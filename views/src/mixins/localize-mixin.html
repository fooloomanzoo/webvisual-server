<link rel="import" href="fetch-mixin.html">
<script>
  window.WebvisualMixins = window.WebvisualMixins || {};

  WebvisualMixins.LocalizeMixin = function(superClass) {
    /**
     *  Mixin that adds localization to page
     *  modification of PolymerElements/app-localize-mixin for simplification reasons
     *
     * @mixinClass
     * @polymer
     */
    return class extends WebvisualMixins.FetchMixin(superClass) {

      constructor() {
        super();
      }

      static get properties() {
        return {

          useWindowLanguage: {
            type: Boolean,
            value: true,
            observer: '_windowLanguageListener'
          },

          language: {
            type: String
          },
          fallbackLanguage: {
            type: String,
            value: 'en'
          },
          /**
           * For example, a valid dictionary would be:
           * this.languageResources = {
           *  'en': { 'greeting': 'Hello!' }, 'fr' : { 'greeting': 'Bonjour!' }
           * }
           */
          languageResources: {
            type: Object
          },
          languageResourcePath: {
            type: String
          },
          /**
           * Translates a string to the current 'language'. Any parameters to the
           * string should be passed in order, as follows:
           * 'localize(stringKey, param1Name, param1Value, param2Name, param2Value)'
           */
          localize: {
            type: Function
          },

          __supportedLanguages: {
            type: Array
          }
        }
      }

      static get observers() {
        return [
          '_loadLanguageResources(languageResourcePath)',
          '_updateLanguage(language, languageResource)'
        ]
      }

      _loadLanguageResources(languageResourcePath) {
        this._fetch(languageResourcePath, 'GET', 'include', 'json', 'languageResource', true, true)
          .catch(err => {
            console.log(err);
          });
      }

      /**
       * Returns a computed 'localize' method, based on the current 'language'.
       */
      __computeLocalize(language, languageResources) {
        var fallback = this.fallbackLanguage;
        return function() {
          var fallbackLanguage = fallback;

          if (!arguments[0])
            return '';

          if (!languageResources) {
            return arguments[0];
          }

          if (!(language && languageResources[language]))
            language = fallbackLanguage;

          var translatedValue = languageResources[language];

          for (var i = 0; i < arguments.length; i++) {
            if (!translatedValue)
              break;
            translatedValue = translatedValue[arguments[i]];
          }

          // if not present in resources, then use fallbackLanguage
          if (!translatedValue) {
            translatedValue = languageResources[fallbackLanguage];
            for (var i = 0; i < arguments.length; i++) {
              if (!translatedValue)
                break;
              translatedValue = translatedValue[arguments[i]];
            }
          }

          // if not present in resources, then return the (requested) key
          if (!translatedValue) {
            translatedValue = arguments[0];
          }
          return translatedValue;
        };
      }

      _updateLanguage(language, languageResources) {
        if (language === undefined || languageResources === undefined) return;

        this.set('__supportedLanguages', Object.keys(languageResources));

        language = language.toLowerCase();

        // check for sub groups of languages and set them to main member of language sets (for simplification)
        if (this.__supportedLanguages.indexOf(language) !== -1) {
          language = language.split('-')[0];
        }
        if (this.__supportedLanguages.indexOf(language) !== -1) {
          this.set('localize', this.__computeLocalize(language, languageResources));
        } else {
          this.set('localize', this.__computeLocalize(language, languageResources));
        }
      }

      _windowLanguageListener(useWindowLanguage) {
        if (useWindowLanguage === true) {
          this.set('language', window.navigator.language);
          window.addEventListener('languagechange', this._setLanguage.bind(this));
        } else {
          window.removeEventListener('languagechange', this._setLanguage.bind(this));
        }
      }

      _setLanguage(language) {
        language = language || window.navigator.language;
        this.set('language', language);
      }

    }
  }
</script>
