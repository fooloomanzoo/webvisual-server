<link rel='import' href='scale-mixin.html'>
<link rel='import' href='localize-mixin.html'>

<script>
  window.WebvisualMixins = window.WebvisualMixins || {};

  WebvisualMixins.AxesMixin = function(superClass) {
    /**
     * Mixin that adds a multiple axis with scaling brushes to an svg using d3
     *
     * @mixinClass
     * @polymer
     */
    return class extends WebvisualMixins.ScaleMixin(superClass) {

      constructor() {
        super();
      }

      static get properties() {
        return {
          /**
           * position of the axes
           * e.this. :
           *  {
           *    x: 'bottom'
           *    y: 'top'
           *  }
           */
          axisPositionX: {
            type: String,
            value: 'bottom'
          },

          axisPositionY: {
            type: String,
            value: 'left'
          },
          /**
           * transition time in ms when changing position
           */
          axisTransitionTime: {
            type: Number,
            value: 100
          },
          /**
           * title to show, when hovering
           */
          axisTitle: {
            type: String
          },
          /**
           * color for axis
           */
          axisColor: {
            type: String,
            observer: '_axisColorChanged'
          },
          /**
           * tick size in pixel
           */
          tickSize: {
            type: Number,
            value: 8
          },

          /**
           * insertion point of the axes
           */
          _axisInsertionPoint: {
            type: Object
          },
          /**
           * nodes of the axes by keys
           */
          axisX: {
            type: Object
          },
          axisY: {
            type: Object
          },
          /**
           * generator functions of the axes by keys
           */
          axisGeneratorX: {
            type: Function
          },

          axisGeneratorY: {
            type: Function
          },
          /**
           * generator functions of the brushes axes by keys
           */
          axisBrushGeneratorX: {
            type: Function,
            value: function() {
              return d3.brushX().on('end', this._onAxisBrushEnd.bind(this));
            }
          },

          axisBrushGeneratorY: {
            type: Function,
            value: function() {
              return d3.brushY().on('end', this._onAxisBrushEnd.bind(this));
            }
          },

          timeFormat: {
            type: Function,
            value: function() {
              return d3.timeFormat
            }
          },

          numberFormat: {
            type: Function,
            value: function() {
              return d3.format
            }
          },

          localeNumber: {
            type: Object
          },

          localeDate: {
            type: Object
          }

        }
      }


      static get observers() {
        return [
          '_setDateNumberFormat(localeNumber, localeDate)'
        ]
      }

      _updateAxisFormat(numberFormat, timeFormat) {
        if (this.axisGeneratorX) {
          this.axisGeneratorX = this._computeAxisGenerator(this.axisPositionX, this.scaleX, this.scalingX, this.scaleBaseX);
          if (this.axisX) {
            this.axisX.call(this.axisGeneratorX.tickSize(this.tickSize).tickFormat(this.axisX.classed('expanded') ? null : ''));
            console.log('recall because of format')
          }
        }
        if (this.axisGeneratorY) {
          this.axisGeneratorY = this._computeAxisGenerator(this.axisPositionY, this.scaleY, this.scalingY, this.scaleBaseY);
          if (this.axisY) {
            this.axisY.call(this.axisGeneratorY.tickSize(this.tickSize).tickFormat(this.axisY.classed('expanded') ? null : ''));
            console.log('recall because of format')
          }
        }
      }

      _updateAxisBrushGenerator(range, pos, tickSize) {
        tickSize = tickSize || 8;
        var extent = [[0,0],[range[1],range[0]]]
        if (pos === 'left') {
          extent[0][0] = -tickSize;
        } else if (pos === 'right') {
          extent[1][0] = tickSize;
        } else if (pos === 'top') {
          extent[0][1] = -tickSize;
        } else if (pos === 'bottom') {
          extent[1][1] = tickSize;
        }
        this.extent(extent);
      }

      _computeAxisGenerator(pos, scale, scaling, base) {
        if (!pos || scale === undefined || scaling === undefined)  return;
        var tickSize = this.tickSize || 6;
        return ((pos === 'left') ? d3.axisLeft(scale) :
          (pos === 'right') ? d3.axisRight(scale) :
          (pos === 'top') ? d3.axisTop(scale) :
            d3.axisBottom(scale)).tickSize(tickSize).tickFormat(this._computeFormatFn(scaling, base));
      }
      //
      // _computeAxisBrushGenerator(pos) {
      //   if (!pos)  return;
      //   var vertical = this._isVertical(pos);
      //   var gen = (vertical ? d3.brushY() : );
      //   if (vertical && this.rangeY) {
      //     this._updateAxisBrushGenerator.call(gen, this.rangeY, pos, this.tickSize);
      //   } else if (!vertical && this.rangeX) {
      //     this._updateAxisBrushGenerator.call(gen, this.rangeX, pos, this.tickSize);
      //   }
      //   return gen;
      // }

      _computeAxisNode(insertionPoint, title) {
        if (insertionPoint === undefined) return;
        var color = this.axisColor || '';
        title = title || this.axisTitle || '';

        var axis = insertionPoint.append('svg:g')
          .classed('axis', true)
          .style('color', color);

        axis.on('click', function() {
            var expanded = d3.select(this).classed('expanded');
            d3.select(this).classed('expanded', !expanded);
            this._genitor.sizeChanged();
          })
          .call(d3.drag()
            .on('start', this._onAxisDragStart)
            .on('drag', this._onAxisDragged)
            .on('end', this._onAxisDragEnd));
        // add title
        axis.append('svg:title').text(title);
        axis.append('svg:g')
          .classed('brush', true)
        axis.node()._genitor = this;
        axis.node()._axis = axis;
        axis._left = 0;
        axis._right = 0;
        axis._bottom = 0;
        axis._top = 0;

        return axis;
      }

      _setAxisProperties(axis, axisGenerator, expanded) {
        axis.classed('expanded', expanded);
        axisGenerator.tickFormat(expanded ? null : '');
      }

      _removeAxes() {
        if (this.axisX && this.axisX.node) {
          var node = this.axisX.node();
          if (node && node.parentElement)
            node.parentElement.removeChild(node);
          this.axisX = null;
        }
        if (this.axisY && this.axisY.node) {
          var node = this.axisY.node();
          if (node && node.parentElement)
            node.parentElement.removeChild(node);
          this.axisY = null;
        }
        delete this.axisGeneratorY;
        delete this.axisGeneratorX;
        delete this.axisBrushGeneratorY;
        delete this.axisBrushGeneratorX;
      }

      _onAxisDragStart() {
        d3.select(this).raise().classed('dragged', true);
        this._left = d3.event.x;
        this._top = d3.event.y;
        console.log('dragged', d3.event, this._left, this._top);
      }
      _onAxisDragged() {
        var vertical = d3.select(this).classed('vertical'), left = 0, top = 0;
        console.log(d3.event)
        if (vertical) {
          left = (this._axis._left || 0) + d3.event.x - this._left;
        } else {
          top = (this._axis._top || 0) + d3.event.y - this._top;
        }
        d3.select(this).attr('transform', 'translate(' + left + ',' + top + ')');

        // d3.select(this).attr('cx', d.x = d3.event.x).attr('cy', d.y = d3.event.y);
      }
      _onAxisDragEnd() {
        d3.select(this).classed('dragged', false);
        var vertical = d3.select(this).classed('vertical'), left = 0, top = 0;
        if (vertical) {
          left = d3.event.x;
          if (this._width) {
            this._position = (left > this._width / 2) ? 'right' : 'left';
          }
        } else {
          top = d3.event.y;
          if (this._height) {
            this._position = (top > this._height / 2) ? 'bottom' : 'top';
          }
        }
        d3.select(this).attr('transform', 'translate(' + left + ',' + top + ')');
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: true,
          composed: true,
          node: this
        }));
        console.log('dragged', this, d3.event);
      }
      _onAxisBrushEnd(key) {
        var s = d3.event.selection;
        console.log('brushend', s);
        if (s) {
          if (s[0] === s[1]) {
            var expanded = this._axis[key].classed('expanded');
            var brushed = this._axis[key]._isBrushed;
            if (!expanded) {
              this._axis[key].classed('expanded', true)
            } else if (brushed) {
              this._axis[key]._isBrushed = false;
              this._getDomain(key).then( (d) => {
                this.set('domain.' + d.key, d.domain);
                this._axisBrush[key].call(this._axisBrushGenerator[key].move, null);
              })
              return;
            }
          } else {
            this._axis[key]._isBrushed = true;
            s = s.map(this.scale[key].invert, this.scale[key]).sort((a, b) => { return a > b});
            console.log(s);
            this.set('domain.' + key, s);
          }
          this._axisBrush[key].call(this._axisBrushGenerator[key].move, null);
          return;
        }
        this.redraw();
      }

      _axisColorChanged(color) {
        if (this.axisX) this.axisX.style('color', color);
        if (this.axisY) this.axisY.style('color', color);
      }

      static get _VALID_AXIS_POSITIONS() {
        return ['top', 'right', 'bottom', 'bottom'];
      }

      _isVertical(pos) {
        return pos === 'left' || pos === 'right';
      }

      _computeFormatFn(scale, base) {
        if (scale === 'time') {
          return this.formatTime.bind(this);
        } else {
          return this.formatNumber.bind(this, scale, base);
        }
      }

      sizeChanged() {
      }
      redraw() {
      }

      formatTime(date) {
        return (d3.timeSecond(date) < date ? this.timeFormat(':%S.%L') :
          d3.timeMinute(date) < date ? this.timeFormat(':%M:%S') :
          d3.timeHour(date) < date ? this.timeFormat('%H:%M') :
          d3.timeDay(date) < date ? this.timeFormat('%X') :
          d3.timeWeek(date) < date ? this.timeFormat('%d.%m') :
          d3.timeMonth(date) < date ? this.timeFormat('%d.%m') :
          d3.timeYear(date) < date ? this.timeFormat('%d. %b') :
          this.timeFormat('%Y'))(date);
      }
      /**
       * format date according to a time-range and pixel-range
       **/
      formatTimeRange(date, range, pixels) {
        var rangeRatio = (range[1] - range[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.timeFormat(':%S.%L') :
          rangeRatio < 5E2 ? this.timeFormat(':%M:%S.%L') :
          rangeRatio < 5E3 ? this.timeFormat(':%M:%S') :
          rangeRatio < 2E4 ? this.timeFormat('%H:%M:%S') :
          rangeRatio < 6E4 ? this.timeFormat('%H:%M') :
          rangeRatio < 36E5 ? this.timeFormat('%X') :
          rangeRatio < 864E5 ? this.timeFormat('%d.%m') :
          rangeRatio < 6048E5 ? this.timeFormat('%d.%m') :
          rangeRatio < 24192E5 ? this.timeFormat('%d. %b') :
          this.timeFormat('%Y'))(date);
      }
      /**
       * format absolute time (like differences)
       * e.g. 3600001 => 1h 1ms
       **/
      formatTimeAbsolute(date) {
        // one year = 365.25 days = 315576E5ms (Julian Calendar)
        var ry = date % 315576E5,
          y = (date - ry) / 315576E5,
          rd = ry % 864E5,
          d = (ry - rd) / 864E5,
          rh = rd % 36E5,
          h = (rd - rh) / 36E5,
          rm = rh % 6E4,
          m = (rh - rm) / 6E4,
          rs = rm % 1E3,
          s = (rm - rs) / 1E3,
          ret = '';
        if (y)
          ret += y + 'y ';
        if (d)
          ret += d + 'd ';
        if (h)
          ret += h + 'h ';
        if (m)
          ret += m + 'm ';
        if (s)
          ret += s + 's ';
        if (rs)
          ret += rs + 'ms';
        return ret;
      }

      formatNumber(scale, num) {
        // format with thousands separators
        return this.numberFormat(',')(num);
      }

      _setDateNumberFormat(localeNumber, localeDate) {
        if (localeDate === undefined || localeNumber === undefined) return;

        if (localeDate) {
          this.localeDate = localeDate;
          d3.timeFormatDefaultLocale(localeDate);
          this.timeFormat = d3.timeFormatLocale(localeDate).format;
        }
        if (localeNumber) {
          this.localeNumber = localeNumber;
          d3.formatDefaultLocale(localeNumber);
          this.numberFormat = d3.formatLocale(localeNumber).format;
        }

        if (this.axisGeneratorX) {
          this.axisGeneratorX = this._computeAxisGenerator(this.axisPositionX, this.scaleX, this.scalingX, this.scaleBaseX);
          if (this.axisX) {
            this.axisX.call(this.axisGeneratorX.tickSize(this.tickSize).tickFormat(this.axisX.classed('expanded') ? null : ''));
            // console.log('recall because of format')
          }
        }
        if (this.axisGeneratorY) {
          this.axisGeneratorY = this._computeAxisGenerator(this.axisPositionY, this.scaleY, this.scalingY, this.scaleBaseY);
          if (this.axisY) {
            this.axisY.call(this.axisGeneratorY.tickSize(this.tickSize).tickFormat(this.axisY.classed('expanded') ? null : ''));
            // console.log('recall because of format')
          }
        }
      }

    }
  }
</script>
