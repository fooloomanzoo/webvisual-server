<!-- Dependent to be content of device-chart -->
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="behaviors/device-behavior.html" />
<link rel="import" href="behaviors/color-behavior.html" />

<dom-module id="device-graph">
  <template>
    <style></style>
  </template>
  <script>
    class DeviceGraph extends WebvisualBehaviors.ColorBehavior(WebvisualBehaviors.DeviceBehavior(Polymer.Element)) {

      static get is() {
        return 'device-graph';
      }

      static get properties() {
        return {

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: '_interpolationChanged'
          },

          hasLine: {
            type: Boolean,
            value: true,
            observer: '_lineChanged'
          },

          hasArea: {
            type: Boolean,
            value: false,
            observer: '_areaChanged'
          },

          hasXAxis: {
            type: Boolean,
            value: true,
            observer: '_axisChanged'
          },

          hasYAxis: {
            type: Boolean,
            value: true,
            observer: '_axisChanged'
          },

          lineWidth: {
            type: Number,
            value: 1,
            observer: '_lineWidthChanged'
          },

          axis: {
            type: Object,
            value: function() {
              return {
                x: {
                  dependend: false,
                  scale: 'time',
                  expanded: false,
                  position: 'bottom'
                },
                y: {
                  dependend: false,
                  scale: 'linear',
                  expanded: false,
                  position: 'left'
                }
              }
            },
            observer: '_axesChanged'
          },

          dotRadius: {
            type: Number,
            value: 3
          },

          viewLength: {
            type: Number,
            value: Number.POSITIVE_INFINITY
          },

          storeInside: {
            type: Boolean,
            value: false,
            readOnly: true
          }
        }
      }

      constructor() {
        super();
        this._isAttached = false;
        this.chartElement = null;
        this._nodes = {
          area: {},
          line: {},
          boundery: {},
          axis: {},
          brush: {}
        };
        this._fn = {
          var: {},
          axis: {},
          brush: {}
        }
        this._generators: {
          brush: {},
          axis: {},
          area: {},
          line: {}
        }

        this._generators.area = d3.area()
          .defined(this._defined.bind(this))
          .x(d => {
            return this._fn.var.x(d.x);
          })
          .y0(d => {
            if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
              return this.chartElement._height;
            } else {
              return this._fn.var.y(0)
            }
          })
          .y1(d => {
            return this._fn.var.y(d.y);
          });

        this._generators.line = d3.line()
          .defined(this._defined.bind(this))
          .x(d => {
            return this._fn.var.x(d.x);
          })
          .y(d => {
            return this._fn.var.y(d.y);
          });

        this.bisectDate = d3.bisector((d, x) => {
          return d.x - x;
        });
      }

      _getContainerRoot() {
        return new Promise((resolve, reject) => {
          var root = Polymer.dom(this).getOwnerRoot();
          if (!root)
            resolve(Polymer.dom(this).parentNode);
          else if (root.host || root.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
            resolve(root.host);
          else
            reject();
        });
      }

      static get observers() {
        return [
          '_itemChanged(item)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.item) {
          this.addNodes();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeNodes();
      }

      addNodes() {
        console.log('addNotes');
        if (this._isAttached) {
          this.clearValues(true);
        }
        this._getContainerRoot()
          .then(containerRoot => {
            if (!containerRoot || containerRoot.nodeName !== 'DEVICE-CHART') {
              console.warn('No parentElement (chart) for graph found. Registration of Graph Element failed', containerRoot);
              return;
            } else if (!containerRoot._isAttached) {
              console.warn('Chart has not been attached yet for adding a graph. Registration of Graph Element failed');
              return;
            }
            this.chartElement = containerRoot;
            this.chartElement._graphs[this.item.mount] = this;
            this._axisChanged(this.hasXAxis, 'x');
            this._axisChanged(this.hasYAxis, 'y');
            this._areaChanged(this.hasArea);
            this._lineChanged(this.hasLine);
            this._setColorProperties();

            // if (!this.chartElement._height || !this.chartElement._width) {
            //   this.chartElement._sizeChanged();
            // }

            this._isAttached = true;
            this.chartElement._sizeChanged();
          })
          .catch(err => {
            console.warn('Error in building graph:', err.stack);
          })
      }

      _areaChanged(hasArea) {
        if (!(this.chartElement && this.chartElement._areas)) return;

        if (hasArea === false) {
          // remove fill area
          if (this._nodes.area && this._nodes.area.node) {
            node = this._nodes.area.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this._nodes.area = null;
          }
        } else {
          if (!(this._nodes.area && this._nodes.area.node)) { // add fill area
            this._nodes.area = this.chartElement._areas.append('svg:path')
          }
          // update fill area node properties
          this._nodes.area
            .attr('data-name', this.item.mount)
            .attr('class', 'area')
            .attr('stroke-width', 0)
            .datum([])
            .attr('d', this._generators.area);
        }
      }

      _lineChanged(hasLine) {
        if (!(this.chartElement && this.chartElement._lines)) return;

        if (hasLine === false) {
          // remove line
          if (this._nodes.line && this._nodes.line.node) {
            node = this._nodes.line.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this._nodes.line = null;
          }
        } else {
          if (!(this._nodes.line && this._nodes.line.node)) { // add line node
            this._nodes.line = this.chartElement._lines.append('svg:path')
          }
          // update line node properties
          this._nodes.line
            .attr('data-name', this.item.mount)
            .attr('class', 'line')
            .attr('fill', 'none')
            .attr('stroke-width', this.lineWidth)
            .datum([])
            .attr('d', this._generators.line);
        }
      }

      _axisChanged(hasAxis, kind) {
        if (!(this.chartElement && this.chartElement._axes)) return;

        if (!kind) {
          this._axisChanged(hasAxis, 'x');
          this._axisChanged(hasAxis, 'y');
          return;
        }

        if (hasAxis === false) {
          this.fn[kind] = this.chartElement.fn[kind];
          // remove axis
          if (this.axis[kind] && this.axis[kind].node) {
            node = this.axis[kind].node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this.axis[kind].node = null;
          }
        } else if (hasAxis === true) {
          // add scale function
          this.fn[kind] = this.chartElement._createScaleFn(this.scale[kind]);
          // add scale function for axis brush
          // this.brushFn[kind] = this.chartElement._createScaleFn(this.scale[kind]);
          // add x axis function
          this.axisFn[kind] = this._createAxisFn(this.fn[kind], this.axisPosition[kind], this.scale[kind]);

          if (!(this.axis[kind] && this.axis[kind].node)) {
            // add x axis
            this.axis[kind] = this.chartElement._axes.append('svg:g')
              .classed('axis', true)
              .classed(kind, true);
          }
          // update axis node properties
          this.axisNode[kind]
            .classed('expanded', this.axisExpanded[kind])
            .attr('data-name', this.item.mount)
            .on('click', this._toggleXAxisExpansion.bind(this));

          if (!this.brush[kind]) {
            // add brush
            switch (kind) {
              case 'x':
                this.brush.x = d3.brushX();
                break;
              case 'y':
                this.brush.y = d3.brushY();
                break;
              default:
                this.brush[kind] = d3.brush();
            }
          }

          this.brush[kind].on("move", this.brushMove.bind(this, kind))
                          .on("end", this.brushEnd.bind(this, kind));
          if (!this.brushNode[kind]) {
            // add brush node
            this.xAxisBrushNode = this.xAxisNode.append('svg:g').classed('brush', true).classed('x', true);
          }
          // update x brush
          this.xAxisBrush.extent([[0, (this.xAxisPosition === 'top') ? (-this.chartElement.tickSize) : 0], [this.chartElement._width, (this.xAxisPosition === 'top') ? 0 :   this.chartElement.tickSize]]);
          this.xAxisBrushNode.raise().call(this.xAxisBrush);
          // getting a domain range for x
          this._getDomain('x', this.xScale)
            .then( domain => {
              console.log(domain);
              this._fn.var.x.domain(domain);
              // this._fn.var.xBrush.domain(domain);
            })
            .catch( err => {});
        }
      }

      _yAxisChanged(hasYAxis) {
        if (!(this.chartElement && this.chartElement._yAxes)) return;

        if (hasYAxis === false) {
          this._fn.var.y = this.chartElement._fn.var.y;
          // remove y axis
          if (this.yAxisNode && this.yAxisNode.node) {
            node = this.yAxisNode.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
          }
          this.yAxisNode = null;
          this.yAxisFn = null;
        } else {
          // add scale function
          this._fn.var.y = this.chartElement._createScaleFn(this.yScale);
          // add scale function for axis brush
          // this._fn.var.yBrush = this.chartElement._createScaleFn(this.yScale);

          if (!this.yAxisFn) {
            // add y axis function
            this.yAxisFn = this._createAxisFn(this._fn.var.y, this.yAxisPosition, this.yScale);
          }
          if (!(this.yAxisNode && this.yAxisNode.node)) {
            // add y axis
            this.yAxisNode = this.chartElement._yAxes.append('svg:g')
          }
          // update y axis node properties
          this.yAxisNode
            .classed('y axis', true)
            .classed('expanded', this.yAxisExpanded)
            .attr('data-name', this.item.mount)
            .on('click', this._toggleYAxisExpansion.bind(this));
          if (!this.yAxisBrush) {
            // add y brush
            this.yAxisBrush = d3.brushY().on("end", this.brushMoveY.bind(this));
          }
          if (!this.yAxisBrushNode) {
            // add x brush node
            this.yAxisBrushNode = this.yAxisNode.append('svg:g').classed('brush', true).classed('y', true);
          }
          // update y brush
          this.yAxisBrush.extent([[this.yAxisPosition === 'left' ? -this.chartElement.tickSize : 0, 0], [this.yAxisPosition === 'left' ? 0 : this.chartElement.tickSize, this.chartElement._height]]);
          this.yAxisBrushNode.raise().call(this.yAxisBrush);

          // getting a domain range for y
          this._getDomain('y', this.yScale)
            .then( range => {
              this._fn.var.y.domain(range).nice(this.yTicks);
              var domain = this._fn.var.y.domain();
              // if domain is on the edge of data, add a little space
              if (domain[0] === range[0]) {
                domain[0] -= (range[1] - range[0]) / ticks;
              }
              if (domain[1] === range[1]) {
                domain[1] += (range[1] - range[0]) / ticks;
              }
              console.log(domain);
              this._fn.var.y.domain(domain);
              // this._fn.var.yBrush.domain(domain);
            })
            .catch( err => {console.log(err);});

        }
      }

      brushMoveY() {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        console.log(d3.event.selection);
        var s = (d3.event.selection || this._fn.var.y.range()).map(this._fn.var.y.invert, this._fn.var.y);
        console.log(s);
        this._fn.var.y.domain(s);
        if (this.hasArea) {
          this._nodes.area.attr("d", this._generators.area);
        }
        if (this.hasLine) {
          this._nodes.line.attr("d", this._generators.line);
        }
        this.yAxisNode.call(this.yAxisFn);
      }

      brushEndY() {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        console.log(d3.event.selection);
        var s = (d3.event.selection || this._fn.var.y.range()).map(this._fn.var.y.invert, this._fn.var.y);
        console.log(s);
        this._fn.var.y.domain(s);
        if (this.hasArea) {
          this._nodes.area.attr("d", this._generators.area);
        }
        if (this.hasLine) {
          this._nodes.line.attr("d", this._generators.line);
        }
        this.yAxisNode.call(this.yAxisFn);
      }

      brushMoveX() {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = (d3.event.selection || this._fn.var.x.range()).map(this._fn.var.x.invert, this._fn.var.x);
        console.log(s);
        this._fn.var.x.domain(s);
        if (this.hasArea) {
          this._nodes.area.attr("d", this._generators.area);
        }
        if (this.hasLine) {
          this._nodes.line.attr("d", this._generators.line);
        }
        this.xAxisNode.call(this.xAxisFn);
      }

      brushEndX() {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = (d3.event.selection || this._fn.var.x.range()).map(this._fn.var.x.invert, this._fn.var.x);
        console.log(s);
        this._fn.var.x.domain(s);
        if (this.hasArea) {
          this._nodes.area.attr("d", this._generators.area);
        }
        if (this.hasLine) {
          this._nodes.line.attr("d", this._generators.line);
        }
        this.xAxisNode.call(this.xAxisFn);
      }

      _getDomain(key, scale) {
        if (!(this.chartElement && (key === 'x' || key === 'y'))) return;

        return new Promise((resolve, reject) => {
          this.requestRange(key)
            .then(range => {
              var domain = range;
              if (key === 'y') {
                // if min, max are equal, add a little space
                if (domain[0] !== undefined && domain[1] !== undefined && domain[0] === domain[1]) {
                  domain[0] -= 0.5;
                  domain[1] += 0.5;
                }
              }

              if (scale === 'ln' || scale === 'log₁₀') {
                if (domain[0] <= 0) {
                  domain[0] = Number.EPSILON;
                }
                if (domain[1] <= 0) {
                  domain[1] = Number.EPSILON;
                }
              }
              resolve(domain);
            })
            .catch(err => {
              reject(err);
            });
        });
      }

      _thresholdChanged(threshold) {
        if (!(this.chartElement && this.chartElement._bounderies)) return;

        if (threshold) {
          if (!this.bounderyLineGradientNode) { // add threshold node
            this.bounderyLineGradientNode = this.chartElement._bounderies.append('linearGradient');
          }
          // update threshold node properties
          this.bounderyLineGradientNode
            .attr('id', 'boundery-line-' + this.item.mount)
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', 0).attr('y1', this.chartElement._height)
            .attr('x2', 0).attr('y2', 0);
        } else {
          // remove threshold colors
          if (this.bounderyLineGradientNode && this.bounderyLineGradientNode.node) {
            node = this.bounderyLineGradientNode.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this.bounderyLineGradientNode = null;
          }
        }
      }

      _createAxisFn(transFn, axisPosition, scale) {
        if (!(this.chartElement && transFn && axisPosition && scale)) {
          return null;
        }
        return this.chartElement._createAxisFn(transFn, axisPosition, scale);
      }

      _toggleYAxisExpansion() {
        this.yAxisExpanded = !this.yAxisExpanded;
        //this.yAxisNode.lower();
        this.yAxisNode.classed('expanded', this.yAxisExpanded);
        this.chartElement._sizeChanged();
      }

      _toggleXAxisExpansion() {
        this.xAxisExpanded = !this.xAxisExpanded;
        //this.xAxisNode.lower();
        this.xAxisNode.classed('expanded', this.xAxisExpanded);
        this.chartElement._sizeChanged();
      }

      _setColorProperties() {
        if (!this.chartElement) return;
        if (this.item && this.item.color) {
          var colorForGraph = this.item.theshold ? ('url(#boundery-line-' + this.item.mount + ')') : this.item.color || '#000';
          if (this._nodes.area && this._nodes.area.attr) this._nodes.area.attr('fill', colorForGraph);
          if (this._nodes.line && this._nodes.line.attr) this._nodes.line.attr('stroke', colorForGraph);
          if (this.yAxisNode && this.yAxisNode.attr) this.yAxisNode.style('color', this.item.color || '#000');
          if (this.xAxisNode && this.xAxisNode.attr) this.xAxisNode.style('color', this.item.color || '#000');
        }
      }

      removeNodes() {
        console.log('removeNodes');
        this._areaChanged();
        this._lineChanged();
        this._xAxisChanged();
        this._yAxisChanged();
        this._thresholdChanged();
        if (this.chartElement && this.chartElement._graphs)
          delete this.chartElement._graphs[this.item.mount];
        this._isAttached = false;
      }

      _itemChanged(item) {
        if (!this._isAttached) {
          return;
        }
        if (!(item && item.mount)) {
          this.removeNodes();
          return;
        }
        this.addNodes();
      }

      insertValues(values, len) {
        if (values === undefined) {
          return;
        }

        var len = len || (this.viewLength > 0 ? this.viewLength : values.length);

        if (!len) {
          values.map(function(v) {
            return {
              x: +v.x,
              y: +v.y,
              state: +v.state
            };
          });
          if (this.storeInside) {
            this.values = this.values.concat(values);
          }
          this.renderInsertedValues(values);
        } else {
          var tmp = values.slice(values.length - len, values.length);
          tmp.map(function(v) {
            return {
              x: new Date(v.x),
              y: +v.y,
              state: +v.state
            };
          });
          if (this.storeInside) {
            this.values = this.values.concat(tmp);
          }
          this.renderInsertedValues(tmp);
          tmp.length = 0;
        }
      }

      spliceValues(splices) {
        // requestAnimationFrame( () => {
        // var changeRecord = [];

        for (var i = 0; i < splices.length; i++) {
          for (var j = this.values.length - 1; j >= 0; j--) {
            if (this.values[j].x === splices[i].x)
              break;
          }
          if (j !== -1) {
            this.values.splice(j, 1);
            // changeRecord.push( { index: j, removed: [this.values[j]], addedCount: 0, object: this.values, type: 'splice'} );
          }
        }

        // })
        // this.notifySplices('values', changeRecord);
        this.redraw();
      }

      renderInsertedValues(values) {
        if (!this._isAttached && this.item) {
          this.addNodes();
        } else if (this.chartElement) {
          // if (this.chartElement._isZoomed === false)
            this.chartElement.redraw();
          // else
          //   this.redraw();
        }
      }

      redraw() {
        if (!(this.chartElement && this.chartElement._isAttached && this.item && this.values && this.values.length)) return;

        console.log('redraw');
        var data = this.values || [];

        // fill area
        if (this.hasArea) {
          if (!(this._nodes.area && this._nodes.area.node)) {
            this._areaChanged(true);
          }
          this._nodes.area
            .datum(data)
            .attr('d', this._generators.area);
        }

        // line
        if (this.hasLine) {
          if (!(this._nodes.line && this._nodes.line.node)) {
            this._lineChanged(true);
          }
          this._nodes.line
            .datum(data)
            .attr('d', this._generators.line);
        }

        // threshold gradients
        if (this.item && this.item.threshold) {
          if (!(this.bounderyLineGradientNode && this.bounderyLineGradientNode.node)) {
            this._thresholdChanged(this.item.threshold);
          }
          var b_line = [],
            y,
            u_color = this.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C',
            l_color = this.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C',
            i_color = this.item.color || '#000';

          if (this.item.threshold.from !== undefined) {
            y = ((1 - Math.ceil(this._fn.var.y(this.item.threshold.from) + this.lineWidth * 1.25) / this.chartElement._height) * 100);
            if (Number.isFinite(y)) {
              b_line.push({
                o: y + '%',
                c: l_color
              });
              b_line.push({
                o: y + '%',
                c: i_color
              });
            }
          }
          if (this.item.threshold.to !== undefined) {
            y = ((1 - Math.floor(this._fn.var.y(this.item.threshold.to) - this.lineWidth * 1.25) / this.chartElement._height) * 100);
            if (Number.isFinite(y)) {
              b_line.push({
                o: y + '%',
                c: i_color
              });
              b_line.push({
                o: y + '%',
                c: u_color
              });
            }
          }
          var gradients = this.bounderyLineGradientNode
            .attr('x1', 0).attr('y1', this.chartElement._height)
            .attr('x2', 0).attr('y2', 0)
            .selectAll('stop')
            .data(b_line);

          gradients.attr('offset', function(d) {
              return d.o;
            })
            .attr('stop-color', function(d) {
              return d.c;
            });

          gradients.enter()
            .append('stop')
            .attr('offset', function(d) {
              return d.o;
            })
            .attr('stop-color', function(d) {
              return d.c;
            });

          gradients.exit()
            .remove();
        }
        // TODO(?): update line, animated http://bl.ocks.org/benjchristensen/1148374
      }

      _defined(d, i) {
        var yScale = this.yScale;

        if (!Number.isFinite(d.y))
          return null;
        else if ((yScale === 'ln' || yScale === 'log₁₀') && d.y <= 0)
          return null; // log- and sqrt-scales require larger than 0-Values
        // else if ((d.x >= domainX[0] && d.x <= domainX[1]) ||
        //   (data[i + 1] && data[i + 1].x >= domainX[0] && data[i + 1].x <= domainX[1]) ||
        //   (data[i - 1] && data[i - 1].x >= domainX[0] && data[i - 1].x <= domainX[1]))
        //   return true; // only numbers in x-Domain are shown (and their successor and predecessor) (graph is a function by definition, so y-Domain is not relevant)
        // else
        //   return false;
        return true;
      }

      // finding the closest Point relativly to a mouse-Coordinate m (stabil)
      // if looking just at to path (instabil): https://bl.ocks.org/mbostock/8027637 https://pomax.github.io/bezierinfo/#projections
      _closestPoint(m) {
        // find good prediction
        var _x = this.chartElement._x,
          _y = this.chartElement._y,
          values = this.values,
          x_0 = _x.invert(m[0]),
          precision = Math.ceil(this.chartElement._width / values.length),
          variance = Math.pow(Math.ceil(values.length / this.chartElement._width), 2),
          mid = this.bisectDate.left(values, x_0, 0, values.length - 1),
          r2 = pixdistance2(values[mid]),
          searchRadius = Math.sqrt(r2) / variance;
        var x_lo = _x.invert(m[0] - searchRadius),
          lo = this.bisectDate.left(values, x_lo, 0, mid),
          hi = 2 * mid - lo;

        if (lo < 0) lo = 0;
        if (hi > values.length) hi = values.length;

        var minDist = r2,
          currentDist,
          pos = mid;
        // linear scan for coarse approximation
        for (i = lo; i < hi; i += precision) {
          if ((currentDist = pixdistance2(values[i])) < minDist) {
            mid = i, minDist = currentDist;
          }
        }
        pos = mid;

        // linear search in positive prediction radius
        for (var i = mid + 1; i < hi && i < mid + precision - 1; i++) {
          if ((currentDist = pixdistance2(values[i])) < minDist) {
            minDist = currentDist;
            pos = i;
          }
        }

        // linear search in negative prediction radius
        for (var i = mid - 1; i > lo && i > mid - precision + 1; i--) {
          if ((currentDist = pixdistance2(values[i])) < minDist) {
            minDist = currentDist;
            pos = i;
          }
        }

        return values[pos];

        function pixdistance2(p) {
          var dx = _fn.var.x(new Date(p.x)) - m[0],
            dy = _fn.var.y(p.y) - m[1];
          return dx * dx + dy * dy;
        }
      }

      // finding the closest interpolated Point relativly to a mouse-Coordinate m
      // https://bl.ocks.org/mbostock/8027637
      // https://pomax.github.io/bezierinfo/#projections
      _closestInterpolatedPoint(point, pathNode) {
        pathNode = pathNode || this._nodes.area.node() || this._nodes.line.node();
        var pathLength = pathNode.getTotalLength(),
          precision = Math.ceil(pathLength / this.chartElement._width / 2.0) * 2,
          best,
          bestLength,
          bestDistance = Infinity;

        // linear scan for coarse approximation
        for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
          if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
            best = scan, bestLength = scanLength, bestDistance = scanDistance;
          }
        }

        // binary search for precise estimate
        precision /= 2;
        while (precision > 0.5) {
          var before,
            after,
            beforeLength,
            afterLength,
            beforeDistance,
            afterDistance;
          if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
            best = before, bestLength = beforeLength, bestDistance = beforeDistance;
          } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
            best = after, bestLength = afterLength, bestDistance = afterDistance;
          } else {
            precision /= 2;
          }
        }

        best = {
          x: this._fn.var.x(best.x),
          y: this._fn.var.y(best.y)
        };
        best.distance = Math.sqrt(bestDistance);
        return best;

        function distance2(p) {
          var dx = p.x - point[0],
            dy = p.y - point[1];
          return dx * dx + dy * dy;
        }
      }

      setColor(color) {
        // random color if color is not set
        super.setColor.call(this, color);
        this._setColorProperties();
      }

      clearValues(force) {
        super.clearValues.call(this, force);
      }

      _getStrokeColor(d) {
        if (this.item.threshold) {
          switch (d.state) {
            case 1:
              return this.getComputedStyleValue('device-state-exceeds-color') || '#F20C0C';
            case -1:
              return this.getComputedStyleValue('device-state-deceeds-color') || '#F20C0C';
          }
        }
        return this.item.color || '#fff';
      }

      _lineWidthChanged(lineWidth) {
        if (this._nodes.line && this._nodes.line.attr) {
          this._nodes.line.attr('stroke-width', lineWidth);
        }
      }

      changeScale(newValue, oldValue) {
        // if (oldValue === undefined) return;
        // var domainY = this._fn.var.y.domain();
        // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
        //   if (domainY[0] <= 0) {
        //     domainY[0] = Number.EPSILON;
        //   }
        //   if (domainY[1] <= 0) {
        //     domainY[1] = Number.EPSILON;
        //   }
        // }
        // this._debouncedHideInfo();
        // this._fn.var.y = this._createScaleFn(this.yScale);
        // this._fn.var.y.domain(domainY).nice(this.yTicks);
        // this.set('domainY', domainY);
        // this._sizeChanged();
      }

      _interpolationChanged(interpolation) {
        var curve;
        switch (interpolation) {
          case 'Basis Spline':
            curve = d3.curveBasis;
            break;
          case 'Monotoner Spline':
            curve = d3.curveMonotoneX;
            break;
          case 'Kubischer Spline':
            curve = d3.curveNatural;
            break;
          case 'Cardinaler Spline':
            curve = d3.curveCardinal;
            break;
          case 'Catmull-Rom-Spline':
            curve = d3.curveCatmullRom;
            break;
          case 'Stufe (mitte)':
            curve = d3.curveStep;
            break;
          case 'Stufe (davor)':
            curve = d3.curveStepAfter;
            break;
          case 'Stufe (danach)':
            curve = d3.curveStepBefore;
            break;
          default:
            curve = d3.curveLinear;
            break;
        }
        this._generators.area.curve(curve);
        this._generators.line.curve(curve);

        if (this.chartElement)
          this.chartElement.redraw();
      }
    }
    customElements.define(DeviceGraph.is, DeviceGraph);
  </script>

</dom-module>
