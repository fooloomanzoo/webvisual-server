<script>
  window.WebvisualBehaviors = window.WebvisualBehaviors || {};

  WebvisualBehaviors.DeviceBehavior = function(superClass) {
    /**
     * Behavior that adds functionality to assign to socket and adds exceed events
     *
     * @mixinClass
     * @polymer
     */
    return class extends superClass {

      constructor() {
        super();
      }

      static get properties() {
        return {
          element: {
            type: Boolean,
            value: true,
            reflectToAttribute: true,
            readOnly: true
          },

          item: {
            type: Object
          },

          values: {
            type: Array,
            value: function() {
              return [];
            }
          },

          isExceeding: {
            type: Boolean,
            value: false
          },

          hasExceeded: {
            type: Boolean,
            value: false
          },

          storeInside: {
            type: Boolean
          },

          viewLength: {
            type: Number,
            value: 1
          },

          noLink: {
            type: Boolean,
            value: false
          },

          _initialized: {
            type: Boolean
          }

        }
      }

      static get observers() {
        return [
          '_exceedingChanged(isExceeding)',
          '_hasExceededChanged(hasExceeded)',
          '_linkElement(item, noLink)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._linkElement(this.item, this.noLink);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._unlinkElement();
        this.clearValues();
      }

      _linkElement(item, noLink) {
        if (!(item && item.mount)) {
          return;
        }
        if (this._olditem) {
          if (item.mount === this._olditem.mount && !noLink) {
            return;
          }
          this._unlinkElement(this._olditem);
        }

        if (noLink) {
          return;
        }

        if (window.Webvisual && window.Webvisual.assignElement) {
          window.Webvisual.assignElement(this);


        this._olditem = item;
        this.clearValues();
        this.resetState();

        this.requestValues(null, null, this.viewLength)
          .then(data => {
            for (var mount in data) {
              if (mount === this.item.mount) {
                this.insertValues(data[mount]);
                break;
              }
            }
          })
          .catch(err => {
            // if (err) {
            //   console.log(err);
            // }
          });
        }
      }

      _unlinkElement(item) {
        item = item || this.item || this._olditem;
        if (window.Webvisual && Webvisual.retractElement && item && item.mount) {
          window.Webvisual.retractElement(this, item);
          this._olditem = null;
        }
      }

      getElement() {
        return this.properties;
      }

      computeDate(x) {
        return x ? (Math.abs(Date.now() - x) < 864E5 ? new Date(x).toLocaleTimeString() : new Date(x).toLocaleString()) : '';
      }

      computeValue(y, state) {
        return (this.item && this.item.isIndicatorLamp) ? (state ? '✗' : '✓') : y;
      }

      insertValues(values, len) {
        if (values === undefined) {
          return;
        }

        var len = len || this.viewLength;

        // len = (len && isFinite(len) && len <= values.length) ? len : ( (this.viewLength && isFinite(this.viewLength) && this.viewLength <= values.length) ? this.viewLength : values.length );

        if (!this._initialized)
          this._initialized = true;

        if (!len) {
          if (this.item && this.item.exceedable === true) {
            values.forEach(value => {
              this.checkExceedingState(value);
            })
          }
          if (this.storeInside) {
            this.values = this.values.concat(values);
          }
          // console.log(this.values);
          this.renderInsertedValues(values);
        } else {
          var tmp = values.slice(values.length - len, values.length);
          if (this.item && this.item.exceedable === true) {
            tmp.forEach(value => {
              this.checkExceedingState(value);
            })
          }
          if (this.storeInside) {
            this.values = this.values.concat(tmp);
          }
          this.renderInsertedValues(tmp);
          tmp.length = 0;
        }
        values.length = 0;
      }

      spliceValues(splices) {
        if (splices) {
          if (this.storeInside === true) {
            this.values = this.values.filter(v => {
              return splices.indexOf(v) === -1;
            })
            this.notifyPath('values');
            // this.splice('values', 0, splices.length);
          }
          if (this.renderSplicedValues) {
            this.renderSplicedValues(splices);
          }
        }
      }

      resetValues(values) {
        this.values = values;
        this.notifyPath('values');
        this.renderInsertedValues(this.values);
      }

      clearValues(force) {
        this.values = [];
        this.notifyPath('values');
      }

      requestValues(start, end, len) {
        if (!(this.item && this.item.mount)) {
          return new Promise((resolve, reject) => {
            reject();
          })
        }
        len = len || this.viewLength || 1;
        var req = {
          target: 'cache',
          operation: 'request',
          args: {
            mounts: [this.item.mount],
            from: null,
            to: null,
            length: len || 1
          }
        };

        if (window.Webvisual) {
          return new Promise((resolve, reject) => {
            window.Webvisual.request(req, resolve);
          })
        } else {
          return new Promise((resolve, reject) => {
            if (this.values)
              resolve(this.values.slice(this.values.length - len, this.values.length))
            else {
              reject();
            }
          });
        }
      }

      requestRange(key) {
        if (!(this.item && this.item.mount)) {
          return new Promise((resolve, reject) => {
            reject();
          })
        }
        var req = {
          target: 'cache',
          operation: 'range',
          forced: true,
          args: {
            mounts: [this.item.mount],
            key: key
          }
        };

        if (!this.storeInside && window.Webvisual) {
          return new Promise( (resolve, reject) => {
            window.Webvisual.request(req, resolve);
          })
        } else {
          return new Promise( (resolve, reject) => {
            if (this.values && this.values.length) {
              var min = this.min(this.values, key);
              var max = this.max(this.values, key);
              if (!(min === undefined && max === undefined)) {
                resolve( [ min, max ] );
              }
            }
            reject();
          });
        }
      }

      min(array, key) { // inspired by d3.array
        var i = -1,
            a,
            b;
        var n = array.length;
        while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
        while (++i < n) if ((b = array[i][key]) !== null && a > b) a = b;
        return a;
      }

      max(array, key) { // inspired by d3.array
        var i = -1,
            a,
            b;
        var n = array.length;
        while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
        while (++i < n) if ((b = array[i][key]) !== null && a < b) { a = b; }
        return a;
      }

      renderInsertedValues(values) {}

      renderSplicedValues(values) {}

      renderClearing(values) {}

      checkExceedingState(value) {
        if (!this.item || this.item.exceedable === false || value === undefined) return;

        if (value.state === 0) {
          if (this.isExceeding === true) {
            this.isExceeding = false;
          }
        } else {
          if (this.isExceeding !== true) {
            this.isExceeding = true;
            if (this.hasExceeded === false)
              this.set('hasExceeded', true);
          }
        }
      }

      _exceedingChanged(isExceeding, old) {
        if (this.item && this.item.exceedable === true) {
          this.dispatchEvent(new CustomEvent('exceeding', {
            bubbles: true,
            composed: true,
            detail: {
              item: this.item,
              value: isExceeding
            }
          }));
        }
      }

      _hasExceededChanged() {}

      resetState() {
        if (this.resetColor)
          this.resetColor();
        this.isExceeding = false;
        this.hasExceeded = false;
        this._initialized = false;
        this.renderClearing();
      }
    }
  }
</script>
