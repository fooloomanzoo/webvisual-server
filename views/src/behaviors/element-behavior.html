<script>
  window.WebvisualBehaviors = window.WebvisualBehaviors || {};

  /**
   * Behavior that adds functionality to assign to socket and adds exceed events
   *
   * @polymerBehavior
   */

  WebvisualBehaviors.ElementBehavior = {

    properties: {

      item: Object,

      values: {
        type: Array,
        value: function() {
          return [];
        }
      },

      isExceeding: {
        type: Boolean,
        value: false
      },

      hasExceeded: {
        type: Boolean,
        value: false
      },

      storeInside: Boolean,

      viewLength: {
        type: Number,
        value: 1
      },

      uniqueid: {
        type: String,
        reflectToAttribute: true
      },

      noLink: {
        type: Boolean,
        value: false
      }

    },

    // communication count to webworker
    _messageCount: 0,

    observers: [
      '_exceedingChanged(isExceeding)',
      '_hasExceededChanged(hasExceeded)',
      '_linkElement(item.mount, uniqueid, noLink)'
    ],

    hostAttributes: {
      element: true
    },

    ready: function() {
      var sel, uniqueid;
      while (true) { // TODO: not valid in ShadowDOM
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.set('uniqueid', uniqueid);
    },

    factoryImpl: function(obj, properties) {
      this._linkElement(obj, properties);
    },

    detached: function() {
      this._unlinkElement();
      this.clearValues();
    },

    _linkElement: function(mount, uniqueid, noLink) {
      if (this._olditem) {
        this._unlinkElement(this._olditem);
      }
      if (!(mount && uniqueid && !noLink)) {
        return;
      }
      this._olditem = this.item;
      if (this._initialized) {
        this.clearValues();
      }
      if (window.Webvisual && window.Webvisual.assignElement && this.item && this.item.mount) {
        window.Webvisual.assignElement(this);
      }

      this.requestValues(null, null, this.viewLength)
          .then( function(data) {
            for (var mount in data) {
              if (mount === this.item.mount) {
                this.insertValues(data[mount]);
                break;
              }
            }
          }.bind(this))
          .catch( function(err) {
            // if (err) {
            //   console.log(err);
            // }
          } );
    },

    _unlinkElement: function(item) {
      item = item || this.item || this._olditem;
      if (window.Webvisual && Webvisual.retractElement && item && item.mount) {
        window.Webvisual.retractElement(this, item);
        this._olditem = null;
      }
    },

    getElement: function() {
      return this.properties;
    },

    computeDate: function(x) {
      return x ? (this.fullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString()) : '';
    },

    computeValue: function(y, state) {
      return (this.item && this.item.isIndicatorLamp) ? ( state ? '✗' : '✓' ) : y;
    },

    insertValues: function(values, len) {
      if (values === undefined) {
        return;
      }

      var len = len || this.viewLength;

      // len = (len && isFinite(len) && len <= values.length) ? len : ( (this.viewLength && isFinite(this.viewLength) && this.viewLength <= values.length) ? this.viewLength : values.length );

      if (!this._initialized)
        this._initialized = true;

      if (!len) {
        if (this.item && this.item.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(values);
        }
        // console.log(this.values);
        this.renderInsertedValues(values);
      } else {
        var tmp = values.slice(values.length - len, values.length);
        if (this.item && this.item.exceedable === true) {
          tmp.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(tmp);
        }
        this.renderInsertedValues(tmp);
        tmp.length = 0;
      }
      values.length = 0;
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.storeInside === true) {
          this.values = this.values.filter( function(v) {
            return splices.indexOf(v) === -1;
          })
          this.notifyPath('values');
          // this.splice('values', 0, splices.length);
        }
        if (this.renderSplicedValues) {
          this.renderSplicedValues(splices);
        }
      }
    },

    resetValues: function(values) {
      this.values = values;
      this.notifyPath('values');
      this.renderInsertedValues(this.values);
    },

    clearValues: function(force) {
      if (this._initialized || force) {
        if (this.selected) {
          this.selected = false;
        }
        this.values = [];
        this.notifyPath('values');
        this.resetState();
      }
    },

    requestValues: function(start, end, len) {
      var self = this;
      len = len || this.viewLength || 1;
      var req = {
        target: 'cache',
        operation: 'request',
        args: {
          mounts: [this.item.mount],
          start: null,
          end: null,
          length: len || 1
        }
      };

      if (window.Webvisual) {
        return new Promise(function(resolve, reject) {

          window.Webvisual.request( req, resolve );
        })
      } else {
        return new Promise( function(resolve, reject) {
          if (this.values)
            resolve(this.values.slice(this.values.length - len, this.values.length))
          else {
            reject();
          }
        }.bind(this));
      }
    },

    requestRange: function(key, attempts) {
      var mount = this.mount;
      var uniqueid = this.uniqueid;
      messageCount = this._messageCount++;
      if (!this.storeInside && window.Webvisual && window.Webvisual.webworker) {
        return new Promise( function (resolve, reject) {

          var messageId = 'requestRange' + uniqueId + '#' + messageCount;
          this.webworker.addEventListener('message', function onMessage(e) {
            if (e.data
             && e.data.messageId
             && e.data.messageId === messageId) {
               this.webworker.removeEventListener('message', onMessage);
               if (e.data.response && e.data.response.length === 2) {
                 resolve(e.data.response);
               } else if (attempts) {
                 resolve(this.requestRange(key, attempts--));
               } else {
                 reject(self.item + ': no range received')
               }
             }
          }.bind(this));

          this.webworker.postMessage(
            {
              request: {
                messageId: messageId,
                func: 'rangedValues',
                arg: {
                  mounts: [mount],
                  key: key
                }
              }
            });
        }.bind(window.Webvisual))
      } else {
        return new Promise( function(resolve, reject) {
          if (this.values && this.values.length) {
            var min = this.min(this.values, key);
            var max = this.max(this.values, key);
            resolve( [ min, max ] );
          }
          else {
            // reject('no values are set');
            resolve( [ ] );
          }
        }.bind(this));
      }
    },

	  min: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a > b) a = b;

	    return a;
	  },

    max: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a < b) { a = b; }

	    return a;
	  },

    renderInsertedValues: function(values) {
    },

    renderSplicedValues: function(values) {
    },

    renderClearing: function(values) {
    },

    checkExceedingState: function(value) {
      if (!this.item || this.item.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    _exceedingChanged: function(isExceeding, old) {
      if (this.item && this.item.exceedable === true) {
        this.fire('exceeding', { item: this.item, value: isExceeding });
      }
    },

    _hasExceededChanged: function() {},

    resetState: function() {
      this.isExceeding = false;
      this.hasExceeded = false;
      if (this.checked) {
        this.checked = false;
      }
      if (this.resetColor)
        this.resetColor();
      this.renderClearing();
    }
  };
</script>
