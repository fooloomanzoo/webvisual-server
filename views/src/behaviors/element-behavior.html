<script>
  window.WebvisualBehaviors = window.WebvisualBehaviors || {};

  /**
   * Behavior that adds functionality to assign to socket and adds exceed events
   *
   * @polymerBehavior
   */

  WebvisualBehaviors.ElementBehavior = {

    properties: {

      item: Object,

      values: {
        type: Array,
        value: function() {
          return [];
        }
      },

      isExceeding: {
        type: Boolean,
        value: false
      },

      hasExceeded: {
        type: Boolean,
        value: false
      },

      bubbles: Boolean,

      storeInside: Boolean,

      viewLength: {
        type: Number,
        value: 1
      },

      uniqueid: {
        type: String,
        reflectToAttribute: true
      },

      noLink: {
        type: Boolean,
        value: false
      }

    },

    // communication count to webworker
    _messageCount: 0,

    observers: [
      '_exceedingChanged(isExceeding)',
      '_hasExceededChanged(hasExceeded)',
      '_linkElement(item.mount, uniqueid, noLink)'
    ],

    hostAttributes: {
      element: true
    },

    ready: function() {
      var sel, uniqueid;
      while (true) {
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.set('uniqueid', uniqueid);
    },

    factoryImpl: function(obj, properties) {
      this._linkElement(obj, properties);
    },

    detached: function() {
      this._unlinkElement();
      this.clearValues();
    },

    _linkElement: function(mount, uniqueid, noLink) {
      // console.log(mount , uniqueid , !noLink);
      if (!(mount && uniqueid && !noLink)) {
        return;
      }
      if (this._olditem) {
        this._unlinkElement(this._olditem);
      }
      this._olditem = this.item;
      if (this._initialized) {
        this.clearValues();
      }
      if (window.Webvisual && window.Webvisual.assignElement && this.item && this.item.mount) {
        window.Webvisual.assignElement(this);
      }

      this.requestLastValue()
          .then( (ret) => {
            for (var mount in ret) {
              this.insertValues(ret[mount]);
            }
          })
          .catch( (err) => {
            console.log(err);
          } );
    },

    _unlinkElement: function(item) {
      if (window.Webvisual && Webvisual.retractElement && item && item.mount) {
        window.Webvisual.retractElement(this, item);
      }
    },

    getElement: function() {
      return this.properties;
    },

    computeDate: function(x) {
      return x ? (this.showFullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString()) : '';
    },

    computeValue: function(y, state) {
      return (this.item && this.item.isIndicatorLamp) ? ( state ? '✗' : '✓' ) : y;
    },

    insertValues: function(values, len) {
      if (values === undefined) {
        return;
      }

      var len = len || this.viewLength;

      if (!this._initialized)
        this._initialized = true;

      if (!len) {
        if (this.item && this.item.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(values);
        }
        // console.log(this.values);
        this.renderInsertedValues(values);
      } else {
        var tmp = values.slice(values.length - len, values.length);
        if (this.item && this.item.exceedable === true) {
          tmp.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(tmp);
        }
        this.renderInsertedValues(tmp);
        tmp.length = 0;
      }
      values.length = 0;
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.storeInside === true) {
          this.values = this.values.filter( (v) => {
            return splices.indexOf(v) === -1;
          })
          this.notifyPath('values');
          // this.splice('values', 0, splices.length);
        }
        if (this.renderSplicedValues) {
          this.renderSplicedValues(splices);
        }
      }
    },

    resetValues: function(values) {
      this.values = values;
      this.notifyPath('values');
      this.renderInsertedValues(this.values);
    },

    clearValues: function() {
      if (this._initialized) {
        this.resetState();
        this.values = [];
        this.notifyPath('values');
        this.renderClearing();
      }
    },

    requestLastValue: function(len) {

      this._messageCount++;
      len = len || this.viewLength || 1;
      var messageId = 'requestLastValue' + this.uniqueid + this._messageCount;
      var req = {
        request: {
          messageId: messageId,
          requestLast: {
            mounts: [this.item.mount],
            length: len || 1
          }
        }
      };

      var uniqueid = this.uniqueid;
      if (window.Webvisual) {
        return new Promise(function(resolve, reject) {

          if (!this.webworker) {
            reject('No webworker in webvisual-client active');
          }

          this.webworker.addEventListener('message', function onMessage(e) {
            if (e.data
             && e.data.messageId
             && e.data.messageId === messageId) {
               this.webworker.removeEventListener('message', onMessage, false );
               resolve(e.data.values);
             }
          }.bind(this), false );

          this.webworker.postMessage( req );
        }.bind(window.Webvisual))
      } else {
        return new Promise( (resolve, reject) => {
          if (this.values)
           resolve(this.values.slice(this.values.length - len, this.values.length))
          else {
            reject();
          }
        });
      }
    },

    requestRange: function(key) {
      var mount = this.mount;
      var uniqueid = this.uniqueid;
      _messageCount = this._messageCount++;
      if (!this.storeInside && window.Webvisual && window.Webvisual.webworker) {
        return new Promise( function (resolve, reject) {

          var messageId = 'requestRange' + uniqueId + _messageCount;
          this.webworker.addEventListener('message', function onMessage(e) {
            if (e.data
             && e.data.messageId
             && e.data.messageId === messageId) {
               this.webworker.removeEventListener('message', onMessage);
               resolve(e.data.values);
             }
          }.bind(this));

          this.webworker.postMessage(
            {
              request: {
                messageId: messageId,
                rangedValues: {
                  mounts: [mount],
                  key: key
                }
              }
            });
        }.bind(window.Webvisual))
      } else {
        return new Promise( (resolve, reject) => {
          if (this.values && this.values.length) {
            var min = this.min(this.values, key);
            var max = this.max(this.values, key);
            resolve( [ min, max ] );
          }
          else {
            reject('no values set');
          }
        });
      }
    },

	  min: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a > b) a = b;

	    return a;
	  },

    max: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a < b) { a = b; }

	    return a;
	  },

    renderInsertedValues: function(values) {
    },

    renderSplicedValues: function(values) {
    },

    renderClearing: function(values) {
    },

    checkExceedingState: function(value) {
      if (!this.item || this.item.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    _exceedingChanged: function(isExceeding, old) {
      if (this.item && this.item.exceedable === true) {
        if (this.bubbles === true) {
          this.dispatchEvent(new CustomEvent('exceeding', {detail: { item: this.item, value: isExceeding }}), {bubbles: true });
        }
      }
    },

    _hasExceededChanged: function() {},

    resetState: function() {
      this.isExceeding = false;
      this.hasExceeded = false;
    }
  };
</script>
