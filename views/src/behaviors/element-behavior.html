<script>
  window.WebvisualBehaviors = window.WebvisualBehaviors || {};

  /**
   * Behavior that adds functionality to assign to socket and adds exceed events
   *
   * @polymerBehavior
   */

  WebvisualBehaviors.ElementBehavior = {

    properties: {

      item: Object,

      values: {
        type: Array,
        value: function() {
          return [];
        }
      },

      isExceeding: {
        type: Boolean,
        value: false
      },

      hasExceeded: {
        type: Boolean,
        value: false
      },

      storeInside: Boolean,

      viewLength: {
        type: Number,
        value: 1
      },

      uniqueid: {
        type: String,
        reflectToAttribute: true
      },

      noLink: {
        type: Boolean,
        value: false
      }

    },

    // communication count to webworker
    _messageCount: 0,

    observers: [
      '_exceedingChanged(isExceeding)',
      '_hasExceededChanged(hasExceeded)',
      '_linkElement(item.mount, uniqueid, noLink)'
    ],

    hostAttributes: {
      element: true
    },

    ready: function() {
      var sel, uniqueid;
      while (true) { // TODO: not valid in ShadowDOM
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.set('uniqueid', uniqueid);
    },

    factoryImpl: function(obj, properties) {
      this._linkElement(obj, properties);
    },

    detached: function() {
      this._unlinkElement();
      this.clearValues();
    },

    _linkElement: function(mount, uniqueid, noLink) {
      if (this._olditem) {
        this._unlinkElement(this._olditem);
      }
      if (!(mount && uniqueid && !noLink)) {
        return;
      }
      this._olditem = this.item;
      if (this._initialized) {
        this.clearValues();
      }
      if (window.Webvisual && window.Webvisual.assignElement && this.item && this.item.mount) {
        window.Webvisual.assignElement(this);
      }

      this.requestLastValue(this.viewLength, 0)
          .then( function(values) {
            this.insertValues(values);
          }.bind(this))
          .catch( function(err) {
            if (err) {
              console.log(err);
            }
          } );
    },

    _unlinkElement: function(item) {
      if (window.Webvisual && Webvisual.retractElement && item && item.mount) {
        window.Webvisual.retractElement(this, item);
        this._olditem = null;
      }
    },

    getElement: function() {
      return this.properties;
    },

    computeDate: function(x) {
      return x ? (this.fullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString()) : '';
    },

    computeValue: function(y, state) {
      return (this.item && this.item.isIndicatorLamp) ? ( state ? '✗' : '✓' ) : y;
    },

    insertValues: function(values, len) {
      if (values === undefined) {
        return;
      }

      var len = len || this.viewLength;

      if (!this._initialized)
        this._initialized = true;

      if (!len) {
        if (this.item && this.item.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(values);
        }
        // console.log(this.values);
        this.renderInsertedValues(values);
      } else {
        var tmp = values.slice(values.length - len, values.length);
        if (this.item && this.item.exceedable === true) {
          tmp.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        if (this.storeInside) {
          this.values = this.values.concat(tmp);
        }
        this.renderInsertedValues(tmp);
        tmp.length = 0;
      }
      values.length = 0;
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.storeInside === true) {
          this.values = this.values.filter( function(v) {
            return splices.indexOf(v) === -1;
          })
          this.notifyPath('values');
          // this.splice('values', 0, splices.length);
        }
        if (this.renderSplicedValues) {
          this.renderSplicedValues(splices);
        }
      }
    },

    resetValues: function(values) {
      this.values = values;
      this.notifyPath('values');
      this.renderInsertedValues(this.values);
    },

    clearValues: function(force) {
      if (this._initialized || force) {
        if (this.selected) {
          this.selected = false;
        }
        this.values = [];
        this.notifyPath('values');
        this.resetState();
      }
    },

    requestLastValue: function(len, attempts) {

      this._messageCount++;
      var self = this;
      len = len || this.viewLength || 1;
      var messageId = 'requestLastValue' + this.uniqueid + '#' + this._messageCount;
      var req = {
        request: {
          messageId: messageId,
          func: 'requestLast',
          arg: {
            mounts: [this.item.mount],
            length: len || 1
          }
        }
      };

      var uniqueid = this.uniqueid;
      if (window.Webvisual) {
        return new Promise(function(resolve, reject) {

          if (!this.webworker) {
            reject('No webworker in webvisual-client active');
          }

          this.webworker.addEventListener('message', function onMessage(e) {
            if (e.data
             && e.data.messageId
             && e.data.messageId === messageId) {
               this.webworker.removeEventListener('message', onMessage, false );
               if (self.item && e.data.response && e.data.response[self.item.mount]) {
                 resolve(e.data.response[self.item.mount]);
               } else if (attempts) {
                //  console.log(self.item.mount + ': ' + attempts + '  ' + JSON.stringify(e.data.response));
                 resolve(self.requestLastValue(len, --attempts));
               } else {
                 reject(self.nodeName + ': no values received')
               }
             }
          }.bind(this), false );

          this.webworker.postMessage( req );
        }.bind(window.Webvisual))
      } else {
        return new Promise( function(resolve, reject) {
          if (this.values)
            resolve(this.values.slice(this.values.length - len, this.values.length))
          else {
            reject();
          }
        }.bind(this));
      }
    },

    requestRange: function(key, attempts) {
      var mount = this.mount;
      var uniqueid = this.uniqueid;
      messageCount = this._messageCount++;
      if (!this.storeInside && window.Webvisual && window.Webvisual.webworker) {
        return new Promise( function (resolve, reject) {

          var messageId = 'requestRange' + uniqueId + '#' + messageCount;
          this.webworker.addEventListener('message', function onMessage(e) {
            if (e.data
             && e.data.messageId
             && e.data.messageId === messageId) {
               this.webworker.removeEventListener('message', onMessage);
               if (e.data.response && e.data.response.length === 2) {
                 resolve(e.data.response);
               } else if (attempts) {
                 resolve(this.requestRange(key, attempts--));
               } else {
                 reject(self.item + ': no range received')
               }
             }
          }.bind(this));

          this.webworker.postMessage(
            {
              request: {
                messageId: messageId,
                func: 'rangedValues',
                arg: {
                  mounts: [mount],
                  key: key
                }
              }
            });
        }.bind(window.Webvisual))
      } else {
        return new Promise( function(resolve, reject) {
          if (this.values && this.values.length) {
            var min = this.min(this.values, key);
            var max = this.max(this.values, key);
            resolve( [ min, max ] );
          }
          else {
            // reject('no values are set');
            resolve( [ ] );
          }
        }.bind(this));
      }
    },

	  min: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a > b) a = b;

	    return a;
	  },

    max: function(array, key) { // inspired by d3.array
			var i = -1,
		      a,
		      b;
			var n = array.length;

			while (++i < n) if ((b = array[i][key]) !== null && b >= b) { a = b; break; }
			while (++i < n) if ((b = array[i][key]) !== null && a < b) { a = b; }

	    return a;
	  },

    renderInsertedValues: function(values) {
    },

    renderSplicedValues: function(values) {
    },

    renderClearing: function(values) {
    },

    checkExceedingState: function(value) {
      if (!this.item || this.item.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    _exceedingChanged: function(isExceeding, old) {
      if (this.item && this.item.exceedable === true) {
        this.fire('exceeding', { item: this.item, value: isExceeding });
      }
    },

    _hasExceededChanged: function() {},

    resetState: function() {
      this.isExceeding = false;
      this.hasExceeded = false;
      if (this.checked) {
        this.checked = false;
      }
      if (this.resetColor)
        this.resetColor();
      this.renderClearing();
    }
  };
</script>
