<link rel="import" href="../bower_components/polymer/polymer-element.html">

<link rel="import" href="mixins/localize-mixin.html">

<link rel="import" href="../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">

<link rel="import" href="components/icon-button.html">
<link rel="import" href="components/dialog-element.html">
<link rel="import" href="components/drawer-element.html">
<link rel="import" href="style/input-style.html">
<link rel="import" href="style/button-style.html">
<link rel="import" href="style/selectbox-style.html">

<dom-module id="dialog-chart-export">
  <template strip-whitespace>
    <style include="input-style button-style selectbox-style">
      :host {
        outline: none;
      }
      #dialog {
        border-radius: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
      #chartContainer {
        display: block;
        position: relative;
        box-sizing: border-box;
        margin: 0;
        padding: 8px;
        flex: 1 1 auto;
        overflow: auto;
      }
      #chartContainer > * {
        color: inherit;
      }
      #chartContainer > device-chart {
        margin: 0;
        padding: 0;
        --focus-color: blue;
      }
      #options {
        position: absolute;
        --drawer-width: 12em;
        --drawer-background: rgba(255,255,255,0.75);
        --drawer-scrim-background: rgba(0,0,0,0.25);
        --drawer-content: {
          padding: 0;
        };
      }
      .drawer-content {
        display: block;
        height: 100%;
        padding: 0 1em;
        overflow-x: hidden;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <dialog-element id="dialog" on-iron-overlay-opened="_setDimensions">
      <div dialog-title>
        <div>{{localize('export', 'title')}}</div>
      </div>
      <div dialog-content horizontal>
        <div id="chartContainer"></div>
        <drawer-element id="options" opened$="[[optionsOpened]]" scrim stretch align="right">
        <div class="drawer-content">
            <div class="selectbox">
              <iron-icon icon="language"></iron-icon>
              <span>{{localize('chart', 'format')}}</span>
              <select value="{{format::change}}">
                <option value="svg">.svg</option>
                <option value="png">.png</option>
                <option value="jpg">.jpg</option>
              </select>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="range" min="0" max="1" step="0.01" value="{{quality::input}}">
              <div class="decorator" error-message$=">= 0">
                <label>{{localize('chart', 'quality')}}</label>
              </div>
            </div>
            <div class="input">
              <iron-icon icon="language"></iron-icon>
              <span>{{localize('chart', 'resolution')}}</span>
              <input type="number" min="96" step="1" value="{{resolution::input}}">
              <div class="decorator" error-message$=">= 0">
                <label>{{localize('chart', 'resolution')}}</label>
                <div class="underline"></div>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="number" min="0" step="10" value="{{height::input}}">
              <div class="decorator" error-message$=">= 0">
                <label>{{localize('chart', 'height')}}</label>
                <div class="underline"></div>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="number" min="0" step="10" value="{{width::input}}">
              <div class="decorator" error-message$=">= 0">
                <label>{{localize('chart', 'width')}}</label>
                <div class="underline"></div>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="number" min="1" step="1" value="{{textSize::input}}">
              <div class="decorator" error-message$=">= 0">
                <label>{{localize('chart', 'text-size')}}</label>
                <div class="underline"></div>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="color" value="{{textColor::input}}">
              <div class="decorator">
                <label>{{localize('chart', 'text-color')}}</label>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="color" value="{{backgroundColor::input}}">
              <div class="decorator">
                <label>{{localize('chart', 'background-color')}}</label>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="color" value="{{lineColor::input}}">
              <div class="decorator">
                <label>{{localize('chart', 'line-color')}}</label>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="radio" value="{{showLegend::input}}">
              <div class="decorator">
                <label>{{localize('chart', 'show-legend')}}</label>
              </div>
            </div>
            <div class="input">
              <iron-icon class="left" icon="tune"></iron-icon>
              <input type="radio" value="{{showFocus::input}}">
              <div class="decorator">
                <label>{{localize('chart', 'show-focus')}}</label>
              </div>
            </div>
        </div>

        </drawer-element>
      </div>
      <div dialog-bottom class="buttons">
        <div class="button" on-tap="toggleControl">
          <paper-ripple></paper-ripple>
          <iron-icon class="left" icon="tune"></iron-icon>
          {{localize('export', 'options')}}
        </div>
        <div class="button" on-tap="toggleStyleOptions">
          <paper-ripple></paper-ripple>
          <iron-icon class="left" icon="style"></iron-icon>
          {{localize('export', 'style')}}
        </div>
        <div class="button" on-tap="fitInContainer">
          <paper-ripple></paper-ripple>
          <iron-icon class="left" icon="aspect-ratio"></iron-icon>
          fit
        </div>
        <div class="button" on-tap="save">
          <paper-ripple></paper-ripple>
          <iron-icon class="left" icon="camera-alt"></iron-icon>
          {{localize('export', 'save')}}
        </div>
      </div>
    </dialog-element>
  </template>

  <script>
    class DialogChartExport extends WebvisualMixins.LocalizeMixin(Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], Polymer.Element)) {

      static get is() {
        return 'dialog-chart-export'
      }

      static get properties() {
        return {
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            observer: '_openedChanged'
          },

          optionsOpened: {
            type: Boolean,
            value: false
          },

          format: {
            type: String,
            value: 'png'
          },

          resolution: {
            type: String,
            value: 'high'
          },

          quality: {
            type: Number,
            value: 0.5
          },

          height: {
            type: Number
          },

          width: {
            type: Number
          },

          showPoint: {
            type: Boolean,
            value: true
          },

          backgroundColor: {
            type: String,
            value: '#ffffff'
          },

          textColor: {
            type: String,
            value: '#151515'
          },

          lineColor: {
            type: String,
            value: '#151515'
          },

          languageResourcePrefix: {
            type: String,
            value: '/locales/ui/'
          }
        }
      }

      static get observers() {
        return [
          '_setDimensions(height, width)',
          '_styleChanged(showPoint, backgroundColor, textColor, lineColor)'
        ]
      }

      static get listeners() {
        return {
          'iron-resize': '_setDimensions'
        };
      }

      constructor() {
        super();
        this.setChartElement(...arguments);
      }

      connectedCallback() {
        super.connectedCallback();
        this._isAttached = true;
        this._attachChartElement();
        this._getPPI();
      }

      setChartElement(chartElement) {
        if (chartElement) {
          if (this._chart) {
            this._detachChartElement();
          }
          this._chart = chartElement.cloneNode(true);
          this._chart.controlButtonsHidden = true;
          this._chart.exportButtonDisabled = true;
          this._chart.setAttribute('without-mixmode', true);
          this._chart.set('items', chartElement.items);
          if (this._isAttached === true) {
            this._attachChartElement();
          }
        }
      }

      _attachChartElement() {
        if (!this._chart) {
          return;
        }
        Array.prototype.forEach.call(this.$.chartContainer.children, el => {
          this.$.chartContainer.removeChild(el);
        });
        requestAnimationFrame(() => {
          this.$.chartContainer.appendChild(this._chart);
          this._chart._assignNodes();
          const clip = this._chart._svg.node().querySelector('clipPath');
          clip.setAttribute('id', 'clip-export'); // firefox brushing
          Array.prototype.forEach.call(this._chart._svg.node().querySelectorAll('[clip-path]'), el => {
            el.setAttribute('clip-path', 'url(#clip-export)');
          })
          setTimeout(() => {
            this._chart.sizeLayout();
            this._chart.updateStyles({ '--focus-color': 'red' });
          }, 100);
        });
      }

      _detachChartElement() {
        if (this._isAttached === true) {
          if (this._chart && this._chart.parentElement)
            this._chart.parentElement.removeChild(this._chart);
        }
      }

      _styleChanged() {
        if (!this._chart || this._isAttached !== true) {
          return;
        }
        const svg = this._chart._svg.node();
      }

      _setDimensions(height, width) {
        if (!this._chart || this._isAttached !== true) {
          return;
        }
        if (typeof height !== 'number' || typeof width !== 'number') {
          const bbox = this._chart.getBoundingClientRect();
          height = bbox.height;
          width = bbox.width;
        }
        if (height <= 0 || width <= 0) {
          return;
        }

        this._chart.style.height = height + 'px';
        this._chart.style.width = width + 'px';
        this._chart.sizeLayout();
      }

      fitInContainer() {
        if (!this._chart || this._isAttached !== true) {
          return;
        }
        const bbox = this.$.chartContainer.getBoundingClientRect(),
          pt = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('padding-top')),
          pr = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('padding-right')),
          pb = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('padding-bottom')),
          pl = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('padding-left')),
          mt = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('margin-top')),
          mr = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('margin-right')),
          mb = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('margin-bottom')),
          ml = parseFloat(window.getComputedStyle(this.$.chartContainer).getPropertyValue('margin-left')),
          height = Math.floor(bbox.height - mt - mb - pt - pb),
          width = Math.floor(bbox.width - mr - ml - pr - pl);

        if (height <= 0 || width <= 0) {
          return;
        }
        this._chart.style.height = height + 'px';
        this._chart.style.width = width + 'px';
        this._chart.sizeLayout();
      }

      _getPPI() {
        let testDiv = document.createElement('div');
        testDiv.style.cssText = 'height: 1in; left: -100%; position: absolute; top: -100%; width: 1in;';
        document.body.insertBefore(testDiv, document.body.children[0]);
        this._ppiX = testDiv.offsetWidth;
        this._ppiY = testDiv.offsetHeight;
        testDiv.parentElement.removeChild(testDiv);
      }

      toggleControl() {
        this._chart.toggleControl();
      }

      toggleStyleOptions() {
        this.optionsOpened = !this.optionsOpened;
      }

      _openedChanged(opened) {
        if (opened === true) {
          this.open();
        } else {
          this.close();
        }
      }

      _equals(a, b) {
        return a === b;
      }

      open() {
        this.$.dialog.open();
        this.opened = true;
      }

      close() {
        this.$.dialog.close();
        this.opened = false;
      }

      save() {
        // TODO: add a dialog with options: height, width, format, legend, legend-keys, areas
        // https://stackoverflow.com/questions/28226677/save-inline-svg-as-jpeg-png-svg
        // https://stackoverflow.com/questions/15181452/how-to-save-export-inline-svg-styled-with-css-from-browser-to-image-file

        this._styleChanged();
        this._setDimensions(this.height, this.width);
        const ContainerElements = ['svg', 'g'];
        const RelevantStyles = {
          'rect': ['fill', 'stroke', 'stroke-width'],
          'path': ['fill', 'stroke', 'stroke-width'],
          'circle': ['fill', 'stroke', 'fill-opacity', 'stroke-width'],
          'line': ['stroke', 'stroke-width'],
          'text': ['fill', 'font-size', 'font-family', 'letter-spacing', 'text-anchor', 'alignment-baseline']
        };
        requestAnimationFrame(() => {
          // setTimeout(() => {
            const svg = this._chart._svg.node().cloneNode(true);
            // window.getComputedStyle(this._chart._svg.node()).getPropertyValue('height')
            applyStyleToElement(svg, this._chart._svg.node());
            Array.prototype.forEach.call(svg.querySelectorAll('[hidden],.brush,#zoom,#focus,.info'), el => {
              if (el && el.parentElement)
                el.parentElement.removeChild(el);
            })
            svg.setAttribute('filter', 'url(#solid)');
            svg.style.margin = '0px';
            svg.style.padding = '0px';

            svg.querySelector('filter#solid feFlood').setAttribute('flood-color', this.backgroundColor);

            Array.prototype.forEach.call(svg.querySelectorAll('.axis.main text'), el => {
              el.setAttribute('fill', this.textColor);
            });
            Array.prototype.forEach.call(svg.querySelectorAll('.domain'), el => {
              el.setAttribute('fill-opacity', '0');
            });
            Array.prototype.forEach.call(svg.querySelectorAll('.grid line'), el => {
              el.setAttribute('stroke-width', 0.5);
              el.setAttribute('stroke-opacity', 0.2);
              el.setAttribute('stroke', this.lineColor);
            });
            Array.prototype.forEach.call(svg.querySelectorAll('.axis.main line,.axis.main path'), el => {
              el.setAttribute('stroke', this.lineColor);
            });
            Array.prototype.forEach.call(svg.querySelectorAll('*'), el => {
              el.removeAttribute('class');
            });

            function applyStyleToElement(parent, orig) {
              const children = parent.childNodes;
              const origChildren = orig.childNodes;

              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                const tag = child.tagName;
                if (ContainerElements.indexOf(tag) !== -1) {
                  applyStyleToElement(child, origChildren[i])
                } else if (tag in RelevantStyles) {
                  const StyleDef = window.getComputedStyle(origChildren[i]);
                  for (let j = 0; j < RelevantStyles[tag].length; j++) {
                    child.setAttribute([RelevantStyles[tag][j]], StyleDef.getPropertyValue(RelevantStyles[tag][j]));
                  }
                }
              }
            }

            const data = (new XMLSerializer()).serializeToString(svg);
            const uri = (decodeURIComponent(location.href)).replace(/ids|room|:\/\/|https|http/gi, '').replace(/[$-/:-?{-~!"^=&_`]/gi, '+').replace(/\+\+/gi, '+');
            let a = document.createElement('a');
            a.setAttribute('download', uri + '.' + this.format);
            const event = new MouseEvent('click', { view: window, bubbles: true, cancelable: true });

            if (this.format === 'svg') {
              const blob = new Blob([data], {type:'image/svg+xml;charset=utf-8}'});
              a.setAttribute('href', URL.createObjectURL(blob));
              const cancelled = !a.dispatchEvent(event);
              if (!cancelled) {
                this.close();
              }
            } else { // save as compressed image file
              const image = new Image();
              let ppi;
              switch (this.resolution) {
                case 'high':
                  ppi = 300;
                  break;
                case 'medium':
                  ppi = 300;
                  break;
                default:
                  ppi = 150;
              }
              image.src = 'data:image/svg+xml;base64,' + window.btoa(unescape(encodeURIComponent(data)));
              image.onload = () => {
                const canvas = document.createElement('canvas'),
                  bbox = this._chart._svg.node().getBoundingClientRect(),
                  height = bbox.height,
                  width = bbox.width;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                let scaleFactorX = ppi / this._ppiX;
                let scaleFactorY = ppi / this._ppiY;
                canvas.setAttribute('width', scaleFactorX * width);
                canvas.setAttribute('height', scaleFactorY * height);
                const context = canvas.getContext('2d');
                context.scale(canvas.width/width, canvas.height/height);
                context.drawImage(image, 0, 0);
                a.setAttribute('href', canvas.toDataURL('image/' + this.format, this.quality));
                const cancelled = !a.dispatchEvent(event);
                if (!cancelled) {
                  this.close();
                }
              }
            }
          // }, 100);
        });
      }
    }
    customElements.define(DialogChartExport.is, DialogChartExport);
  </script>

</dom-module>
