<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="behaviors/fullscreen-behavior.html"/>

<link rel="import" href="components/webvisual-icon-button.html"/>

<link rel="import" href="webvisual-element-graph.html"/>

<script type="text/javascript" src="../bower_components/d3/d3.min.js"></script>

<dom-module id="webvisual-element-chart">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
        font-family: inherit;
        color: currentColor;
        letter-spacing: normal !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
        -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
        -webkit-touch-callout: none !important;
          -webkit-user-select: none !important;
           -khtml-user-select: none !important;
             -moz-user-select: none !important;
              -ms-user-select: none !important;
                  user-select: none !important;
      }
      :host[fullscreen],
      :host([fullscreen]) {
        background-color: var(--fullscreen-background-color);
        padding: 3em !important;
      }
      :host(:-webkit-full-screen) {
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        border-radius: inherit;
        display: block;
        width: 100%;
        height: 100%;
      }
      #svgchart {
        overflow: visible;
        position: relative;
        width: 100%;
        height: 100%;
        display: block;
        mix-blend-mode: exclusion;
        font-family: inherit;
      }
      text {
        fill: currentColor;
        pointer-events: none;
        letter-spacing: normal !important;
        font-family: inherit !important;
      }
      g#chart .axis {
        font-size: inherit;
      }
      g#chart text {
        font-size: 0.55em;
      }
      rect#plot {
        fill: var(--chart-plot-background, #fff);
        stroke: currentColor;
        fill-opacity: 0.25;
        stroke-opacity: 0.25;
        shape-rendering: crispEdges;
        stroke-width: 1px;
      }
      :host[fullscreen] #plot,
      :host([fullscreen]) #plot {
        fill: var(--chart-plot-background, #ccc);
      }
      #brush .overlay {
        cursor: default;
      }
      #brush .selection {
        stroke: white;
        fill: white;
        stroke-opacity: 0.25;
        fill-opacity: 0.1;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.1;
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis path, .axis line {
        fill: none;
        stroke: currentColor;
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
        mix-blend-mode: exclusion;
      }
      .axis {
        font-family: inherit;
      }
      /*g#chart g.axis path, g#chart g.axis line {
        stroke-opacity: 0.5;
      }*/
      #graphs {
        isolation: isolate;
      }
      #graphs .area, #graphs .line {
        pointer-events: none;
        mix-blend-mode: exclusion;
      }
      #graphs .area {
        fill-opacity: 0.3;
        @apply(--chart-area);
      }
      #graphs .line {
        stroke-width: 1.5px;
        @apply(--chart-line);
      }
      #graphs .dot {
        cursor: pointer;
        pointer-events: all;
        transform-origin: center;
        stroke: #252525;
        stroke-width: 0.5px;
        stroke-opacity: 1;
        @apply(--chart-dot);
      }
      #zoom .overlay {
        fill: none;
        fill-opacity: 0.1;
        pointer-events: none;
        stroke-width: 0;
      }
      #zoom .overlay.active {
        pointer-events: all;
        fill: #8B5F45;
        cursor: zoom-in;
        stroke: #1f1f1f;
        stroke-opacity: 0.3;
        stroke-width: 1px;
      }
      #focus .focus.line {
        fill: none;
        pointer-events: none;
        stroke: white;
        stroke-opacity: 0.2;
        stroke-width: 1px;
        stroke-dasharray: 2;
        mix-blend-mode: exclusion;
      }
      .axis, .grid, #plot {
        pointer-events: none;
      }
      webvisual-icon-button {
        border-radius: 0%;
        mix-blend-mode: exclusion;
        opacity: 0.5;
        will-change: opacity;
        transition: opacity 150ms ease;
      }
      webvisual-icon-button:hover {
        opacity: 1;
      }
      #control {
        display: inline-block;
        position: absolute;
        bottom: 0;
        right: 4px;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer">
      <svg id="svgchart" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <g id="xAxis" class="axis"></g>
          <g id="yAxis" class="axis"></g>
          <g id="xGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="brush" clip-path="url(#clip)"></g>
          <g id="focus" clip-path="url(#clip)" hidden>
            <line id="focusX" class="focus line x" x1="0"></line>
            <line id="focusY" class="focus line y"></line>
          </g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="areas"></g>
            <g id="lines"></g>
            <g id="dots"></g>
          </g>
          <text id="info" x="0" y="0" hidden></text>
          <g id="zoom" clip-path="url(#clip)">
            <rect class="overlay" x="0.5" y="0.5"></rect>
          </g>
        </g>
      </svg>
  	</div>

      <!-- <webvisual-icon-button id="zoombutton" icon="search" on-tap="_startZoomSession"></webvisual-icon-button> -->
    <section id="control">
		  <webvisual-icon-button title="legend" icon="timeline" on-tap="openLegend"></webvisual-icon-button>
      <webvisual-icon-button title="fullscreen" icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></webvisual-icon-button>
    </section>
		  <!--<webvisual-icon-button id="optionsbutton" icon="juelich:app-inverted"></webvisual-icon-button>
		  <webvisual-dropdown for="optionsbutton" target-toggle-event="tap" position="right" align="outer-start" offset="10">
		    <webvisual-radio-button checked="[[!noDots]]" on-change="changeDots">mit Punkten</webvisual-radio-button>
		    <webvisual-radio-button checked="[[!noLines]]" on-change="changeLines">mit Linien</webvisual-radio-button>
		    <webvisual-radio-button checked="[[!noAreas]]" on-change="changeAreas">mit Flächen</webvisual-radio-button>
		  </webvisual-dropdown>

		  <webvisual-icon-button id="ybutton" icon="y"></webvisual-icon-button>
		  <webvisual-dropdown for="ybutton" target-toggle-event="tap" position="right" align="start" offset="10">
		    <iron-selector attr-for-selected="scale" selected="{{yScale}}" fallback-selection="linear" toggles>
		      <webvisual-button scale="linear">linear</webvisual-button>
		      <webvisual-button scale="√">√</webvisual-button>
		      <webvisual-button scale="ln">ln</webvisual-button>
		      <webvisual-button scale="log₁₀">log₁₀</webvisual-button>
		    </iron-selector>
		  </webvisual-dropdown>

		  <webvisual-icon-button id="xbutton" icon="x"></webvisual-icon-button>
		  <webvisual-dropdown for="xbutton" target-toggle-event="tap" position="top" align="end" offset="1">
		    <iron-selector attr-for-selected="interpolate" selected="{{interpolation}}" fallback-selection="Lineare Verbindung" toggles>
		      <webvisual-button interpolate="Lineare Verbindung">Lineare Verbindung</webvisual-button>
		      <webvisual-button interpolate="Basis Spline">Basis Spline</webvisual-button>
		      <webvisual-button interpolate="Monotoner Spline">Monotoner Spline</webvisual-button>
		      <webvisual-button interpolate="Kubischer Spline">Kubischer Spline</webvisual-button>
		      <webvisual-button interpolate="Cardinaler Spline">Cardinaler Spline</webvisual-button>
		      <webvisual-button interpolate="Catmull-Rom-Spline">Catmull-Rom-Spline</webvisual-button>
		      <webvisual-button interpolate="Stufe (mitte)">Stufe (mitte)</webvisual-button>
		      <webvisual-button interpolate="Stufe (davor)">Stufe (davor)</webvisual-button>
		      <webvisual-button interpolate="Stufe (danach)">Stufe (danach)</webvisual-button>
		    </iron-selector>
		  </webvisual-dropdown> -->

    <template is="dom-repeat" items="[[items]]">
      <webvisual-element-graph
        item="[[item]]"
        interpolation="[[interpolation]]"
        store-inside>
      </webvisual-element-graph>
    </template>

  </template>

  <script>
    d3.timeFormatDefaultLocale({
      'dateTime': '%x %X',
      'date': '%d.%m.%Y',
      'time': '%H:%M:%S',
      'periods': ['', ''],
      'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
      'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
      'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
    });
    d3.formatDefaultLocale({
      'decimal': ',',
      'thousands': '.',
      'grouping': [3],
      'currency': ['', '\u00a0€']
    });

    Polymer({
      is: 'webvisual-element-chart',

      behaviors: [
        Polymer.IronResizableBehavior,
        WebvisualBehaviors.FullscreenBehavior
      ],

      properties: {

        opened: {
          type: Boolean,
          reflectToAttribute: true
        },

        gridMult: {
          type: Number,
          value: 2
        },

        xScale: {
          type: String,
          value: 'time',
          observer: 'changeScale'
        },

        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },

        interpolation: {
          type: String,
          value: 'Lineare Verbindung',
          observer: 'changeInterpolation'
        },

        noDots: {
          type: Boolean,
          value: false
        },

        noLines: {
          type: Boolean,
          value: false
        },

        noAreas: {
          type: Boolean,
          value: false
        },

        items: {
          type: Array,
          value: function() {
            return [];
          }
        },

        uniqueid: String

      },

      _width: 0,
      _height: 0,
      _margin: {
        top: 0,
        right: 15,
        bottom: 10,
        left: 40
      },

      _xGrid: Object,
      _yGrid: Object,
      _brush: Object,
      _chart: Object,
      _svg: Object,
      _info: Object,
      _focusX: Object,
      _focusY: Object,
      _zoomOverlay: Object,
      _lines: Object,
      _areas: Object,
      _dots: Object,

      _x: Function,
      _y: Function,

      _xAxis: Object,
      _yAxis: Object,

      _xGrid: Object,
      _yGrid: Object,

      _isBrushed: false,
      _isZoomed: false,

      format: {
        Millisecond: Function,
        Second: Function,
        LongSecond: Function,
        Minute: Function,
        LongMinute: Function,
        Hour: Function,
        Day: Function,
        Week: Function,
        Month: Function,
        Year: Function
      },

      _graphs: new Set(),

      _brushBehavior: Function,

      _messageCount: 0,

      get _self() {
        return this;
      },

      listeners: {
        'iron-resize': '_sizeChanged',
        'contextmenu': '_resetZoom'
      },

      observers: [
        'redraw(items.length)'
      ],

      created: function() {
        this.format.Millisecond = d3.timeFormat(':%S,%L');
        this.format.LongSecond = d3.timeFormat(':%M:%S,%L');
        this.format.Second = d3.timeFormat(':%M:%S');
        this.format.LongMinute = d3.timeFormat('%H:%M:%S');
        this.format.Minute = d3.timeFormat('%H:%M');
        this.format.Hour = d3.timeFormat('%X');
        this.format.Day = d3.timeFormat('%d.%m');
        this.format.Week = d3.timeFormat('%d.%m');
        this.format.Month = d3.timeFormat('%d. %b');
        this.format.Year = d3.timeFormat('%Y');
      },

      ready: function() {
        var sel, uniqueid;
        while (true) {
          uniqueid = String(Math.random().toString(16).slice(2));
          sel = document.querySelector("[uniqueid='" + uniqueid + "']");
          if (!sel) break;
        }
        this.setAttribute('uniqueid', uniqueid);
        this._buildLayout();
      },

      _sizeChanged: function(e) {
        // only resize if opened attribute is set
        if (this.opened) {
          this.debounce('resize', this._sizeLayout, 25);
        }
      },

      _buildLayout: function() {
        // performance.mark('build start');
        // this.assignParentResizable(this.rootElement);

        this._svg = d3.select(this.$.svgchart)
          .attr('height', null)
          .attr('width', null);
        this._x = this._createScale(this.xScale);
        this._y = this._createScale(this.yScale);

        this._chart = d3.select(this.$.chart);

        this._lines = d3.select(this.$.lines);
        this._areas = d3.select(this.$.areas);
        this._dots = d3.select(this.$.dots);

        this._brushBehavior = d3.brush()
          .on('end', this.brushed.bind(this._self));
        this._brush = d3.select(this.$.brush);

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = this._focus.select('#focusX');
        this._focusY = this._focus.select('#focusY');
        this._zoomOverlay = d3.select(this.$.zoom).select('rect.overlay')
          .on('click', (d) => {
            var offset = Math.floor(Math.min(this._height, this._width) / 5);
            var x = d3.event.offsetX - this._margin.left;
            var y = d3.event.offsetY - this._margin.top;
            d3.event.selection = [
              [x - offset, y - offset],
              [x + offset, y + offset]
            ];
            this.brushed();
          })
          .on('touchmove', this._resetZoom.bind(this));

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('webvisual-element-chart', true);
        // performance.mark('build end');
        // performance.measure('build', 'build start', 'build end');
        this._sizeChanged();
      },

      _sizeLayout: function() {
        // performance.mark('size start');
        var bRect = this.$.svgchart.getBoundingClientRect();

        if (bRect.height === 0 || bRect.width === 0) return;

        this._height = bRect.height;
        this._width = bRect.width;

        // this._svg.attr('height', this._height)
        //          .attr('width', this._width);

        this._width = this._width - this._margin.left - this._margin.right;
        this._height = this._height - this._margin.bottom - this._margin.top;

        this.xTicks = Math.ceil(this._width / 150);
        this.yTicks = Math.ceil(this._height / 50);

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this._chart.attr('transform', 'translate(' + this._margin.left + ',' + (this._margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.select('clipPath#clip rect')
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.select('rect#plot')
          .attr('width', this._width)
          .attr('height', this._height);

        this._zoomOverlay
          .attr('width', this._width - 1)
          .attr('height', this._height - 1);

        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);

        this._xGrid = this._createAxis(this._x, 'bottom', this.xScale, this.gridMult)
          .tickSize(-this._height, 0, 0)
          .tickFormat('');
        this._yGrid = this._createAxis(this._y, 'left', this.yScale, this.gridMult)
          .tickSize(-this._width, 0, 0)
          .tickFormat('');

        this._chart.select('#xAxis')
          .call(this._xAxis)
          .attr('transform', 'translate(0,' + this._height + ')');
        this._chart.select('#yAxis')
          .call(this._yAxis)
          .attr('transform', 'translate(0,' + 0 + ')');
        this._chart.select('#xGrid')
          .attr('transform', 'translate(0,' + this._height + ')')
          .call(this._xGrid);
        this._chart.select('#yGrid')
          .call(this._yGrid)
          .attr('transform', 'translate(0,' + 0 + ')');;

        this._brushBehavior.extent([
          [0, 0],
          [this._width, this._height]
        ])
        this._brush.call(this._brushBehavior);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('webvisual-element-chart', true);
        this._focusY.attr('y1', this._height);
        // performance.mark('size end');
        // performance.measure('size', 'size start', 'size end');
        this._redraw();
      },

      _createScale: function(option) {
        switch (option) {
          case 'time':
            return d3.scaleTime();
            break;
          case 'ln':
            return d3.scaleLog().base(Math.E);
            break;
          case 'log₁₀':
            return d3.scaleLog();
            break;
          case '√':
            return d3.scaleSqrt();
            break;
          default:
            return d3.scaleLinear();
        }
      },

      _createAxis: function(scale, orient, kind, tickmult) {
        var axis, ticks, horTicks, verTicks;
        tickmult = tickmult || 1;

        switch (orient) {
          case 'top':
            axis = d3.axisTop();
            ticks = this.xTicks;
            break;
          case 'bottom':
            axis = d3.axisBottom();
            ticks = this.xTicks;
            break;
          case 'left':
            axis = d3.axisLeft();
            ticks = this.yTicks;
            break;
          case 'right':
            axis = d3.axisRight();
            ticks = this.yTicks;
            break;
        }
        axis.scale(scale).ticks(ticks * tickmult);
        if (kind === 'time')
          axis.ticks(ticks * tickmult)
          .tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat( (d) => {
            return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
          })

        return axis;
      },

      timeFormat: function(date) {
        return (d3.timeSecond(date) < date ? this.format.Millisecond :
          d3.timeMinute(date) < date ? this.format.Second :
          d3.timeHour(date) < date ? this.format.Minute :
          d3.timeDay(date) < date ? this.format.Hour :
          d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.format.Day : this.format.Week) :
          d3.timeYear(date) < date ? this.format.Month :
          this.format.Year)(date);
      },

      timeFormatRange: function(date, r, pixels) {
        var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.format.Millisecond :
          rangeRatio < 500 ? this.format.LongSecond :
          rangeRatio < 5000 ? this.format.Second :
          rangeRatio < 20000 ? this.format.LongMinute :
          rangeRatio < 60000 ? this.format.Minute :
          rangeRatio < 3600000 ? this.format.Hour :
          rangeRatio < 86400000 ? this.format.Day :
          rangeRatio < 604800000 ? this.format.Week :
          rangeRatio < 2419200000 ? this.format.Month :
          this.format.Year)(date);
      },

      redraw: function() {
        if (this._chart === undefined || this._chart.select === undefined) return;
        Promise.resolve( this.setDomains.call(this) )
              .then( this._redraw.bind(this) )
              .catch( (err) => {
                console.warn(err);
              });
      },

      _redraw: function() {
        if (this._chart === undefined || this._chart.select === undefined) return;
        if (this._graphs.size > 0) {
          this._graphs.forEach( (g) => {
            // performance.mark('start');
            if (g.redraw)
              g.redraw();
            // performance.mark('end');
            // performance.measure(g.ident, 'start', 'end');
          });
          // p = performance.getEntriesByType('measure');
          //   for (var i=0; i < p.length; i++) {
          //     console.log ('performance.measure ' + p[i].name +
          //         //  ' startTime = ' + p[i].startTime +
          //          ' duration  = ' + p[i].duration);
          //   }
          // performance.clearMarks();
          // performance.clearMeasures();
        }

        this._chart.select('#xAxis').transition(50).call(this._xAxis);
        this._chart.select('#yAxis').transition(50).call(this._yAxis);
        this._chart.select('#xGrid').transition(50).call(this._xGrid);
        this._chart.select('#yGrid').transition(50).call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('webvisual-element-chart', true);
        this._updateInfo();
        // this._hideInfo();
      },

      brushed: function() {
        var s = d3.event.selection;
        if (s) {
          this._isBrushed = true;
          this._isZoomed = true;
          this._x.domain([s[0][0], s[1][0]].map(this._x.invert, this._x)).nice(this.xTicks);
          this._y.domain([s[1][1], s[0][1]].map(this._y.invert, this._y)).nice(this.yTicks);
          this._brush.call(this._brushBehavior.move, null);
          return;
        } else if (this._isBrushed === true) {
          this._isBrushed = false;
        } else {
          this._isZoomed = false;
          Promise.resolve(this.setDomains.call(this))
                 .then( this._redraw.bind(this) )
                 .catch( (err) => {
                    console.warn(err);
                 });
          return;
        }
        this._redraw();
      },

      setDomains: function() {
        var domainX
          , domainY;

        return new Promise( (resolve, reject) => {
          if (!this._graphs.size)
            reject('No Graphs are attached');
          if (this._isZoomed === true) {
            resolve();
          }

          this.requestRange('x')
              .then( (rangeX) => {
                domainX = rangeX;
                this.requestRange('y')
                    .then( (rangeY) => {

                      domainY = rangeY;

                      // rounding y-domains to the according decimal exponent
                      if (domainY[0] !== undefined && domainY[1] !== undefined && domainY[0] === domainY[1]) {
                        v = (domainY[0]).toExponential().split('e');
                        v.map( (vl) => { return parseInt(vl); });
                        domainY[0] = Math.floor(v[0] - 0.1) * Math.pow(10, v[1]);
                        v = (domainY[1]).toExponential().split('e');
                        v.map( (vl) => { return parseInt(vl); });
                        domainY[1] = Math.ceil(v[0] + 0.1) * Math.pow(10, v[1]);
                      }

                      if (this.yScale === '√' || this.yScale === 'ln' || this.yScale === 'log₁₀') {
                        if (domainY[0] <= 0) {
                          domainY[0] = 1e-15;
                        }
                        if (domainY[1] <= 0) {
                          domainY[1] = 1e-15;
                        }
                      }

                      this._x.domain(domainX);
                      this._y.domain(domainY).nice(this.yTicks);
                      resolve();

                    })
                    .catch( (err) => {
                      reject(err);
                    });
              })
              .catch( (err) => {
                reject(err);
              });
        });
      },

      requestRange: function(key) {
        return new Promise( (resolve, reject) => {
          var p = [];
          var res = [];
          this._graphs.forEach( (g) => {
            p.push( g.requestRange(key)
                     .then( (range) => { res.push(range) })
                     .catch( (err) => {
                       reject(err);
                     }) );
          });
          Promise.all(p)
                 .then( () => {
                   var min, max;
                   for (var i = 0; i < res.length; i++) {
                     min = (min === undefined || min > res[i][0]) ? res[i][0] : min;
                     max = (max === undefined || max < res[i][1]) ? res[i][1] : max;
                   }
                   if (min === undefined || max === undefined) {
                     reject();
                   }
                   resolve([min, max]);
                 })
                 .catch( (err) => {
                   reject(err);
                 });
        } );
      },

      _showInfo: function(d) {
        this.cancelDebouncer('hideinfo');
        var x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
        this._info.text(x + ' , ' + d.y);
        this._info.x = d.x;
        this._info.y = d.y;
        this._info.attr('hidden', null);
        this._focus.transition(33).attr('hidden', null);
        this._updateInfo();
      },

      _hideInfo: function() {
        this.debounce('hideinfo', this._debounceHideInfo, 750);
      },

      _debounceHideInfo: function() {
        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);
        this._chart.select('#xAxis').transition(50).call(this._xAxis);
        this._chart.select('#yAxis').transition(50).call(this._yAxis);
        this._info.transition(33).attr('hidden', '');
        this._focus.transition(33).attr('hidden', '');
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('webvisual-element-chart', true);
      },

      _updateInfo: function() {
        if (this._info.attr('hidden') === '' || this._info.x === undefined || this._info.y === undefined) return;
        var bbox = this._info.node().getBBox();
        // console.log(bbox, this._width, this._height);
        var x = this._x(this._info.x),
          y = this._y(this._info.y);
        this._info.transition(33)
          .attr('x', (x + 4 + bbox.width > this._width ? (x - 4 - bbox.width < 0 ? 0 : x - 4 - bbox.width) : x + 4))
          .attr('y', (y > bbox.height + 4 ? y - 4 : bbox.height));
        this._focusX.transition(33)
          .attr('x2', x)
          .attr('y2', y)
          .attr('y1', y);
        this._focusY.transition(33)
          .attr('y2', y)
          .attr('x2', x)
          .attr('x1', x);

        this._xAxis.tickValues([this._info.x]);
        this._yAxis.tickValues([this._info.y]);
        this._chart.select('#xAxis').transition(50).call(this._xAxis);
        this._chart.select('#yAxis').transition(50).call(this._yAxis);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('webvisual-element-chart', true);
      },

      openLegend: function() {
        var graphs = [];
        this._graphs.forEach(
          (g) => {
            graphs.push({type: 'webvisual-element-checkbox', checked: g.checked, item: g.item})
          });
        // console.log(graphs);
        this.fire('open-settings', { trigger: this, title: 'chart', settings: [ {title: 'graphs', entries: graphs} ]} );
      },

      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        } else {
          this.$.menu.setAttribute('hidden', '');
        }
      },

      changeInterpolation: function(interpolation, oldValue) {
        if (!this._graphs.size) return;
        this._graphs.forEach(
          (g) => {
            g.interpolation = interpolation;
          });
      },

      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        if (this._isZoomed === false) {
          Promise.resolve(this.setDomains.call(this))
                 .then( () => {
                   this._buildLayout();
                   this._sizeLayout();
                   this._redraw();
                 })
                 .catch( (err) => {
                   console.warn(err);
                 });
          return;
        }
        var domainX = this._x.domain();
        var domainY = this._y.domain();
        if (this.yScale === '√' || this.yScale === 'ln' || this.yScale === 'log₁₀') {
          if (domainY[0] <= 0) {
            domainY[0] = 1e-15;
          }
          if (domainY[1] <= 0) {
            domainY[1] = 1e-15;
          }
        }
        this._buildLayout();
        this._sizeLayout();
        this._x.domain(domainX);
        this._y.domain(domainY).nice(this.yTicks);
        this._redraw();
      },

      changeDots: function(e) {
        this.noDots = !e.target.checked;
        if (!this._graphs.size) return;
        this._graphs.forEach(
          (g) => {
            g.set('noDots', !e.target.checked)
          });
      },

      changeLines: function(e) {
        this.noLines = !e.target.checked;
        if (!this._graphs.size) return;
        this._graphs.forEach(
          (g) => {
            g.set('noLine', !e.target.checked)
          });
      },

      changeAreas: function(e) {
        this.noAreas = !e.target.checked;
        if (!this._graphs.size) return;
        this._graphs.forEach(
          (g) => {
            g.set('noFill', !e.target.checked)
          });
      },

      _startZoomSession: function() {
        if (this._zoomOverlay.classed('active')) {
          this._zoomOverlay.classed('active', null);
        } else {
          this._zoomOverlay.classed('active', true);
        }
      },

      _resetZoom: function(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this.redraw();
      }
    });
  </script>

</dom-module>
