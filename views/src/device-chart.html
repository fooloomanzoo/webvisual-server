<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="mixins/axes-mixin.html">
<link rel="import" href="mixins/fullscreen-mixin.html">

<link rel="import" href="components/icon-button.html">
<link rel="import" href="components/drawer-element.html">
<link rel="import" href="style/selectbox-style.html">
<link rel="import" href="style/button-style.html">

<link rel="import" href="device-graph.html">
<link rel="import" href="dialog-chart-export.html">

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        display: block;
        box-sizing: border-box;
        position: relative;
        font: inherit;
        color: white;
        letter-spacing: normal;
        user-select: none !important;
        z-index: auto;
        width: 100%;
        height: 100%;
        transition: background 150ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100vh;
        min-width: 100vw;
        padding: 1.25em !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      :host(:-webkit-full-screen) *, :host([without-mixmode]) * {
        mix-blend-mode: unset !important;
      }
      #svg {
        width: 100%; height: 100%;
        overflow: visible;
        font-family: inherit !important;
      }
      text {
        fill: currentColor;
        stroke: #000;
        stroke-width: 0.2;
        stroke-opacity: 0.2;
        font-size: 11px !important;
        letter-spacing: -0.025em;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
        pointer-events: none;
      }
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
        isolation: isolate;
      }
      .grid .tick line {
        color: var(--grid-color, currentColor);
        stroke-opacity: 0.1;
        stroke-width: 0.75px;
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis {
        cursor: -webkit-grab;
        cursor: grab;
        pointer-events: all;
        font-family: inherit !important;
      }
      .axis.dragged {
        cursor: -webkit-grabbing;
        cursor: grabbing;
      }
      .axis path, .axis line {
        fill: currentColor;
        fill-opacity: 0.01;
        stroke: currentColor;
        stroke-opacity: 0.75;
        transition: fill-opacity 200ms linear;
      }
      .axis:hover path {
        fill-opacity: 0.2;
      }
      .axis.expanded path, .axis.expanded line {
        stroke-opacity: 0.9;
      }
      .axis.dragged path {
        fill-opacity: 0.2;
      }
      .brush .selection {
        fill: currentColor;
        fill-opacity: 0.8;
        stroke: currentColor;
        stroke-width: 0;
      }
      .axis.vertical .brush .overlay {
        cursor: default;
      }
      .axis:not(.vertical) .brush .overlay {
        cursor: default;
      }
      #graphs .area {
        fill-opacity: 0.4;
        @apply --chart-area;
      }
      #graphs .area:last-of-type {
        fill-opacity: 0.5;
        mix-blend-mode: hard-light;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.9;
        @apply --chart-line;
      }
      #graphs .line:last-of-type {
        stroke-opacity: 1;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *:not(.dot),
      #delta > *:not(.dot) {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: var(--focus-opacity, 0.75);
        stroke-dasharray: 1;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #delta .line,
      #focus .line {
        mix-blend-mode: exclusion;
        pointer-events: none;
      }
      #zoom {
        cursor: default;
        fill: none;
        stroke: none;
        pointer-events: all;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        stroke: #000;
        stroke-opacity: 0.75;
        stroke-width: 1px;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
        mix-blend-mode: exclusion;
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      icon-button {
        background: rgba(255,255,255,0.0625);
      }
      .checkbox,
      .selectbox,
      .button {
        font-size: 0.8em;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .button {
        padding: 0.3em;
        flex: initial;
      }
      #options {
        position: absolute;
        --drawer-color: #151515;
        --drawer-height: auto;
        --drawer-background: rgba(255,255,255,0.5);
        --drawer-content: {
          padding: 0;
          position: absolute;
          flex-wrap: wrap;
        };
      }
      .selectbox > select {
        opacity: 1;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMinYMin meet">
      <defs>
        <marker id="arrowToLeft" viewBox="0 0 20 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 20,0 L 0,5 L 20,10 Z" />
        </marker>
        <marker id="arrowToRight" viewBox="0 0 20 10" refX="20" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0,0 L 20,5 L 0,10 Z" />
        </marker>
        <marker id="stub" markerWidth="8" markerHeight="6" refX="6" refY="5" orient="auto" markerUnits="strokeWidth" viewBox="0 0 6 10">
          <path d="M 5,10 M 4,0 H 6 V 10 H 4 Z"/>
          <path d="M 3,5 M 0,4 H 6 V 6 H 0 Z"/>
        </marker>
        <filter id="solid">
          <feFlood flood-color="#fff" result="out1" />
          <feComposite in="SourceGraphic" in2="out1"
            operator="over" />
        </filter>
      </defs>
      <g id="chart" on-click="_closeControl">
        <clipPath id="clip">
          <rect x="0" y="0"></rect>
        </clipPath>
        <rect id="plot" clip-path="url(#clip)"></rect>
        <g class="grid" clip-path="url(#clip)">
          <g id="gridX"></g>
          <g id="gridY"></g>
        </g>
        <g id="graphs" clip-path="url(#clip)">
          <g id="area"></g>
          <g id="line"></g>
          <g id="boundery"></g>
        </g>
        <rect id="zoom" x="0" y="0" on-contextmenu="_resetZoom"></rect>
        <g id="delta" hidden>
          <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
          <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
          <circle id="deltaDot" class="dot"></circle>
        </g>
        <g id="focus" hidden>
          <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
          <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
          <circle id="focusDot" class="dot"></circle>
        </g>
        <g id="axis"></g>
        <g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </g>
    </svg>

    <drawer-element id="options" opened$="[[showControl]]" align="top" stretch>
      <div class="selectbox">
        <select value="{{interpolation::change}}">
          <option value="Lineare Verbindung">Lineare Verbindung</option>
          <option value="Basis Spline">Basis Spline</option>
          <option value="Kubischer Spline">Kubischer Spline</option>
          <option value="Cardinaler Spline">Cardinaler Spline</option>
          <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
          <option value="Stufe (mitte)">Stufe (mitte)</option>
          <option value="Stufe (davor)">Stufe (davor)</option>
          <option value="Stufe (danach)">Stufe (danach)</option>
        </select>
      </div>
      <div class="selectbox">
        <select value="{{scalingY::change}}">
          <option value="linear">linear</option>
          <option value="√">√</option>
          <option value="ln">ln</option>
          <option value="log₂">log₂</option>
          <option value="log₁₀">log₁₀</option>
        </select>
      </div>
      <div class="selectbox">
        <select value="{{modus::change}}">
          <option value="zoom">zoom</option>
          <option value="delta">delta</option>
        </select>
      </div>
      <div class="checkbox">
        <input type="checkbox" name="multiX" checked="{{multiAxesX::change}}">mehrere x-Achsen
      </div>
      <div class="checkbox">
        <input type="checkbox" name="multiY" checked="{{multiAxesY::change}}">mehrere y-Achsen
      </div>
      <div class="button" on-click="_openExportDialog" hidden$="[[exportDisabled]]">
        <iron-icon style="margin-right:0.5em;" icon="file-download"></iron-icon>Export
      </div>
    </drawer-element>
    <section id="control">
      <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
      <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen" hidden$="[[fullscreenDisabled]]"></icon-button>
    </section>

    <template is="dom-if" if="[[multi]]" restamp>
      <template is="dom-repeat" items="[[items]]">
        <device-graph item="[[item]]" interpolation="[[interpolation]]" locale-date="[[localeDate]]" locale-number=[[localeNumber]] range-x=[[rangeX]] range-y=[[rangeY]] no-link="[[!opened]]" scaling-y="[[scalingY]]" scaling-x="[[scalingX]]"></device-graph>
      </template>
    </template>
    <template is="dom-if" if="[[!multi]]" restamp>
        <device-graph item="[[item]]" interpolation="[[interpolation]]" locale-date="[[localeDate]]" locale-number=[[localeNumber]] range-x=[[rangeX]] range-y=[[rangeY]] no-link="[[!opened]]" scaling-y="[[scalingY]]" scaling-x="[[scalingX]]"></device-graph>
      </template>
    </template>
  <script>
    class DeviceChart extends Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], WebvisualMixins.AxesMixin(WebvisualMixins.FullscreenMixin(WebvisualMixins.LocalizeMixin(Polymer.Element)))) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {

          opened: {
            type: Boolean
          },

          hasGrid: {
            type: Boolean,
            value: true
          },

          margin: {
            type: Object,
            value: function() {
              return {top: 8, right: 6, bottom: 6, left: 6}
            }
          },

          multiAxesX: {
            type: Boolean,
            value: false
          },

          multiAxesY: {
            type: Boolean,
            value: true
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          fullscreenDisabled: {
            type: Boolean,
            value: false
          },

          exportDisabled: {
            type: Boolean,
            value: false
          },

          autoHideFocusDisabled: {
            type: Boolean
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          },

          /**
           * folder for date/time-format file
           */
          languageResourcePrefix: {
            type: String,
            value: '/locales/format/'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._graphs = new Set();
      }

      get _self() {
        return this;
      }

      static get observers() {
        return [
          '_localizeChanged(localize)',
          '_multiAxesChanged(multiAxesX, multiAxesY)',
        ]
      }

      _localizeChanged(localize) {
        this.set('localeDate', localize('date'));
        this.set('localeNumber', localize('number'));
      }

      _fireResize() {
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: false,
          composed: true,
          node: this
        }));
        this.sizeChanged();
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _buildLayout() {
        // console.log('_buildLayout');
        this._svg = d3.select(this.$.svg)
          .attr('height', null)
          .attr('width', null);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._axisInsertionPoint = d3.select(this.$.axis);
        this._area = d3.select(this.$.area);
        this._line = d3.select(this.$.line);
        this._boundery = d3.select(this.$.boundery);

        this.gridX = d3.select(this.$.gridX);
        this.gridY = d3.select(this.$.gridY);

        this.axisX = this._computeAxisNode(this._axisInsertionPoint, this.axisOrientX, '', this.axisX)
          .classed('main', true)
          .attr('hidden', this.multiAxesX ? true : null);
        this.axisY = this._computeAxisNode(this._axisInsertionPoint, this.axisOrientY, '', this.axisY)
          .classed('main', true)
          .attr('hidden', this.multiAxesY ? true : null);
        this.axisGeneratorX = this._computeAxisGenerator(this.axisOrientX, this.scaleX, this.scalingX, this.scaleBaseX);
        this.axisGeneratorY = this._computeAxisGenerator(this.axisOrientY, this.scaleY, this.scalingY, this.scaleBaseY);

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            if (this._activeHideInfoJob) {
              clearTimeout(this._activeHideInfoJob);
            }
          }, {
            passive: true
          })
          .on('mouseleave', this._debouncedHideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        this._zoomBehavior = d3.zoom()
          .scaleExtent([0.95, Infinity])
          .on("zoom", this._onZoomed.bind(this));

        this._zoom = d3.select(this.$.zoom)
          .call(this._zoomBehavior);

        this._zoom
          .on('mouseenter touchstart', this._showInfo.bind(this), {
            passive: true
          })
          .on('mouseleave touchend', () => {
            this._debouncedHideInfo(this);
          }, {
            passive: true
          })
          .on('mousemove', () => {
            const m = d3.mouse(this._chart.node());
            requestAnimationFrame(() => {
              let closestGraph, closestPoint, closestDistance, fill;
              this._graphs.forEach(g => {
                if (g.values && g.values.length) {
                  const d = g._closestPoint(m);
                  const currentMin2 = Math.pow(m[0] - g.scaleX(d.x), 2) + Math.pow(m[1] - g.scaleY(d.y), 2); // in px²
                  if (closestDistance === undefined || currentMin2 < closestDistance) {
                    closestDistance = currentMin2;
                    closestPoint = d;
                    closestGraph = g;
                  }
                }
              });
              if (closestPoint) {
                fill = '#fff';
                if (closestGraph.item.threshold) {
                  switch (closestPoint.state) {
                    case 1:
                      fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
                      break;
                    case -1:
                      fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
                      break;
                  }
                }
                this._focusedValue = closestPoint;
                this._focusedValue.g = closestGraph;
                this._focusedValue._left = this.multiAxesY ? closestGraph.axisY._left : this.axisY._left;
                this._focusedValue._top = this.multiAxesX ? closestGraph.axisX._top : this.axisX._top;
                this._focusDot.datum(closestPoint)
                  .attr('fill', fill)
                  .attr('r', closestGraph.dotRadius);
                this._showInfo();
                this._moveInfo(closestPoint);
              } else {
                this._debouncedHideInfo();
              }
            });
          }, {
            passive: true
          });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true).classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._multiAxesChanged(this.multiAxesX, this.multiAxesY);
        this.sizeChanged();
      }

      reset() {
        this.opened = false;
        this.set('item', {});
        this.set('items', []);
        this.set('exceeding', []);
        this._debouncedHideInfo();
        this._fixedValue = null;
        this._focusedValue = null;
      }

      sizeChanged() {
        // only resize if initialized
        if (!(this.opened && this._isAttached)) return;
        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }
        this._activeSizeJob = setTimeout(() => {
          this.sizeLayout();
        }, 0);
      }

      sizeLayout() {
        if (!(this.opened && this._isAttached)) return;
        const bRect = this.$.svg.getBoundingClientRect();

        if (this._activeSizeJob) {
          clearTimeout(this._activeSizeJob);
          this._activeSizeJob = null;
        }

        if (bRect.height === 0 || bRect.width === 0) {
          requestAnimationFrame(() => {
            this.sizeChanged();
          });
          return;
        }

        this._debouncedHideInfo();

        this._chart._top = 0;
        this._chart._right = 0;
        this._chart._bottom = 0;
        this._chart._left = 0;
        let size;
        const q = [],
          p = [];

        this._graphs.forEach(g => {
          if (g._isAttached) {
            let size;
            if (!g.axisX.attr('hidden')) {
              size = g.axisX.classed('expanded') ? g.axisSizeX : g.tickSize + g.collapsedAxisMargin;
              q.push(this._incremAxisPosition(g.axisX, g.axisOrientX, size));
            }
            if (!g.axisY.attr('hidden')) {
              size = g.axisY.classed('expanded') ? g.axisSizeY : g.tickSize + g.collapsedAxisMargin;
              q.push(this._incremAxisPosition(g.axisY, g.axisOrientY, size));
            }
          }
        })
        if (!this.axisX.attr('hidden')) {
          size = this.axisX.classed('expanded') ? this.axisSizeX : this.tickSize + this.collapsedAxisMargin;
          q.push(this._incremAxisPosition(this.axisX, this.axisOrientX, size));
        }
        if (!this.axisY.attr('hidden')) {
          size = this.axisY.classed('expanded') ? this.axisSizeY : this.tickSize + this.collapsedAxisMargin;
          q.push(this._incremAxisPosition(this.axisY, this.axisOrientY, size));
        }

        Promise.all(q).then(() => {
          const bRect = this.$.svg.getBoundingClientRect();
          this._width = Math.abs(bRect.width - Math.abs(this._chart._left || 0) - Math.abs(this._chart._right || 0) - (this.margin.left || 0) - (this.margin.right || 0));
          this._height = Math.abs(bRect.height - Math.abs(this._chart._bottom || 0) - Math.abs(this._chart._top || 0) - (this.margin.top || 0) - (this.margin.bottom || 0));

          this.set('rangeX', [0, this._width]);
          this.set('rangeY', [this._height, 0]);

          this._zoom.attr('height', this._height).attr('width', this._width);
          this._zoomBehavior
            .translateExtent([
              [0, 0],
              [this._width, this._height]
            ])
            .extent([
              [0, 0],
              [this._width, this._height]
            ])
          // this._zoom.call(this._zoomBehavior.transform, d3.zoomIdentity);

          this._graphs.forEach(g => {
            if (g._isAttached) {
              if (!g.axisX.attr('hidden')) {
                p.push(this._finalizeAxisPosition(g.axisX, g.axisOrientX, this._width, this._height));
              }
              if (!g.axisY.attr('hidden')) {
                p.push(this._finalizeAxisPosition(g.axisY, g.axisOrientY, this._width, this._height));
              }
            }
          })
          if (!this.axisX.attr('hidden')) {
            p.push(this._finalizeAxisPosition(this.axisX, this.axisOrientX, this._width, this._height));
          }
          if (!this.axisY.attr('hidden')) {
            p.push(this._finalizeAxisPosition(this.axisY, this.axisOrientY, this._width, this._height));
          }

          Promise.all(p).then(() => {
            // Limiting Projection to Margin
            this._chart.select('clipPath#clip rect').transition()
              .attr('width', this._width)
              .attr('height', this._height);

            this._chart.select('rect#plot').transition()
              .attr('width', this._width)
              .attr('height', this._height);

            let left = (-this._chart._left || 0) + (this.margin.left || 0),
              top = (-this._chart._top || 0) + (this.margin.top || 0),
              right = (-this._chart._right || 0) - (this.margin.right || 0),
              bottom = (-this._chart._bottom || 0) - (this.margin.bottom || 0);
            this._chart.transition().attr('transform', 'translate(' + left + ',' + top + ')');
            this._focusY.attr('y1', this._height);

            this._graphs.forEach(g => {
              if (g._isAttached) {
                if (!g.axisX.attr('hidden')) {
                  g.axisGeneratorX = g._computeAxisGenerator.call(g, g.axisOrientX, g.scaleX, g.scalingX, g.scaleBaseX).ticks(g.ticksX).tickSize(g.tickSize).tickFormat(g.axisX.classed('expanded') ? g._computeFormatFn(g.scalingX, g.scaleBaseX) :
                    '');
                  g._updateAxisBrushGenerator.call(g.axisBrushGeneratorX, this.rangeX, g.axisOrientX);
                  g.axisX.select('.brush').raise().call(g.axisBrushGeneratorX);
                  g.axisX.attr('transform', 'translate(' + (g.axisX._left || 0) + ',' + (g.axisX._top || 0) + ')');
                }
                if (!g.axisY.attr('hidden')) {
                  g.axisGeneratorY = g._computeAxisGenerator.call(g, g.axisOrientY, g.scaleY, g.scalingY, g.scaleBaseY).ticks(g.ticksY).tickSize(g.tickSize).tickFormat(g.axisY.classed('expanded') ? g._computeFormatFn(g.scalingY, g.scaleBaseY) :
                    '');
                  g._updateAxisBrushGenerator.call(g.axisBrushGeneratorY, this.rangeY, g.axisOrientY);
                  g.axisY.select('.brush').raise().call(g.axisBrushGeneratorY);
                  g.axisY.attr('transform', 'translate(' + (g.axisY._left || 0) + ',' + (g.axisY._top || 0) + ')');
                }
              }
            })

            if (!this.axisX.attr('hidden')) {
              this.axisGeneratorX = this._computeAxisGenerator(this.axisOrientX, this.scaleX, this.scalingX, this.scaleBaseX).ticks(this.ticksX).tickSize(this.tickSize).tickFormat(this.axisX.classed('expanded') ? this._computeFormatFn(
                this.scalingX, this.scaleBaseX) : '');
              this._updateAxisBrushGenerator.call(this.axisBrushGeneratorX, this.rangeX, this.axisOrientX);
              this.axisX.select('.brush').raise().call(this.axisBrushGeneratorX);
              this.axisX.attr('transform', 'translate(' + (this.axisX._left || 0) + ',' + (this.axisX._top || 0) + ')');
            }
            if (!this.axisY.attr('hidden')) {
              this.axisGeneratorY = this._computeAxisGenerator(this.axisOrientY, this.scaleY, this.scalingY, this.scaleBaseY).ticks(this.ticksY).tickSize(this.tickSize).tickFormat(this.axisY.classed('expanded') ? this._computeFormatFn(
                this.scalingY, this.scaleBaseY) : '');
              this._updateAxisBrushGenerator.call(this.axisBrushGeneratorY, this.rangeY, this.axisOrientY);
              this.axisY.select('.brush').raise().call(this.axisBrushGeneratorY);
              this.axisY.attr('transform', 'translate(' + (this.axisY._left || 0) + ',' + (this.axisY._top || 0) + ')');
            }

            this._svg.selectAll('g,line,text,path,rect')
              .classed('style-scope', true).classed('device-chart', true);

            this._control.transition().style('transform', 'translate(' + right + 'px,' + bottom + 'px)');

            if (!this.domainX || !this.domainY || this.domainX.some(e => {
                return e === undefined || e === null;
              }) || this.domainY.some(e => {
                return e === undefined || e === null;
              })) {
              this.redraw(true);
            } else {
              this.redraw();
            }
          })
        })
      }

      _incremAxisPosition(node, orient, size) {
        if (orient === 'left') {
          node._left = this._chart._left;
          node._right = 0;
          this._chart._left -= size;
        } else if (orient === 'right') {
          node._left = 0;
          node._right = this._chart._right;
          this._chart._right += size;
        } else {
          node._left = 0;
          node._right = 0;
        }
        if (orient === 'top') {
          node._bottom = 0;
          node._top = this._chart._top;
          this._chart._top -= size;
        } else if (orient === 'bottom') {
          node._bottom = this._chart._bottom;
          node._top = 0;
          this._chart._bottom += size;
        } else {
          node._bottom = 0;
          node._top = 0;
        }
        return true;
      }

      _finalizeAxisPosition(node, orient, width, height) {
        node._left += node._right;
        node._top += node._bottom;
        node._bottom = 0;
        node._right = 0;
        if (orient === 'right') {
          node._left += width;
        } else if (orient === 'bottom') {
          node._top += height;
        }
        return true;
      }

      _generateGrid() {
        if (this._gridBuildJob) {
          clearTimeout(this._gridBuildJob);
        }
        this._gridBuildJob = setTimeout(() => {
          if (this.hasGrid && (!this.multiAxesY || this._graphs.size <= 1)) {
            this.gridGeneratorY = d3.axisLeft(this.scaleY)
                    .ticks((this.ticksY * 2) || 10)
                    .tickSize(-this._width)
                    .tickFormat('');
            this.gridY.call(this.gridGeneratorY)
                    .attr('font-family', null)
                    .attr('font-size', null)
                    .attr('text-anchor', null)
            this.gridY.attr('hidden', null);
          } else {
            this.gridY.attr('hidden', true);
          }
          if (this.hasGrid && (!this.multiAxesX || this._graphs.size <= 1)) {
            this.gridGeneratorX = d3.axisBottom(this.scaleX)
                    .ticks((this.ticksX * 2) || 10)
                    .tickSize(this._height)
                    .tickFormat('');
            this.gridX.call(this.gridGeneratorX)
                    .attr('font-family', null)
                    .attr('font-size', null)
                    .attr('text-anchor', null);
            this.gridX.attr('hidden', null);
            this.gridX.call(this.gridGeneratorX.scale(this.scaleX));
          } else {
            this.gridX.attr('hidden', true);
          }
          this._gridBuildJob = null;
        }, 0)
      }

      _redomain() {
        if (!this._isAttached) return;
        if (this._activeRedrawJob) {
          clearTimeout(this._activeRedrawJob);
        }
        // console.log('_redomain')
        Promise.resolve(this._getDomain.call(this))
          .then(this.redraw.bind(this, false))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      redraw(force) {
        if (!this._isAttached) return;

        if (force) {
          // console.log('force')
          this._redomain();
          return;
        }
        // console.log('chart redraw')
        // async redrawing
        if (this._activeRedrawJob) {
          clearTimeout(this._activeRedrawJob);
        }
        this._activeRedrawJob = setTimeout(() => {

          if (!this.axisX.attr('hidden')) {
            this.axisX.transition().call(this.axisGeneratorX).attr('transform', 'translate(' + (this.axisX._left || 0) + ',' + (this.axisX._top || 0) + ')');
          }
          if (!this.axisY.attr('hidden')) {
            this.axisY.transition().call(this.axisGeneratorY).attr('transform', 'translate(' + (this.axisY._left || 0) + ',' + (this.axisY._top || 0) + ')');
          }

          this._graphs.forEach(g => {
            if (g._isAttached) {
              if (!g.axisX.attr('hidden')) {
                g.axisX.transition().call(g.axisGeneratorX).attr('transform', 'translate(' + (g.axisX._left || 0) + ',' + (g.axisX._top || 0) + ')');
              } else {
                g.set('domainX', this.domainX);
              }
              if (!g.axisY.attr('hidden')) {
                g.axisY.transition().call(g.axisGeneratorY).attr('transform', 'translate(' + (g.axisY._left || 0) + ',' + (g.axisY._top || 0) + ')');
              } else {
                g.set('domainY', this.domainY);
              }
              g.redraw();
            }
          })

          if (this.hasGrid) this._generateGrid();
          this._svg.selectAll('g,line,text,path,rect')
            .classed('style-scope', true).classed('device-chart', true);

          this._updateInfo();
        }, 0);
      }

      _multiAxesChanged(multiAxesX, multiAxesY) {
        if (!this._isAttached) return;
        let hidden;
        this._graphs.forEach(g => {
          if (g._isAttached) {
            hidden = multiAxesX ? null : true;
            g.axisX.attr('hidden', hidden);
            hidden = multiAxesY ? null : true;
            g.axisY.attr('hidden', hidden);
          }
        })
        hidden = multiAxesX ? true : null;
        this.axisX.attr('hidden', hidden);
        hidden = multiAxesY ? true : null;
        this.axisY.attr('hidden', hidden);
        hidden = (!multiAxesY && !multiAxesX) ? true : null;
        this.axisX.select('.brush').attr('hidden', hidden);
        this.axisY.select('.brush').attr('hidden', hidden);
        this._generateGrid();
        this._redomain();
        this.sizeChanged();
      }

      _addGraph(g) {
        this._graphs.add(g);
        this.sizeChanged();
      }

      _removeGraph(g) {
        this._graphs.delete(g);
        if (this._graphs.size === 0) {
          this.set('domainX', [null, null])
          this.set('domainY', [null, null])
        }
        g = null;
        this._fixedValue = null;
        this._focusedValue = null;
        this.sizeChanged();
      }

      _getDomain() {
        // console.log('_getDomain');
        return new Promise((resolve, reject) => {
          const p = [],
            q = [];
          this._graphs.forEach(g => {
            p.push(g._getDomain('x', this.multiAxesX))
            q.push(g._getDomain('y', this.multiAxesY))
          })
          Promise.all(p)
            .then(res => {
              let min, max, domain;
              for (let i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
              }
              if (min === undefined || max === undefined) {
                resolve();
              }
              domain = [min, max];
              this.set('domainX', domain);
              this.scaleX.domain(domain);
              if (this.multiAxesX === false) {
                this._graphs.forEach(g => {
                  g.axisX._isBrushed = false;
                  g.set('domainX', domain);
                  g.scaleX.domain(domain);
                })
              }
              Promise.all(q)
                .then(res => {
                  let min, max, domain;
                  for (let i = 0; i < res.length; i++) {
                    min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                    max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
                  }
                  if (min === undefined || max === undefined) {
                    resolve();
                  }
                  domain = [min, max];
                  this.set('domainY', domain);
                  if (this.multiAxesY === false) {
                    this._graphs.forEach(g => {
                      g.axisY._isBrushed = false;
                      g.set('domainY', domain);
                    })
                  }
                  resolve();
                })
                .catch(error => {
                  reject(error);
                })
            })
            .catch(error => {
              reject(error);
            });
        });
      }

      insertValues(data) {
        this._graphs.forEach(g => {
          if (g && g._isAttached && g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        })
      }

      clearValues() {
        this._graphs.forEach(g => {
          if (g && g._isAttached)
            g.clearValues();
        })
      }

      _moveInfo(d) {
        if (Number.isFinite(d.g.scaleY(d.y))) {
          const formatX = this._computeFormatFn.call(d.g, d.g.scalingX, d.g.scaleBaseX),
            formatY = this._computeFormatFn.call(d.g, d.g.scalingY, d.g.scaleBaseY),
            fixP = this._fixedValue;
          this._info.text(formatX(d.x) + ' ' + formatY(d.y) + ' ' + (d.g.item.unit || ''));
          if (fixP) {
            const diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            this._infoDeltaX.text((d.g.scalingX === 'time' ? d.g.formatTimeAbsolute : formatX)(diffX));
            this._infoDeltaY.text((d.g.scalingY === 'time' ? d.g.formatTimeAbsolute : formatY)(diffY));
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _debouncedHideInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._activeHideInfoJob = setTimeout(() => {
          this._hideInfo();
          this._activeHideInfoJob = null;
        }, 750);
      }

      _hideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true).classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        const focP = this._focusedValue;
        const x = focP.g.scaleX(+focP.x),
          y = focP.g.scaleY(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        if (this.modus === 'delta') {
          const fixP = this._fixedValue;
          if (fixP && fixP.x !== undefined && fixP.y !== undefined && !(focP.x === fixP.x && focP.y === fixP.y)) {
            const xFix = fixP.g.scaleX(+fixP.x),
              yFix = fixP.g.scaleY(+fixP.y);
            this._deltaX.attr('x1', x).attr('x2', xFix);
            this._deltaY.attr('y1', y).attr('y2', yFix);
            if (yFix < y) {
              this._deltaY.attr('x1', x).attr('x2', x);
              this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
            } else {
              this._deltaY.attr('x1', xFix).attr('x2', xFix);
              this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
            }
            if (yFix < y || xFix < x) {
              this._deltaX.attr('y1', yFix).attr('y2', yFix);
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
            } else {
              this._deltaX.attr('y1', y).attr('y2', y);
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, y, null, null, null, 'middle');
            }
            this._deltaDot.attr('cy', yFix).attr('cx', xFix);
          } else {
            this._hideDelta();
          }
        }
        this._focusX.attr('x1', focP._left).attr('x2', x).attr('y2', y).attr('y1', y);
        this._focusY.attr('y1', focP._top).attr('y2', y).attr('x2', x).attr('x1', x);
        this._focusDot.attr('cy', y).attr('cx', x);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true).classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        const bbox = node.getBBox(),
          height = this._height,
          width = this._width;
        let anchor = textAnchor || 'middle',
          alignment = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;
        switch (anchor) { // list is not complete!
          case 'middle':
            limitLeft += (bbox.width / 2);
            break;
          case 'end ':
            limitLeft += bbox.width;
            break;
        }
        switch (alignment) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
            break;
          case 'middle':
            limitBottom += (bbox.height / 2);
            break;
          case 'hanging':
            limitBottom -= bbox.height;
            break;
        }

        if (y - limitBottom <= 0) { // above top
          alignment = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft >= width) { // beyond right
          anchor = 'end';
        } else if (x - limitLeft <= 0) { // beyond left
          anchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', anchor);
        node.setAttribute('alignment-baseline', alignment);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
        this._fixedValue = null;
        this._focusedValue = null;
      }

      _dotClicked(d) {
        const oldzoom = this._zoom.node().__zoom,
          fP = this._fixedValue;
        let x, y, scale;
        switch (this.modus) {
          case 'zoom':
            x = d.g.scaleX(+d.x) - this._width / 6;
            y = (d.g.scaleY(+d.y) || 0) - this._height / 6;
            scale = oldzoom.k * 3;
            y = (oldzoom.y - y) / oldzoom.k;
            x = (oldzoom.x - x) / oldzoom.k;
            this._zoom.transition(300).call(this._zoomBehavior.transform, d3.zoomIdentity
              .scale(scale)
              .translate(x, y));
            break;
          case 'delta':
            if (!(fP && fP.x !== undefined && fP.y !== undefined && fP.x === d.x && fP.y === d.y)) {
              this._fixedValue = d;
              this._deltaDot.datum(d)
                .attr('cx', d => {
                  return d.g.scaleX(d.x);
                })
                .attr('cy', d => {
                  return d.g.scaleY(d.y);
                })
                .attr('r', this._focusDot.attr('r'))
                .attr('fill', this._focusDot.attr('fill'));
            } else {
              this._fixedValue = null;
              this._hideDelta();
            }
            break;
          case 'integral':
            break;
        }
        this._updateInfo();
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation) {
        this._graphs.forEach(g => {
          if (g && g._isAttached)
            g.set('interpolation', interpolation);
        })
      }

      _onAxisBrushEnd(key) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        const s = d3.event.selection;
        if (!s) {
          return;
        }
        if (!this.multiAxesY && !this.multiAxesX) {
          if (key === 'x') this.axisX.select('.brush').call(this.axisBrushGeneratorX.move, null);
          if (key === 'y') this.axisY.select('.brush').call(this.axisBrushGeneratorY.move, null);
          return; // TODO: zoomm does not work correctly if brushing on all combined axes
        }
        const vertical = (key === 'y');
        let domain, oldzoom, scale, y, x;
        if (vertical) {
          domain = s.map(this.scaleY.invert, this.scaleY).sort((a, b) => {
            return a > b
          });
          this._graphs.forEach(g => {
            g.scaleY.domain(domain).nice();
            g.axisGeneratorY.scale(g.scaleY);
          })
          this.axisY._isBrushed = true;
          this.scaleY.domain(domain).nice();
          this.axisY.call(this.axisGeneratorY.scale(this.scaleY));
          this.axisY.select('.brush').call(this.axisBrushGeneratorY.move, null);
          oldzoom = this._zoom.node().__zoom;
          scale = oldzoom.k * this._height / (s[1] - s[0]);
          y = (oldzoom.y - s[0]) / oldzoom.k;
          this._zoom.transition(300).call(this._zoomBehavior.transform, d3.zoomIdentity
            .scale(scale)
            .translate(0, y));
        }
        if (!vertical) {
          domain = s.map(this.scaleX.invert, this.scaleX).sort((a, b) => {
            return a > b
          });
          this._graphs.forEach(g => {
            g.scaleX.domain(domain);
            g.axisGeneratorX.scale(g.scaleX);
          })
          this.axisX._isBrushed = true;
          this.scaleX.domain(domain);
          this.axisX.call(this.axisGeneratorX.scale(this.scaleX));
          this.axisX.select('.brush').call(this.axisBrushGeneratorX.move, null);
          oldzoom = this._zoom.node().__zoom;
          scale = oldzoom.k * this._width / (s[1] - s[0]);
          x = (oldzoom.x - s[0]) / oldzoom.k;
          this._zoom.transition(300).call(this._zoomBehavior.transform, d3.zoomIdentity
            .scale(scale)
            .translate(x, 0));
        }
        this._graphs.forEach(g => {
          g.redraw();
        })
        this._updateInfo();
      }

      _onZoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'brush') return; // ignore zoom-by-brush
        const t = d3.event.transform;
        if (!this.domainX || !this.domainY) {
          return;
        }
        const x = d3.event.transform.rescaleX(this.scaleX.domain(this.domainX));
        const y = d3.event.transform.rescaleY(this.scaleY.domain(this.domainY).nice());
        let domain;
        if (!this.multiAxesX) {
          domain = x.domain();
          this._graphs.forEach(g => {
            g.scaleX.domain(domain);
            g.axisGeneratorX.scale(g.scaleX);
          })
          this.scaleX.domain(domain);
          this.axisX.call(this.axisGeneratorX.scale(this.scaleX));
          if (this.hasGrid) this.gridX.call(this.gridGeneratorX.scale(this.scaleX));
        }
        if (!this.multiAxesY) {
          domain = y.domain();
          this._graphs.forEach(g => {
            g.scaleY.domain(domain);
            g.axisGeneratorY.scale(g.scaleY);
          })
          this.scaleY.domain(domain);
          this.axisY.call(this.axisGeneratorY.scale(this.scaleY));
          if (this.hasGrid) this.gridY.call(this.gridGeneratorY.scale(this.scaleY));
        }
        this._graphs.forEach(g => {
          g.redraw();
        })
        this._isZoomed = !(t.k === 1 && t.x === 0 && t.y === 0);
        this._updateInfo();
      }

      _onAxisClicked(axis) {
        if (this._activeToggleAxisJob) {
          clearTimeout(this._activeToggleAxisJob);
          this._activeToggleAxisJob = null;
          if (axis._isBrushed || this._isZoomed) {
            this._resetZoom();
          }
          return;
        }
        super._onAxisClicked(axis);
      }

      _onAxisContextMenu(orient) {
        if (d3.event)
          d3.event.preventDefault();
        if (this._isZoomed) {
          this._resetZoom();
        } else {
          super._onAxisContextMenu(orient);
        }
        this._debouncedHideInfo();
      }

      _closeControl() {
        this.showControl = false;
      }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this.showControl = false;
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this.axisX._isBrushed = false;
        this.axisY._isBrushed = false;
        this._graphs.forEach(g => {
          g.axisX._isBrushed = false;
          g.axisY._isBrushed = false;
          g.scaleX.domain(g.domainX);
          g.scaleY.domain(g.domainY);
          g.axisX.transition().call(g.axisGeneratorX.scale(g.scaleX));
          g.axisY.transition().call(g.axisGeneratorY.scale(g.scaleY));
        })
        this._zoom.transition(300).call(this._zoomBehavior.transform, d3.zoomIdentity.scale(1));
        this._hideInfo();
        this._redomain();
      }

      _openExportDialog() {
        if (!window._exportChartDialog) {
          const DialogChartExport = customElements.get('dialog-chart-export');
          window._exportChartDialog = new DialogChartExport(this);
          document.body.appendChild(window._exportChartDialog);
        } else {
          window._exportChartDialog.setChartElement(this);
        }
        window._exportChartDialog.open();
      }

      // _refresh() {
      //   this._buildLayout();
      //   this._graphs.forEach( g => {
      //     if (g && g._isAttached) {
      //       g.clearValues(true);
      //       g.requestValues(null, null, this.viewLength)
      //         .then(function(data) {
      //           for (var mount in data) {
      //             if (mount === this.item.mount) {
      //               this.insertValues(data[mount]);
      //               break;
      //             }
      //           }
      //         }.bind(g))
      //         .catch(err => {
      //           if (err) console.log(err);
      //         });
      //     }
      //   })
      //   this._isZoomed = false;
      //   this._redomain();
      // }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
