<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="behaviors/fullscreen-behavior.html" />

<link rel="import" href="components/icon-button.html" />
<link rel="import" href="style/selectbox-style.html" />
<link rel="import" href="style/button-style.html" />

<link rel="import" href="device-graph.html" />

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        box-sizing: border-box;
        position: relative;
        font-family: inherit;
        color: white;
        letter-spacing: normal !important;
        user-select: none !important;
        z-index: auto;
        transition: background 150ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100%;
        min-width: 100%;
        padding: 0 !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        isolation: isolate;
      }
      :host([fullscreen]) > #svgContainer {
        position: fixed;
        padding: 1em 1em 3em 1em !important;
      }
      #svgChart {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        width: 100%; height: 100%;
        overflow: visible;
        font-family: inherit;
      }
      text {
        fill: currentColor;
        stroke: none;
        font-size: 10px;
        letter-spacing: normal !important;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
      }
      /*g#brush .selection {
        stroke: currentColor;
        stroke-opacity: 0.7;
      }*/
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.15;
      }
      .grid {
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis {
        fill-opacity: 0.01;
      }
      .axis path, .axis line {
        fill: currentColor;
        fill-opacity: 0.01;
        stroke: currentColor;
        stroke-opacity: 0.5;
        transition: fill-opacity 150ms linear;
      }
      .axis:hover path {
        fill-opacity: 0.25;
      }
      .axis[expanded] path, .axis[expanded] line {
        stroke-opacity: 0.75;
      }
      .axis.button {
        pointer-events: all;
        cursor: pointer;
      }
      .x.axis > .tick:first-of-type:not(:only-of-type) > text {
        text-anchor: start;
      }
      .x.axis > .tick:last-of-type:not(:only-of-type) > text {
        text-anchor: end;
      }
      .y.axis > .tick:first-of-type:not(:only-of-type) > text {
        alignment-baseline: after-edge;
      }
      .y.axis > .tick:last-of-type:not(:only-of-type) > text {
        alignment-baseline: before-edge;
      }
      .brush .selection {
        fill: currentColor;
        stroke: currentColor;
        stroke-width: 0;
      }
      .axis[dir="vertical"] .brush .overlay {
        cursor: ns-resize;
      }
      .axis[dir="horizontal"] .brush .overlay {
        cursor: ew-resize;
      }
      #graphs .area {
        fill-opacity: 0.3;
        mix-blend-mode: overlay;
        @apply --chart-area;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.7;
        @apply --chart-line;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *,
      #delta > * {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #focus .line {
        stroke-dasharray: 2;
        mix-blend-mode: darken;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      #control > * {
        background: rgba(255,255,255,0.0625);
      }
      .selectbox,
      .button {
        font-size: 12px;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
        color: var(--primary-text-color);
      }
      .button {
        padding: 0.3em;
      }
      #controlcontent {
        transform: translateY(-100%);
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-dir: column;
        background-color: rgba(255, 255, 255, 0.25);
      }
      icon-button {
        mix-blend-mode: overlay;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer" on-contextmenu="_resetZoom">
      <svg id="svgChart" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <marker id="arrowToLeft" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m 5.29167,-1.7197893 v 3.439581 L 0,2.6966667e-6 Z"/>
          </marker>
          <marker id="arrowToRight" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m -5.2916667,-1.7197893 v 3.439581 L 3.3333333e-6,2.6966667e-6 Z"/>
          </marker>
          <marker id="stub" markerWidth="5" markerHeight="5" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-1 -5 2 10">
            <path d="M0,0 m-1,-5 L1,-5 L1,5 L-1,5 z"/>
            <path d="M -2,0 M -5,-1 H 1 V 1 H -5 Z"/>
          </marker>
          <filter x="0" y="0" width="1" height="1" id="solid">
            <feFlood flood-color="white" id="flood"/>
            <feMerge>
              <feMergeNode in="flood" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <!-- <g id="xGrid" class="grid" clip-path="url(#clip)"></g> -->
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="area"></g>
            <g id="line"></g>
            <g id="boundery"></g>
            <g id="brush"></g>
          </g>
          <g id="delta" hidden>
            <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <circle id="deltaDot" class="dot"></circle>
          </g>
          <g id="focus" hidden>
            <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <circle id="focusDot" class="dot"></circle>
          </g>
          <g id="axis" on-tap="_resetZoom"></g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </svg>
  	</div>
    <section id="control">
      <iron-collapse id="controlcontent" opened="[[showControl]]">
        <div class="selectbox">
          <select value="{{interpolation::change}}">
            <option value="Lineare Verbindung">Lineare Verbindung</option>
            <option value="Basis Spline">Basis Spline</option>
            <option value="Kubischer Spline">Kubischer Spline</option>
            <option value="Cardinaler Spline">Cardinaler Spline</option>
            <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
            <option value="Stufe (mitte)">Stufe (mitte)</option>
            <option value="Stufe (davor)">Stufe (davor)</option>
            <option value="Stufe (danach)">Stufe (danach)</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{yScale::change}}">
            <option value="linear">linear</option>
            <option value="√">√</option>
            <option value="ln">ln</option>
            <option value="log₁₀">log₁₀</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{modus::change}}">
            <option value="zoom">zoom</option>
            <option value="delta">delta</option>
            <!-- <option value="integral">integral</option> -->
          </select>
        </div>
      </iron-collapse>
      <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
      <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></icon-button>
    </section>

    <template is="dom-if" if="[[multi]]" restamp>
      <template is="dom-repeat" items="[[items]]">
        <device-graph
          item="[[item]]"
          interpolation="[[interpolation]]"
          store-inside
          no-link="[[noLink]]">
        </device-graph>
      </template>
    </template>

    <template is="dom-if" if="[[!multi]]" restamp>
      <device-graph
        item="[[item]]"
        interpolation="[[interpolation]]"
        store-inside
        no-link="[[noLink]]">
      </device-graph>
    </template>

  </template>
  <script>
    class DeviceChart extends Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], WebvisualBehaviors.FullscreenBehavior(Polymer.Element)) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {

          margin: {
            type: Object,
            value: function() {
              return {
                top: 6,
                right: 6,
                bottom: 6,
                left: 6
              }
            }
          },

          gridMult: {
            type: Number,
            value: 2
          },

          multiAxes: {
            type: Object,
            value: function() {
              return {
                x: false,
                y: true
              };
            },
            observer: '_multiAxesChanged'
          },

          tickSize: {
            type: Number,
            value: 6
          },

          axisMargin: {
            type: Number,
            value: 6
          },

          axisSize: {
            type: Object,
            value: function() {
              return {
                x: 24,
                y: 48
              };
            }
          },

          axisPosition: {
            type: Object,
            value: function() {
              return {
                x: 'bottom',
                y: 'left'
              }
            },
            observer: '_axisPositionChanged'
          },

          scale: {
            type: Object,
            value: function() {
              return {
                x: 'time',
                y: 'linear'
              };
            },
            observer: '_scaleChanged'
          },

          domain: {
            type: Object,
            value: function() {
              return {
                x: [null, null],
                y: [null, null]
              };
            },
            notify: true
          },

          domainX: {
            type: Array,
            value: function() {
              return [null, null];
            },
            notify: true
          },

          domainY: {
            type: Array,
            value: function() {
              return [null, null];
            },
            notify: true
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          noLink: {
            type: Boolean
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._yGrid = {};
        this._brush = {};
        this._chart = {};
        this._control = {};
        this._svg = {};
        this._info = {};
        this._focus = {};
        this._focusX = {};
        this._focusY = {};
        this._focusDot = {};
        this._infoDeltaX = {};
        this._infoDeltaY = {};
        this._delta = {};
        this._deltaX = {};
        this._deltaY = {};
        this._deltaDot = {};
        this._focusedValue = null;
        this._fixedValue = null;
        this._nodes = {
          axis: {},
          brush: {}
        };
        this._fn = {
          var: { x: Function.prototype, y: Function.prototype },
          axis: { x: Function.prototype, y: Function.prototype },
          brush: { x: Function.prototype, y: Function.prototype }
        };
        this._generators = {
          brush: {},
          axis: {}
        }
        // this._xAxisFn = {};
        // this._yAxisFn = {};
        this._isAttached = false;
        this._isBrushed = false;
        this._isZoomed = false;
        this._brushBehavior = Function.prototype;
        this._graphs = {};
        this._graphElements = [];
        this._ticks = {};
        var localeDateFormat = {
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        }
        var localeNumberFormat = {
          'decimal': ',',
          'thousands': '.',
          'grouping': [3],
          'currency': ['', '\u00a0€']
        };
        d3.timeFormatDefaultLocale(localeDateFormat);
        d3.formatDefaultLocale(localeNumberFormat);
        this.format = {
          Millisecond: d3.timeFormat(':%S,%L'),
          LongSecond: d3.timeFormat(':%M:%S,%L'),
          Second: d3.timeFormat(':%M:%S'),
          LongMinute: d3.timeFormat('%H:%M:%S'),
          Minute: d3.timeFormat('%H:%M'),
          Hour: d3.timeFormat('%X'),
          Day: d3.timeFormat('%d.%m'),
          Week: d3.timeFormat('%d.%m'),
          Month: d3.timeFormat('%d. %b'),
          Year: d3.timeFormat('%Y'),
          timeDiff: function(date) {
            // one year = 365.25 days = 315576E5ms (Julian Calendar)
            var ry = date % 315576E5,
              y = (date - ry) / 315576E5,
              rd = ry % 864E5,
              d = (ry - rd) / 864E5,
              rh = rd % 36E5,
              h = (rd - rh) / 36E5,
              rm = rh % 6E4,
              m = (rh - rm) / 6E4,
              rs = rm % 1E3,
              s = (rm - rs) / 1E3,
              ret = '';
            if (y)
              ret += y + 'y ';
            if (d)
              ret += d + 'd ';
            if (h)
              ret += h + 'h ';
            if (m)
              ret += m + 'm ';
            if (s)
              ret += s + 's ';
            if (rs)
              ret += rs + 'ms';
            return ret;
          },
          Number: d3.format(',')
        }
      }

      get _self() {
        return this;
      }

      _fireResize() {
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: false, composed: true, node: this
        }));
        this._sizeChanged();
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _sizeChanged() {
        // only resize if initialized
        if (this._isAttached) {
          if (this._activeSizeJob) {
            clearTimeout(this._activeSizeJob);
          }
          this._activeSizeJob = setTimeout( () => {
            this._sizeLayout();
          }, 0);
        }
      }

      _buildLayout() {
        console.log('_sizeChanged');
        this._svg = d3.select(this.$.svgChart)
          .attr('height', null)
          .attr('width', null);
        this._fn.var.x = this._createScaleFn(this.scale.x);
        this._fn.var.y = this._createScaleFn(this.scale.y);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._nodes.axis = d3.select(this.$.axis);
        this._nodes.area = d3.select(this.$.area);
        this._nodes.line = d3.select(this.$.line);
        this._nodes.boundery = d3.select(this.$.boundery);

        // Test
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('x axis', true);
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        //

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            this.cancelDebouncer('hideinfo');
          }, {
            passive: true
          })
          .on('mouseleave', this._debouncedHideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        // this._brushBehavior = d3.brush()
        //   // .on('end', this.brushed.bind(this._self()));
        //   .on('end', this.brushed.bind(this));
        // this._brush = d3.select(this.$.brush);
        // this._brush
        //   .on('mouseenter touchstart', this._showInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mouseleave touchend', this._debouncedHideInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mousemove', () => {
        //     var m = d3.mouse(this._chart.node());
        //     requestAnimationFrame( () => {
        //       var closestGraph, closestPoint, closestDistance;
        //       var mounts = Object.keys(this._graphs), g;
        //       for (var i = 0; mounts && i < mounts.length; i++) {
        //         g = this._graphs[mounts[i]]
        //         if (g.values && g.values.length) {
        //           var d = g._closestPoint(m);
        //           var currentMin2 = Math.pow(m[0] - g._fn.var.x(d.x), 2) + Math.pow(m[1] - g._fn.var.y(d.y), 2); // in px²
        //           if (closestDistance === undefined || currentMin2 < closestDistance) {
        //             closestDistance = currentMin2;
        //             closestPoint = d;
        //             closestGraph = g;
        //           }
        //         }
        //       }
        //       if (closestPoint) {
        //         var fill = closestGraph.getComputedStyleValue('--device-color') || '#000';
        //         if (closestGraph.item.threshold) {
        //           switch (closestPoint.state) {
        //             case 1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
        //               break;
        //             case -1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
        //               break;
        //           }
        //         }
        //         this._focusedValue = closestPoint;
        //         this._focusedValue.g = closestGraph;
        //         this._focusedValue._y_axis = this.multiAxes.y ? (closestGraph._y_left + closestGraph._y_right) : 0;
        //         this._focusedValue._x_axis = this.multiAxes.x ? (closestGraph._x_bottom + closestGraph._x_top) : this._height;
        //         this._focusDot.datum(closestPoint)
        //           .attr('fill', fill)
        //           .attr('r', closestGraph.dotRadius);
        //         this._showInfo();
        //         this._moveInfo(closestPoint);
        //       } else {
        //         this._debouncedHideInfo();
        //       }
        //     });
        //   }, {
        //     passive: true
        //   })
        //   .on('touchmove', this._resetZoom.bind(this), {
        //     passive: true
        //   });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._sizeChanged();
      }

      _sizeLayout() {
        if (!this._isAttached) return;

        var bRect = this.$.svgChart.getBoundingClientRect();
        // console.log('sizeLayout', bRect);

        if (bRect.height === 0 || bRect.width === 0) return;

        let top = 0,
          right = 0,
          bottom = 0,
          left = 0,
          axisSize = this.axisSize,
          tickSize = this.tickSize,
          condensedSize = tickSize + this.axisMargin,
          size,
          lineWidth = 1,
          height,
          width,
          graphs = this._graphs,
          self = this,
          mounts = Object.keys(graphs),
          ax,
          g,
          exp,
          pos,
          axes,
          dir,
          mount;

        function incremPosition(axis, pos, size) {
          switch (pos) {
            case 'left':
              axis._left = left; axis._right = 0;
              left -= size;
              break;
            case 'right':
              axis._left = 0; axis._right = right;
              right += size;
              break;
            default:
              axis._left = 0; axis._right = 0;
          }
          switch (pos) {
            case 'top':
              axis._bottom = 0; axis._top = top;
              top -= size;
              break;
            case 'bottom':
              axis._bottom = bottom; axis._top = 0;
              bottom += size;
              break;
            default:
              axis._bottom = 0; axis._top = 0;
          }
        }

        function finalizePosition(g, ax, pos, dir, exp) {
          if (pos === 'left') {
            g._generators.brush[key].extent([[-tickSize, 0], [0, height]]);
          }
          else if (pos === 'right') {
            ax._right += width;
            g._generators.brush[key].extent([[0, 0], [tickSize, height]]);
          }
          else if (pos === 'top') {
            g._generators.brush[key].extent([[0, -tickSize], [width, 0]]);
          }
          else if (pos === 'bottom') {
            ax._bottom += height;
            g._generators.brush[key].extent([[0, 0], [width, tickSize]]);
          }
          switch (dir) {
            case 'vertical':
              g._fn.var[key].range([height, 0]);
              break;
            case 'horizontal':
              g._fn.var[key].range([0, width]);
              break;
            default:
              g._fn.var[key].range([height, width]);
          }
          g._generators.axis[key].tickFormat(exp ? null : '').tickSize(tickSize);
          g._nodes.axis[key].call(g._generators.axis[key]).transition(150).attr('transform', 'translate('+ (ax._left + ax._right) +',' + (ax._top + ax._bottom) + ')');
          g._nodes.brush[key].raise().call(g._generators.brush[key]);
        }

        for (let key in this.multiAxes) {
          let g, ax, size;
          for (let i = 0; i < mounts.length; i++) {
            g = graphs[mounts[i]];
            ax = g._nodes.axis[key];
            if (ax) {
              size = ax.attr('expanded') ? axisSize[key] : condensedSize;
              incremPosition(ax, g.axisPosition[key], size);
            }
          }
          ax = this._nodes.axis[key];
          if (ax) {
            size = ax.attr('expanded') ? axisSize[key] : condensedSize;
            incremPosition(ax, this.axisPosition[key], size);
          }
        }

        this._width = width = bRect.width - Math.abs(left || 0) - Math.abs(right || 0) - (this.margin.left || 0) - (this.margin.right || 0);
        this._height = height = bRect.height - Math.abs(bottom || 0) - Math.abs(top || 0) - (this.margin.bottom || 0) - (this.margin.top || 0);

        // this.xTicks = Math.ceil(this._width / 75);
        // this.yTicks = Math.ceil(this._height / 50);

        for (var key in this.multiAxes) {
          let g, ax, pos;
          if (this.multiAxes[key] === true) {
            for (let i = 0; i < mounts.length; i++) {
              g = graphs[mounts[i]];
              ax = g._nodes.axis[key];
              pos = g.axisPosition[key];
              if (ax) {
                finalizePosition(g, ax, pos, ax.attr('dir'), ax.attr('expanded'));
                console.log(key, g._fn.var[key].range(), g._fn.var[key].domain());
              }
            }
          }
          g = this;
          ax = this._nodes.axis[key];
          pos = g.axisPosition[key];
          if (ax) {
            finalizePosition(g, ax, pos, ax.attr('dir'), ax.attr('expanded'));
            console.log(key, g._fn.var[key].range(), g._fn.var[key].domain());
          }
        }

        top -= (this.margin.top || 0);
        right += (this.margin.right || 0);
        bottom += (this.margin.bottom || 0);
        left -= (this.margin.left || 0);
        this._control.transition(150).style('transform', 'translate(-'+right+'px,-'+bottom+'px)');

        // Limiting Projection to Margin
        this._chart.select('clipPath#clip rect').transition(150)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.select('rect#plot').transition(150)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.transition(150).attr('transform', 'translate(' + (-left || 0) + ',' + (-top || 0) + ')');

        // this._xGrid = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._height)
        //   .tickFormat('');
        // this._yGrid = this._createAxisFn(this._y, 'left', this.yScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._width)
        //   .tickFormat('');

        // this._chart.select('#xGrid')
        //   .attr('transform', 'translate(0,' + this._height + ')')
        //   .call(this._xGrid);
        // this._chart.select('#yGrid')
        //   .call(this._yGrid)
        //   .attr('transform', 'translate(0,' + 0 + ')');;

        // if (this._isBrushed !== true || this._isZoomed !== true) {
        //   this._brushBehavior.extent([
        //     [0, 0],
        //     [this._width, this._height]
        //   ])
        //   this._brush.call(this._brushBehavior);
        // }

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope device-chart', true)
        this._focusY.attr('y1', this._height);

        this._redraw(true);
      }

      _multiAxesChanged(multiAxes) {
        if (!this._isAttached) return;

        var mounts = Object.keys(this._graphs), axesMounts = [], graphs = this._graphs, self = this;
        this.axes = this.axes || {};

        for (var key in multiAxes) {
          this.axes[key] = this.axes[key] || {};
          axesMounts = multiAxes[key] ? mounts : [''];

          this.axes[key] = d3.select(this.$.axis).selectAll('g.axis.'+key).data(axesMounts);

          // enter new axes
          this.axes[key].enter()
            .append('svg:g')
              .classed('axis', true)
              .classed(key, true)
              .attr('expanded', d => {
                return d ? null : true; // main axis is expanded by default, others not
              })
              .attr('data-mount', d => {
                return d || '';
              })
              .attr('dir', d => {
                let g = graphs[d] || self, dir;
                switch (g.axisPosition[key]) {
                  case 'left':
                  case 'right':
                    dir = 'vertical';
                    break;
                  case 'bottom':
                  case 'top':
                    dir = 'horizontal';
                }
                return dir || null;
              })
              .on('click', function(d) {
                let a = d3.select(this), exp = a.attr('expanded');
                a.attr('expanded', exp ? null : true);
                self._sizeChanged();
              })
              .each( function(d) {
                let g = graphs[d] || self;
                console.log('add axis', key, d);
                switch (g.axisPosition[key]) {
                  case 'left':
                  case 'right':
                    g._generators.brush[key] = d3.brushY();
                    break;
                  case 'bottom':
                  case 'top':
                    g._generators.brush[key] = d3.brushX();
                    break;
                  // default:
                  //   this._graphs[d]._generators.brush[key] = d3.brush();
                }

                g._fn.var[key] = self._createScaleFn(g.scale[key]);
                g._generators.brush[key]
                      .on('brush', self.axisBrushMove.bind(g, key))
                      .on('end', self.axisBrushEnd.bind(g, key));
                g._generators.axis[key] = self._createAxisFn(g._fn.var[key], g.axisPosition[key], g.scale[key]);
                g._nodes.axis[key] = d3.select(this);
              })
              .call(d3.drag().on('drag', self.axisDragged))
              .append('svg:g')
                .classed('brush', true)
                .each( function(d) {
                  let g = graphs[d] || self;
                  g._nodes.brush[key] = d3.select(this);
                })

          // update all axes
          // this.axes[key].each( function(d) {
          //   if (d && graphs[d]) {
          //     graphs[d]._nodes.axis[key].call(graphs[d]._generators.axis[key]);
          //   }
          // })

          // remove not used axes
          this.axes[key].exit()
            .each( (d, i) => {
              console.log('remove axis', key, d);
              let g = graphs[d] || this;
              if (d) { // only reset graphs
                g._generators.brush[key] = null;
                g._generators.axis[key] = null;
                g._fn.var[key] = this._fn.var[key];
              }
              // remove axis & brush node
              if (g._nodes.axis[key]) {
                var node = g._nodes.axis[key].node();
                if (node && node.parentElement)
                  node.parentElement.removeChild(node);
              }
              g._nodes.axis[key] = null;
              g._nodes.brush[key] = null;
              this._sizeChanged();
            })
            .remove();
        }
      }

      axisBrushMove(key) {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return; // ignore brush-by-zoom
        console.log('brushmove', key, d3.event.selection);
        var s = (d3.event.selection || this._fn.var[key].range()).map(this._fn.var[key].invert, this._fn.var[key]);
        console.log(key, s);
        // this._fn.var[key].domain(s);
        // if (this.hasArea) {
        //   this._nodes.area.attr('d', this._generators.area);
        // }
        // if (this.hasLine) {
        //   this._nodes.line.attr('d', this._generators.line);
        // }
        this._nodes.axis[key].call(this._fn.var[key]);
      }

      axisBrushEnd(key) {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return; // ignore brush-by-zoom
        console.log('brushend', key, d3.event.selection);
        var s = (d3.event.selection || this._fn.var[key].range()).map(this._fn.var[key].invert, this._fn.var[key]);
        console.log(key, s);
        // this._fn.var[key].domain(s);
        // if (this.hasArea) {
        //   this._nodes.area.attr('d', this._generators.area);
        // }
        // if (this.hasLine) {
        //   this._nodes.line.attr('d', this._generators.line);
        // }
        this._nodes.axis[key].call(this._fn.var[key]);
      }

      axisDragged(position) {
        console.log('dragged', position, d3.event);
      }

      _axisPositionChanged(axisPosition) {
      }

      _addGraph(g) {
        if (this._graphElements.indexOf(g) === -1) {
          this._graphElements.push(g);
        }
      }

      _createScaleFn(type) {
        switch (type) {
          case 'time':
            return d3.scaleTime();
            break;
          case 'ln':
            return d3.scaleLog().base(Math.E);
            break;
          case 'log₁₀':
            return d3.scaleLog();
            break;
          case '√':
            return d3.scaleSqrt();
            break;
          default:
            return d3.scaleLinear();
        }
      }

      _createAxisFn(scale, orient, kind, ticks) {
        var axis;
        ticks = ticks || 5;
        switch (orient) {
          case 'top':
            axis = d3.axisTop();
            break;
          case 'bottom':
            axis = d3.axisBottom();
            break;
          case 'right':
            axis = d3.axisRight();
            break;
          default:
            axis = d3.axisLeft();
        }
        axis.scale(scale).ticks(ticks);
        if (kind === 'time')
          axis.ticks(ticks).tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat(d => {
            // TODO: different conception for log scales needed
            return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
          })

        return axis;
      }

      timeFormat(date) {
        return (d3.timeSecond(date) < date ? this.format.Millisecond :
          d3.timeMinute(date) < date ? this.format.Second :
          d3.timeHour(date) < date ? this.format.Minute :
          d3.timeDay(date) < date ? this.format.Hour :
          d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.format.Day : this.format.Week) :
          d3.timeYear(date) < date ? this.format.Month :
          this.format.Year)(date);
      }

      timeFormatRange(date, r, pixels) {
        var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.format.Millisecond :
          rangeRatio < 5E2 ? this.format.LongSecond :
          rangeRatio < 5E3 ? this.format.Second :
          rangeRatio < 2E4 ? this.format.LongMinute :
          rangeRatio < 6E4 ? this.format.Minute :
          rangeRatio < 36E5 ? this.format.Hour :
          rangeRatio < 864E5 ? this.format.Day :
          rangeRatio < 6048E5 ? this.format.Week :
          rangeRatio < 24192E5 ? this.format.Month :
          this.format.Year)(date);
      }

      redraw() {
        if (!this._isAttached) return;
        Promise.resolve(this.setDomains.call(this))
          .then(this._redraw.bind(this, false))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      _redraw(force) {
        if (!this._isAttached) return;

        if (force) {
          this.redraw();
          return;
        }
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (!(g && g._isAttached)) continue;
          g.redraw();
        }

        // this._chart.transition(50).select('#xGrid').call(this._xGrid);
        // this._chart.transition(50).select('#yGrid').call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
        this._updateInfo();
      }

      brushed() {
        // var s = d3.event.selection;
        // this._debouncedHideInfo();
        // if (s) {
        //   this._isBrushed = true;
        //   this._isZoomed = true;
        //   this._fn.var.x.domain([s[0][0], s[1][0]].map(this._fn.var.x.invert, this._fn.var.x)).nice(this.xTicks);
        //   this._fn.var.y.domain([s[1][1], s[0][1]].map(this._fn.var.y.invert, this._fn.var.y)).nice(this.yTicks);
        //   this._brush.call(this._brushBehavior.move, null);
        //   return;
        // } else if (this._isBrushed === true) {
        //   this._isBrushed = false;
        // } else {
        //   this._isZoomed = false;
        //   this.redraw();
        //   return;
        // }
        // this._redraw();
      }

      setDomains() {
        var mounts = Object.keys(this._graphs),
            p = [];

        return new Promise((resolve, reject) => {
          if (!Object.keys(this._graphs).length)
            reject('No Graphs are attached');
          // if (this._isZoomed === true || this._isBrushed === true) {
          //   resolve();
          // }

          for (var key in this.axes) {
            if (this.multiAxes[key] === true) {
              for (let i = 0; i < mounts.length; i++) {
                if (!this._graphs[mounts[i]]._isAttached || this._graphs[mounts[i]]._isBrushed === true) continue;
                p.push(this._graphs[mounts[i]]._getDomain(key).then( res => {
                  this._graphs[mounts[i]]._fn.var[key].domain(res);
                }));
              }
            } else {
              p.push(this.requestRange(key, mounts).then(res => {
                this._fn.var[key].domain(res);
                console.log(res)
              }));
            }
          }

          Promise.all(p)
            .then(resolve)
            .catch(reject);

          // this.requestRange('x')
          //   .then(rangeX => {
          //     var domainX = rangeX;
          //     this.requestRange('y')
          //       .then(rangeY => {
          //
          //         var domainY = rangeY;
          //
          //         // if min, max are equal, add a little space
          //         if (domainY[0] !== undefined && domainY[1] !== undefined && domainY[0] === domainY[1]) {
          //           domainY[0] -= 0.5;
          //           domainY[1] += 0.5;
          //         }
          //
          //         if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
          //           if (domainY[0] <= 0) {
          //             domainY[0] = Number.EPSILON;
          //           }
          //           if (domainY[1] <= 0) {
          //             domainY[1] = Number.EPSILON;
          //           }
          //         }
          //
          //         this._fn.var.x.domain(domainX);
          //         this.set('domainX', domainX);
          //         this._fn.var.y.domain(domainY).nice(this.yTicks);
          //
          //         // if domain is on the edge of data, add a little space
          //         domainY = this._fn.var.y.domain();
          //         if (domainY[0] === rangeY[0]) {
          //           domainY[0] -= (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         if (domainY[1] === rangeY[1]) {
          //           domainY[1] += (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         this._fn.var.y.domain(domainY);
          //         this.set('domainY', domainY);
          //         resolve();
          //
          //       })
          //       .catch(err => {
          //         reject(err);
          //       });
          //   })
          //   .catch(err => {
          //     reject(err);
          //   });
        });
      }

      insertValues(data) {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (!(g && g._isAttached)) continue;
          if (g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        }
      }

      clearValues() {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (!(g && g._isAttached)) continue;
          if (g.item && g.item.mount)
            g.clearValues();
        }
      }

      requestRange(key, mounts) {
        var p = [],
            g;

        return new Promise((resolve, reject) => {
          for (var i = 0; mounts && i < mounts.length; i++) {
            g = this._graphs[mounts[i]];
            if (!(g && g._isAttached)) continue;
            if (g.item && g.item.mount)
              p.push(g.requestRange(key));
          }
          Promise.all(p)
            .then( (res) => {
              var min, max;
              for (var i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i][0]) ? res[i][0] : min;
                max = (max === undefined || max < res[i][1]) ? res[i][1] : max;
              }
              if (min === undefined || max === undefined) {
                reject();
              }
              resolve([min, max]);
            })
            .catch(err => {});
        });
      }

      _moveInfo(d) {
        if (Number.isFinite(this._fn.var.y(d.y))) {
          var x = this.timeFormatRange.call(this, d.x, this._fn.var.x.domain(), this._width);
          var y = this.format.Number(d.y);
          this._info.text(x + ' ' + y);
          var fixP = this._fixedValue;
          if (fixP) {
            var diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            diffX = this.format.timeDiff.call(this, diffX);
            diffY = this.format.Number(diffY);
            this._infoDeltaX.text(diffX);
            this._infoDeltaY.text(diffY);
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        this.cancelDebouncer('hideinfo');
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _debouncedHideInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._activeHideInfoJob = setTimeout(() => {
          // this._hideInfo();
        }, 1000);
      }

      _hideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);
        // this._nodes.axis.select('.x.axis').call(this._xAxisFn);
        // this._nodes.axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        var focP = this._focusedValue;
        var x = this._fn.var.x(+focP.x),
          y = this._fn.var.y(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        switch (this.modus) {
          case 'delta':
            var fixP = this._fixedValue;
            if (fixP && fixP.x && focP.x !== fixP.x && fixP.y && focP.y !== fixP.y) {
              var xFix = this._fn.var.x(+fixP.x),
                yFix = this._fn.var.y(+fixP.y);
              var x1D, x2D, y1D, y2D;
              this._deltaX.attr('x1', x).attr('x2', xFix).attr('y1', yFix).attr('y2', yFix);
              this._deltaY.attr('y1', y).attr('y2', yFix);
              if (yFix < y || x < xFix) {
                this._deltaY.attr('x1', x).attr('x2', x);
                this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
              } else {
                this._deltaY.attr('x1', xFix).attr('x2', xFix);
                this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
              }
              this._deltaX
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
              this._deltaDot.attr('cy', yFix).attr('cx', xFix);
            } else {
              this._hideDelta();
            }
          case 'integral':
          default: // always performed
            this._focusX.attr('x1', focP._y_axis).attr('x2', x).attr('y2', y).attr('y1', y);
            this._focusY.attr('y1', focP._x_axis).attr('y2', y).attr('x2', x).attr('x1', x);
            this._focusDot.attr('cy', y).attr('cx', x);
        }

        // this._xAxisFn.tickValues([this._focusedValue.x]);
        // this._xAxisFn.tickFormat(null);
        // this._yAxisFn.tickValues([this._focusedValue.y]);
        // this._yAxisFn.tickFormat(null);
        // this._nodes.axis.select('.x.axis').call(this._xAxisFn);
        // this._nodes.axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        var bbox = node.getBBox(),
          height = this._height,
          width = this._width,
          textAnchor = textAnchor || 'middle',
          alignmentBaseline = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;

        switch (textAnchor) { // list is not complete!
          case 'middle':
            limitLeft += bbox.width / 2;
          case 'end ':
            limitLeft += bbox.width;
        }
        switch (alignmentBaseline) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
          case 'middle':
            limitBottom += bbox.height / 2;
          case 'hanging':
            limitBottom -= bbox.height;
        }

        if (y - limitBottom < 0) { // above top
          alignmentBaseline = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft > width) { // beyond right
          textAnchor = 'end';
        } else if (x - limitLeft < 0) { // beyond left
          textAnchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', textAnchor);
        node.setAttribute('alignment-baseline', alignmentBaseline);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
      }

      _dotClicked(d) {
        switch (this.modus) {
          case 'zoom':
            var offsetX = (this._fn.var.x(this._fn.var.x.domain()[1]) - this._fn.var.x(this._fn.var.x.domain()[0])) / 4,
              offsetY = (this._fn.var.y(this._fn.var.y.domain()[0]) - this._fn.var.y(this._fn.var.y.domain()[1])) / 4,
              x = this._fn.var.x(+d.x),
              y = this._fn.var.y(+d.y) || 0;
            d3.event.selection = [
              [x - offsetX, y - offsetY],
              [x + offsetX, y + offsetY]
            ];
            this.brushed();
            break;
          case 'delta':
            var fP = this._fixedValue;
            if (fP && fP.x && fP.y && fP.x === d.x && fP.y === d.y) {
              this._fixedValue = null;
              this._hideDelta();
              this._updateInfo();
              return;
            }
            this._fixedValue = d;
            this._deltaDot.datum(this._fixedValue)
              .attr('cx', d => {
                return this._fn.var.x(d.x)
              })
              .attr('cy', d => {
                return this._fn.var.y(d.y)
              })
              .attr('r', this._focusDot.attr('r'))
              .attr('fill', this._focusDot.attr('fill'));
            break;
          case 'integral':
            break;
        }
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation, oldValue) {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (!(g && g._isAttached)) continue;
          g.set('interpolation', interpolation);
        }
      }

      _scaleChanged(scale) {
        for (var key in scale) {
          // add scale function
          this._fn.var[key] = this._createScaleFn(scale[key]);
        }
      }
      //
      // changeScale(newValue, oldValue) {
      //   // if (oldValue === undefined) return;
      //   // var domainY = this._fn.var.y.domain();
      //   // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
      //   //   if (domainY[0] <= 0) {
      //   //     domainY[0] = Number.EPSILON;
      //   //   }
      //   //   if (domainY[1] <= 0) {
      //   //     domainY[1] = Number.EPSILON;
      //   //   }
      //   // }
      //   // this._debouncedHideInfo();
      //   // this._fn.var.y = this._createScaleFn(this.yScale);
      //   // this._fn.var.y.domain(domainY).nice(this.yTicks);
      //   // this.set('domainY', domainY);
      //   // this._sizeChanged();
      // }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this._hideInfo();
        this.redraw();
      }

      // _refresh() {
      //   this._buildLayout();
      //   var mounts = Object.keys(this._graphs), g;
      //   for (var i = 0; mounts && i < mounts.length; i++) {
      //     g = this._graphs[mounts[i]];
      //     if (!(g && g._isAttached)) continue;
      //     g.clearValues(true);
      //     g.requestValues(null, null, this.viewLength)
      //       .then(function(data) {
      //         for (var mount in data) {
      //           if (mount === this.item.mount) {
      //             this.insertValues(data[mount]);
      //             break;
      //           }
      //         }
      //       }.bind(g))
      //       .catch(err => {
      //         if (err) {
      //           console.log(err);
      //         }
      //       });
      //   }
      //   this._isZoomed = false;
      //   this.redraw();
      // }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
