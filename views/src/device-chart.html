<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="behaviors/scale-behavior.html">
<link rel="import" href="behaviors/fullscreen-behavior.html">

<link rel="import" href="components/icon-button.html">
<link rel="import" href="style/selectbox-style.html">
<link rel="import" href="style/button-style.html">

<link rel="import" href="device-graph.html">

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        box-sizing: border-box;
        position: relative;
        font-family: inherit;
        color: white;
        letter-spacing: normal !important;
        user-select: none !important;
        z-index: auto;
        transition: background 150ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100%;
        min-width: 100%;
        padding: 0 !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        isolation: isolate;
      }
      :host([fullscreen]) > #svgContainer {
        position: fixed;
        padding: 1em 1em 3em 1em !important;
      }
      #svg {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        width: 100%; height: 100%;
        overflow: visible;
        font-family: inherit !important;
      }
      text {
        fill: currentColor;
        stroke: white;
        stroke-width: 0.2;
        stroke-opacity: 0.1;
        font-size: 1em;
        letter-spacing: normal !important;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
      }
      /*g#brush .selection {
        stroke: currentColor;
        stroke-opacity: 0.7;
      }*/
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.15;
      }
      .grid {
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis {
        cursor: -webkit-grab;
        cursor: grab;
        font-family: inherit !important;
      }
      .axis.dragged {
        cursor: -webkit-grabbing;
        cursor: grabbing;
      }
      .axis path, .axis line {
        fill: currentColor;
        fill-opacity: 0.01;
        stroke: currentColor;
        stroke-opacity: 0.75;
        transition: fill-opacity 150ms linear;
      }
      .axis:hover path {
        fill-opacity: 0.3;
      }
      .axis.expanded path, .axis.expanded line {
        stroke-opacity: 0.9;
      }
      .axis.dragged path {
        fill-opacity: 0.2;
      }
      .axis.horizontal .tick > text {
        alignment-baseline: after-edge;
      }
      .axis.horizontal .tick:first-of-type:not(:only-of-type) > text {
        text-anchor: start;
      }
      .axis.horizontal .tick:nth-last-of-type(2):not(:only-of-type) > text {
        text-anchor: end;
      }
      .axis.vertical[position="left"]:not(.dragged) .tick > text {
        text-anchor: end;
      }
      .axis.vertical[position="right"]:not(.dragged) .tick > text {
        text-anchor: start;
      }
      .brush .selection {
        fill: currentColor;
        fill-opacity: 0.5;
        stroke: currentColor;
        stroke-width: 0;
      }
      .axis.vertical .brush .overlay {
        cursor: ns-resize;
      }
      .axis.horizontal .brush .overlay {
        cursor: ew-resize;
      }
      #graphs .area {
        fill-opacity: 0.3;
        mix-blend-mode: overlay;
        @apply --chart-area;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.7;
        @apply --chart-line;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *,
      #delta > * {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #focus .line {
        stroke-dasharray: 2;
        mix-blend-mode: darken;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
        mix-blend-mode: exclusion;
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      #control > * {
        background: rgba(255,255,255,0.0625);
      }
      .selectbox,
      .button {
        font-size: 0.8em;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
      }
      .button {
        padding: 0.3em;
      }
      #controlcontent {
        transform: translateY(-100%);
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        background-color: rgba(255, 255, 255, 0.25);
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer" on-contextmenu="_resetZoom">
      <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <marker id="arrowToLeft" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m 5.29167,-1.7197893 v 3.439581 L 0,2.6966667e-6 Z"/>
          </marker>
          <marker id="arrowToRight" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m -5.2916667,-1.7197893 v 3.439581 L 3.3333333e-6,2.6966667e-6 Z"/>
          </marker>
          <marker id="stub" markerWidth="5" markerHeight="5" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-1 -5 2 10">
            <path d="M0,0 m-1,-5 L1,-5 L1,5 L-1,5 z"/>
            <path d="M -2,0 M -5,-1 H 1 V 1 H -5 Z"/>
          </marker>
          <filter x="0" y="0" width="1" height="1" id="solid">
            <feFlood flood-color="white" id="flood"/>
            <feMerge>
              <feMergeNode in="flood" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <!-- <g id="xGrid" class="grid" clip-path="url(#clip)"></g> -->
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="area"></g>
            <g id="line"></g>
            <g id="boundery"></g>
            <g id="brush"></g>
          </g>
          <g id="delta" hidden>
            <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <circle id="deltaDot" class="dot"></circle>
          </g>
          <g id="focus" hidden>
            <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <circle id="focusDot" class="dot"></circle>
          </g>
          <g id="axis" on-tap="_resetZoom"></g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </svg>
  	</div>
    <section id="control">
      <iron-collapse id="controlcontent" opened="[[showControl]]">
        <div class="selectbox">
          <select value="{{interpolation::change}}">
            <option value="Lineare Verbindung">Lineare Verbindung</option>
            <option value="Basis Spline">Basis Spline</option>
            <option value="Kubischer Spline">Kubischer Spline</option>
            <option value="Cardinaler Spline">Cardinaler Spline</option>
            <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
            <option value="Stufe (mitte)">Stufe (mitte)</option>
            <option value="Stufe (davor)">Stufe (davor)</option>
            <option value="Stufe (danach)">Stufe (danach)</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{yScale::change}}">
            <option value="linear">linear</option>
            <option value="√">√</option>
            <option value="ln">ln</option>
            <option value="log₁₀">log₁₀</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{modus::change}}">
            <option value="zoom">zoom</option>
            <option value="delta">delta</option>
          </select>
        </div>
      </iron-collapse>
      <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
      <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></icon-button>
    </section>

    <dom-if if="[[multi]]" restamp>
      <template>
        <dom-repeat items="[[items]]">
          <template>
            <device-graph item="[[item]]" interpolation="[[interpolation]]" no-link="[[noLink]]" multi-axes=[[multiAxes]] range=[[range]]></device-graph>
          </template>
        </dom-repeat>
      </template>
    </dom-if>
    <dom-if if="[[!multi]]" restamp>
      <template>
        <device-graph item="[[item]]" interpolation="[[interpolation]]" no-link="[[noLink]]" multi-axes=[[multiAxes]] range=[[range]]></device-graph>
      </template>
    </dom-if>
  </template>
  <script>
    class DeviceChart extends Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], WebvisualBehaviors.ScaleBehavior(WebvisualBehaviors.FullscreenBehavior(Polymer.Element))) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {

          margin: {
            type: Object,
            value: function() {
              return {
                top: 6,
                right: 6,
                bottom: 6,
                left: 6
              }
            }
          },

          gridMult: {
            type: Number,
            value: 2
          },

          multiAxes: {
            type: Object,
            value: function() {
              return {
                x: false,
                y: true
              };
            },
            observer: '_multiAxesChanged'
          },

          tickSize: {
            type: Number,
            value: 8
          },

          axisMargin: {
            type: Number,
            value: 6
          },

          axisSize: {
            type: Object,
            value: function() {
              return {
                x: 20,
                y: 54
              };
            }
          },

          axisPosition: {
            type: Object,
            value: function() {
              return {
                x: 'bottom',
                y: 'left'
              }
            },
            observer: '_axisPositionChanged'
          },

          domain: {
            type: Object,
            value: function() {
              return {
                x: [null, null],
                y: [null, null]
              };
            }
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          noLink: {
            type: Boolean
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._yGrid = {};
        this._brush = {};
        this._chart = {};
        this._control = {};
        this._svg = {};
        this._info = {};
        this._focus = {};
        this._focusX = {};
        this._focusY = {};
        this._focusDot = {};
        this._infoDeltaX = {};
        this._infoDeltaY = {};
        this._delta = {};
        this._deltaX = {};
        this._deltaY = {};
        this._deltaDot = {};
        this._focusedValue = null;
        this._fixedValue = null;
        this._axes = new Set();
        this._nodes = {
          axis: {},
          brush: {},
          axes: {}
        };
        this._fn = {
          axis: {
            x: Function.prototype,
            y: Function.prototype
          },
          brush: {
            x: Function.prototype,
            y: Function.prototype
          }
        };
        this._generators = {
          brush: {},
          axis: {}
        }
        // this._xAxisFn = {};
        // this._yAxisFn = {};
        this._isAttached = false;
        this._isBrushed = false;
        this._isZoomed = false;
        this._brushBehavior = Function.prototype;
        this._graphs = new Set();
        this._ticks = {};
        var localeDateFormat = {
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        }
        var localeNumberFormat = {
          'decimal': ',',
          'thousands': '.',
          'grouping': [3],
          'currency': ['', '\u00a0€']
        };
        d3.timeFormatDefaultLocale(localeDateFormat);
        d3.formatDefaultLocale(localeNumberFormat);
        this.format = {
          Millisecond: d3.timeFormat(':%S,%L'),
          LongSecond: d3.timeFormat(':%M:%S,%L'),
          Second: d3.timeFormat(':%M:%S'),
          LongMinute: d3.timeFormat('%H:%M:%S'),
          Minute: d3.timeFormat('%H:%M'),
          Hour: d3.timeFormat('%X'),
          Day: d3.timeFormat('%d.%m'),
          Week: d3.timeFormat('%d.%m'),
          Month: d3.timeFormat('%d. %b'),
          Year: d3.timeFormat('%Y'),
          timeDiff: function(date) {
            // one year = 365.25 days = 315576E5ms (Julian Calendar)
            var ry = date % 315576E5,
              y = (date - ry) / 315576E5,
              rd = ry % 864E5,
              d = (ry - rd) / 864E5,
              rh = rd % 36E5,
              h = (rd - rh) / 36E5,
              rm = rh % 6E4,
              m = (rh - rm) / 6E4,
              rs = rm % 1E3,
              s = (rm - rs) / 1E3,
              ret = '';
            if (y)
              ret += y + 'y ';
            if (d)
              ret += d + 'd ';
            if (h)
              ret += h + 'h ';
            if (m)
              ret += m + 'm ';
            if (s)
              ret += s + 's ';
            if (rs)
              ret += rs + 'ms';
            return ret;
          },
          Number: d3.format(',')
        }
      }

      get _self() {
        return this;
      }

      _fireResize() {
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: false,
          composed: true,
          node: this
        }));
        this._sizeChanged();
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _sizeChanged() {
        // only resize if initialized
        if (this._isAttached) {
          console.log('_sizeChanged called')
          if (this._activeSizeJob) {
            cancelAnimationFrame(this._activeSizeJob);
          }
          this._activeSizeJob = requestAnimationFrame(() => {
            this._sizeLayout();
          });
        }
      }

      _buildLayout() {
        console.log('_buildLayout');
        this._svg = d3.select(this.$.svg)
          .attr('height', null)
          .attr('width', null);
        // this.scale.x = this._createScaleFn(this.scale.x);
        // this.scale.y = this._createScaleFn(this.scale.y);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._nodes.axis = d3.select(this.$.axis);
        this._nodes.area = d3.select(this.$.area);
        this._nodes.line = d3.select(this.$.line);
        this._nodes.boundery = d3.select(this.$.boundery);

        // Test
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('x axis', true);
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        // this._nodes.axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        //

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            this.cancelDebouncer('hideinfo');
          }, {
            passive: true
          })
          .on('mouseleave', this._debouncedHideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        // this._brushBehavior = d3.brush()
        //   // .on('end', this.brushed.bind(this._self()));
        //   .on('end', this.brushed.bind(this));
        // this._brush = d3.select(this.$.brush);
        // this._brush
        //   .on('mouseenter touchstart', this._showInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mouseleave touchend', this._debouncedHideInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mousemove', () => {
        //     var m = d3.mouse(this._chart.node());
        //     requestAnimationFrame( () => {
        //       var closestGraph, closestPoint, closestDistance;
        //       var mounts = Object.keys(this._graphs), g;
        //       for (var i = 0; mounts && i < mounts.length; i++) {
        //         g = this._graphs[mounts[i]]
        //         if (g.values && g.values.length) {
        //           var d = g._closestPoint(m);
        //           var currentMin2 = Math.pow(m[0] - g.scale.x(d.x), 2) + Math.pow(m[1] - g.scale.y(d.y), 2); // in px²
        //           if (closestDistance === undefined || currentMin2 < closestDistance) {
        //             closestDistance = currentMin2;
        //             closestPoint = d;
        //             closestGraph = g;
        //           }
        //         }
        //       }
        //       if (closestPoint) {
        //         var fill = closestGraph.getComputedStyleValue('--device-color') || '#000';
        //         if (closestGraph.item.threshold) {
        //           switch (closestPoint.state) {
        //             case 1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
        //               break;
        //             case -1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
        //               break;
        //           }
        //         }
        //         this._focusedValue = closestPoint;
        //         this._focusedValue.g = closestGraph;
        //         this._focusedValue._y_axis = this.multiAxes.y ? (closestGraph._y_left + closestGraph._y_right) : 0;
        //         this._focusedValue._x_axis = this.multiAxes.x ? (closestGraph._x_bottom + closestGraph._x_top) : this._height;
        //         this._focusDot.datum(closestPoint)
        //           .attr('fill', fill)
        //           .attr('r', closestGraph.dotRadius);
        //         this._showInfo();
        //         this._moveInfo(closestPoint);
        //       } else {
        //         this._debouncedHideInfo();
        //       }
        //     });
        //   }, {
        //     passive: true
        //   })
        //   .on('touchmove', this._resetZoom.bind(this), {
        //     passive: true
        //   });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._multiAxesChanged(this.multiAxes);
        this._sizeChanged();
      }

      _sizeLayout() {
        if (!this._isAttached) return;

        var bRect = this.$.svg.getBoundingClientRect();
        console.log('sizeLayout', bRect.height, bRect.width);

        if (bRect.height === 0 || bRect.width === 0) {
          this._activeSizeJob = requestAnimationFrame(() => {
            this._sizeLayout();
          });
          return;
        }

        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }

        var top = 0,
          right = 0,
          bottom = 0,
          left = 0,
          axisSize = this.axisSize,
          tickSize = this.tickSize,
          axisMargin = this.axisMargin,
          expandedSize = axisSize - axisMargin,
          condensedSize = tickSize + axisMargin;

        var q = [];

        function incremPosition(size) {
          var pos = this._position;
          if (pos === 'left') {
            this._left = left;
            this._right = 0;
            left -= size;
          } else if (pos === 'right') {
            this._left = 0;
            this._right = right;
            right += size;
          } else {
            this._left = 0;
            this._right = 0;
          }
          if (pos === 'top') {
            this._bottom = 0;
            this._top = top;
            top -= size;
          } else if (pos === 'bottom') {
            this._bottom = bottom;
            this._top = 0;
            bottom += size;
          } else {
            this._bottom = 0;
            this._top = 0;
          }
          console.log(this._position, this._mount, this._top, this._bottom, this._right, this._left)
          return true;
        }

        function finalizePosition(width, height) {
          var pos = this._position;
          this._left += this._right;
          this._top += this._bottom;
          if (pos === 'right') {
            this._left += width;
          } else if (pos === 'bottom') {
            this._top += height;
          }
          this._bottom = this._right = 0;
          console.log(this._position, this._mount, this._top, this._bottom, this._right, this._left)
          return true;
        }

        for (var key in this.multiAxes) {
          this._graphs.forEach( g => {
            if (g._nodes.axis[key]) {
              var size = g._nodes.axis[key].classed('expanded') ? axisSize[key] : condensedSize;
              q.push(incremPosition.call(g._nodes.axis[key].node(), size));
            }
          })
          if (this._nodes.axis[key] && !this._nodes.axis[key].attr('hidden')) {
            var size = this._nodes.axis[key].classed('expanded') ? axisSize[key] : condensedSize;
            q.push(incremPosition.call(this._nodes.axis[key].node(), size));
          }
        }

        // this.xTicks = Math.ceil(this._width / 75);
        // this.yTicks = Math.ceil(this._height / 50);

        Promise.all(q).then(() => {
          var bRect = this.$.svg.getBoundingClientRect();
          this._width = bRect.width - Math.abs(left || 0) - Math.abs(right || 0) - (this.margin.left || 0) - (this.margin.right || 0);
          this._height = bRect.height - Math.abs(bottom || 0) - Math.abs(top || 0) - (this.margin.bottom || 0) - (this.margin.top || 0);

          this.set('range', {x: [0, this._width], y: [this._height, 0]});

          var p = [];
          for (var key in this.multiAxes) {
            if (this.multiAxes[key] === true) {
              this._graphs.forEach( g => {
                if (g._nodes.axis[key]) {
                  p.push(finalizePosition.call(g._nodes.axis[key].node(), this._width, this._height));
                }
              })
            }
            if (this._nodes.axis[key] && !this._nodes.axis[key].attr('hidden')) {
              p.push(finalizePosition.call(this._nodes.axis[key].node(), this._width, this._height));
            }
          }

          Promise.all(p).then(() => {
            top -= (this.margin.top || 0);
            right += (this.margin.right || 0);
            bottom += (this.margin.bottom || 0);
            left -= (this.margin.left || 0);

            this._control.transition(100).style('transform', 'translate(-' + right + 'px,-' + bottom + 'px)');

            // Limiting Projection to Margin
            this._chart.select('clipPath#clip rect').transition(100)
              .attr('width', this._width)
              .attr('height', this._height);

            this._chart.select('rect#plot').transition(100)
              .attr('width', this._width)
              .attr('height', this._height);

            this._chart.transition(100).attr('transform', 'translate(' + (-left || 0) + ',' + (-top || 0) + ')');

            for (var key in this.multiAxes) {
              this._graphs.forEach( g => {
                this._updateAxis(g, key);
              })
              this._updateAxis(this, key);
            }

            this._focusY.attr('y1', this._height);

            this._svg.selectAll('g,line,text,path,rect')
              .classed('style-scope device-chart', true)

            this._redraw();
          })
        })

        // this._xGrid = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._height)
        //   .tickFormat('');
        // this._yGrid = this._createAxisFn(this._y, 'left', this.yScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._width)
        //   .tickFormat('');

        // this._chart.select('#xGrid')
        //   .attr('transform', 'translate(0,' + this._height + ')')
        //   .call(this._xGrid);
        // this._chart.select('#yGrid')
        //   .call(this._yGrid)
        //   .attr('transform', 'translate(0,' + 0 + ')');;

        // if (this._isBrushed !== true || this._isZoomed !== true) {
        //   this._brushBehavior.extent([
        //     [0, 0],
        //     [this._width, this._height]
        //   ])
        //   this._brush.call(this._brushBehavior);
        // }
      }

      _multiAxesChanged(multiAxes) {
        if (!this._isAttached) return;

        for (var key in multiAxes) {
          this._graphs.forEach( g => {
            if (this.multiAxes[key] === true) {
              this._addAxis(g, key, g.item.mount);
              this._updateAxis(g, key);
            } else {
              this._removeAxis(g, key);
            }
          })
          if (!this._nodes.axis[key]) {
            this._addAxis(this, key, null, true);
          }
          if (this.multiAxes[key] === true) {
            // hide main axis
            this._nodes.axis[key].attr('hidden', true);
          } else {
            this._nodes.axis[key].attr('hidden', null);
            this._updateAxis(this, key);
          }
        }
      }

      _addAxis(g, key, mount, expanded) {
        if (g._nodes.axis[key]) return;
        this._nodes.axes[key] = this._nodes.axes[key] || d3.select(this.$.axis).append('svg:g').classed(key, true);
        var self = this, vertical = false, pos = g.axisPosition[key];
        // enter axes node
        g._nodes.axis[key] = this._nodes.axes[key]
          .append('svg:g')
          .classed('axis', true)
          .classed(key, true)
          .classed('expanded', expanded)
          .attr('mount', mount)
          .on('click', function() {
            var a = d3.select(this),
              exp = a.classed('expanded');
            a.classed('expanded', !exp);
            this._expanded = exp;
            self._sizeChanged();
          })
          .call(d3.drag()
            .on("start", this._axisDragStarted)
            .on("drag", this._axisDragged)
            .on("end", this._axisDragEnded));

        // add title
        g._nodes.axis[key].append('svg:title').text(mount);
        // set scale
        // this.scale[key] = this._createScaleFn(this.scale[key]).domain(this.domain[key]);
        g._generators.axis[key] = this._createAxisFn(this.scale[key], pos, this.keys[key].scale);
        switch (pos) {
          case 'left':
          case 'right':
            this.scale[key].range([this._height, 0]);
            g._generators.brush[key] = d3.brushY();
            vertical = true;
            break;
          case 'bottom':
          case 'top':
            this.scale[key].range([0, this._width]);
            g._generators.brush[key] = d3.brushX();
            break;
        }
        // enter brush node
        g._nodes.brush[key] = g._nodes.axis[key].append('svg:g').classed('brush', true);
        g._nodes.axis[key].classed('vertical', vertical).classed('horizontal', !vertical);
        g._nodes.axis[key].node()._vertical = vertical;
        g._nodes.axis[key].node()._position = pos;
        g._nodes.axis[key].node()._caller = g;
        console.log('_addAxis', key, mount, pos)
      }

      _updateAxis(g, key) {
        g = g || this;
        if (!g._nodes.axis[key] || g._nodes.axis[key].attr('hidden')) return;
        var expanded = g._nodes.axis[key].classed('expanded'),
          tickSize = this.tickSize,
          pos = g._nodes.axis[key].node()._position;
        // update axis
        if (pos === 'left' || pos === 'right') {
          this._updateScale.call(g);
          if (pos === 'left') {
            g._generators.brush[key].extent([
              [-tickSize, 0], [0, this._height]
            ]);
          } else if (pos === 'right') {
            g._generators.brush[key].extent([
              [0, 0], [tickSize, this._height]
            ]);
          }
        } else if (pos === 'bottom' || pos === 'top') {
          this._updateScale.call(g);
          if (pos === 'top') {
            g._generators.brush[key].extent([
              [0, -tickSize], [this._width, 0]
            ]);
          } else if (pos === 'bottom') {
            g._generators.brush[key].extent([
              [0, 0], [this._width, tickSize]
            ]);
          }
        }
        g._generators.axis[key] = this._createAxisFn(g.scale[key], pos, g.keys[key].scale).tickFormat(expanded ? null : '').tickSize(tickSize);
        g._nodes.brush[key].raise().call(g._generators.brush[key]);
        g._nodes.axis[key].call(g._generators.axis[key]).transition(100)
          .attr('transform', 'translate(' + (g._nodes.axis[key].node()._left || 0) + ',' + (g._nodes.axis[key].node()._top || 0) + ')');
        g._nodes.axis[key].node()._width = this._width;
        g._nodes.axis[key].node()._height = this._height;
      }

      _removeAxis(g, key) {
        g = g || this;
        if (!g._nodes.axis[key]) return;
        console.log('_removeAxis', key)
        var node;
        g._generators.brush[key] = null;
        g._generators.axis[key] = null;
        g.scale[key] = this.scale[key];
        // remove axis & brush node
        if (g._nodes.brush[key]) {
          node = g._nodes.brush[key].node();
          if (node && node.parentElement)
            node.parentElement.removeChild(node);
        }
        if (g._nodes.axis[key]) {
          node = g._nodes.axis[key].node();
          if (node && node.parentElement)
            node.parentElement.removeChild(node);
        }
        g._nodes.axis[key] = null;
        g._nodes.brush[key] = null;
      }

      _updateScales(keys) {
        this._updateScale();
        this._graphs.forEach( g => {
          // if (g._nodes.axis[key]) {
            g._updateScale();
          // }
        })
      }

      _callAxes() {
        var keys = Object.keys(this.multiAxes);
        keys.forEach(key => {
          this._graphs.forEach( g => {
            if (g._nodes.axis[key] && g._generators.axis[key]) {
              g._nodes.brush[key].raise().call(g._generators.brush[key]);
              g._nodes.axis[key].call(g._generators.axis[key]).transition(100)
                .attr('transform', 'translate(' + (g._nodes.axis[key].node()._left || 0) + ',' + (g._nodes.axis[key].node()._top || 0) + ')');
            }
          })
          if (this._nodes.axis[key] && this._generators.axis[key]) {
            this._nodes.brush[key].raise().call(this._generators.brush[key]);
            this._nodes.axis[key].call(this._generators.axis[key]).transition(100)
              .attr('transform', 'translate(' + (this._nodes.axis[key].node()._left || 0) + ',' + (this._nodes.axis[key].node()._top || 0) + ')');
          }
        })
      }

      axisBrushMove(key) {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return; // ignore brush-by-zoom
        console.log('brushmove', key, d3.event.selection);
        var s = (d3.event.selection || this.scale[key].range()).map(this.scale[key].invert, this.scale[key]);
        console.log(key, s);
        // this.scale[key].domain(s);
        // if (this.hasArea) {
        //   this._nodes.area.attr('d', this._generators.area);
        // }
        // if (this.hasLine) {
        //   this._nodes.line.attr('d', this._generators.line);
        // }
        this._nodes.axis[key].call(this.scale[key]);
      }

      axisBrushEnd(key) {
        // if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return; // ignore brush-by-zoom
        console.log('brushend', key, d3.event.selection);
        var s = (d3.event.selection || this.scale[key].range()).map(this.scale[key].invert, this.scale[key]);
        console.log(key, s);
        // this.scale[key].domain(s);
        // if (this.hasArea) {
        //   this._nodes.area.attr('d', this._generators.area);
        // }
        // if (this.hasLine) {
        //   this._nodes.line.attr('d', this._generators.line);
        // }
        this._nodes.axis[key].call(this.scale[key]);
      }

      _axisDragStarted(e) {
        d3.select(this).raise().classed("dragged", true);
        console.log('dragged', e, d3.event, this._left, this._top);
      }
      _axisDragged(e) {
        var vertical = d3.select(this).classed('vertical'), left = 0, top = 0;
        if (vertical) {
          left = d3.event.x;
        } else {
          top = d3.event.y;
        }
        d3.select(this).attr('transform', 'translate(' + left + ',' + top + ')');

        // d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
      }
      _axisDragEnded(e) {
        d3.select(this).classed("dragged", false);
        var vertical = d3.select(this).classed('vertical'), left = 0, top = 0;
        if (vertical) {
          left = d3.event.x;
          if (this._width) {
            this._position = (left > this._width / 2) ? 'right' : 'left';
          }
        } else {
          top = d3.event.y;
          if (this._height) {
            this._position = (top > this._height / 2) ? 'bottom' : 'top';
          }
        }
        d3.select(this).attr('transform', 'translate(' + left + ',' + top + ')');
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: true,
          composed: true,
          node: this
        }));
        console.log('dragged', this, d3.event);
      }

      _axisPositionChanged(axisPosition) {}

      _addGraph(g) {
        this._graphs.add(g);
      }
      _removeGraph(g) {
        this._graphs.delete(g);
      }

      _createAxisFn(scalefn, pos, scale, ticks) {
        console.log('_createAxisFn', pos, scale, ticks)
        var axis;
        ticks = ticks || 5;
        switch (pos) {
          case 'top':
            axis = d3.axisTop();
            break;
          case 'bottom':
            axis = d3.axisBottom();
            break;
          case 'right':
            axis = d3.axisRight();
            break;
          default:
            axis = d3.axisLeft();
        }
        axis.scale(scalefn).ticks(ticks);
        if (scale === 'time')
          axis.ticks(ticks).tickFormat(this.timeFormat.bind(this));
        else if (scalefn.base && scalefn.base() === Math.E)
          axis.tickFormat(d => {
            // TODO: different conception for log scales needed
            return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
          })

        return axis;
      }

      timeFormat(date) {
        return (d3.timeSecond(date) < date ? this.format.Millisecond :
          d3.timeMinute(date) < date ? this.format.Second :
          d3.timeHour(date) < date ? this.format.Minute :
          d3.timeDay(date) < date ? this.format.Hour :
          d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.format.Day : this.format.Week) :
          d3.timeYear(date) < date ? this.format.Month :
          this.format.Year)(date);
      }

      timeFormatRange(date, r, pixels) {
        var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.format.Millisecond :
          rangeRatio < 5E2 ? this.format.LongSecond :
          rangeRatio < 5E3 ? this.format.Second :
          rangeRatio < 2E4 ? this.format.LongMinute :
          rangeRatio < 6E4 ? this.format.Minute :
          rangeRatio < 36E5 ? this.format.Hour :
          rangeRatio < 864E5 ? this.format.Day :
          rangeRatio < 6048E5 ? this.format.Week :
          rangeRatio < 24192E5 ? this.format.Month :
          this.format.Year)(date);
      }

      redraw() {
        if (!this._isAttached) return;

        Promise.resolve(this._getDomains.call(this))
          .then(this._redraw.bind(this, false))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      _redraw(force) {
        if (!this._isAttached) return;

        if (force) {
          this.redraw();
          return;
        }

        this._updateScales();
        this._callAxes();

        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.redraw();
        })

        // this._chart.transition(50).select('#xGrid').call(this._xGrid);
        // this._chart.transition(50).select('#yGrid').call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
        this._updateInfo();
      }

      brushed() {
        // var s = d3.event.selection;
        // this._debouncedHideInfo();
        // if (s) {
        //   this._isBrushed = true;
        //   this._isZoomed = true;
        //   this.scale.x.domain([s[0][0], s[1][0]].map(this.scale.x.invert, this.scale.x)).nice(this.xTicks);
        //   this.scale.y.domain([s[1][1], s[0][1]].map(this.scale.y.invert, this.scale.y)).nice(this.yTicks);
        //   this._brush.call(this._brushBehavior.move, null);
        //   return;
        // } else if (this._isBrushed === true) {
        //   this._isBrushed = false;
        // } else {
        //   this._isZoomed = false;
        //   this.redraw();
        //   return;
        // }
        // this._redraw();
      }

      _getDomains() {
        var p = [];

        return new Promise((resolve, reject) => {

          for (var key in this.multiAxes) {
            if (this.multiAxes[key] === true) {
              this._graphs.forEach( g => {
                if (g._isAttached & !g._isBrushed) {
                  p.push( g._getDomain(key) )
                }
              })
            } else {
              p.push(
                this.requestRange(key)
                      .then(res => {
                        this.set('domain.' + res.key, res.domain);
                      }) )
            }
          }

          Promise.all(p)
            .then(resolve)
            .catch(reject);

          // this.requestRange('x')
          //   .then(rangeX => {
          //     var domainX = rangeX;
          //     this.requestRange('y')
          //       .then(rangeY => {
          //
          //         var domainY = rangeY;
          //
          //         // if min, max are equal, add a little space
          //         if (domainY[0] !== undefined && domainY[1] !== undefined && domainY[0] === domainY[1]) {
          //           domainY[0] -= 0.5;
          //           domainY[1] += 0.5;
          //         }
          //
          //         if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
          //           if (domainY[0] <= 0) {
          //             domainY[0] = Number.EPSILON;
          //           }
          //           if (domainY[1] <= 0) {
          //             domainY[1] = Number.EPSILON;
          //           }
          //         }
          //
          //         this.scale.x.domain(domainX);
          //         this.set('domainX', domainX);
          //         this.scale.y.domain(domainY).nice(this.yTicks);
          //
          //         // if domain is on the edge of data, add a little space
          //         domainY = this.scale.y.domain();
          //         if (domainY[0] === rangeY[0]) {
          //           domainY[0] -= (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         if (domainY[1] === rangeY[1]) {
          //           domainY[1] += (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         this.scale.y.domain(domainY);
          //         this.set('domainY', domainY);
          //         resolve();
          //
          //       })
          //       .catch(err => {
          //         reject(err);
          //       });
          //   })
          //   .catch(err => {
          //     reject(err);
          //   });
        });
      }

      insertValues(data) {
        this._graphs.forEach( g => {
          if (g && g._isAttached && g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        })
      }

      clearValues() {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.clearValues();
        })
      }

      requestRange(key) {
        return new Promise((resolve, reject) => {
          var p = [];
          this._graphs.forEach( g => {
            if (g && g._isAttached && g.item && g.item.mount)
              p.push(g._getDomain(key));
          })
          Promise.all(p)
            .then(res => {
              var min, max, key;
              for (var i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
                key = key || res[i].key;
              }
              if (min === undefined || max === undefined) {
                reject();
              }
              resolve({domain: [min, max], key: key});
            })
            .catch(err => {});
        });
      }

      _moveInfo(d) {
        if (Number.isFinite(this.scale.y(d.y))) {
          var x = this.timeFormatRange.call(this, d.x, this.scale.x.domain(), this._width);
          var y = this.format.Number(d.y);
          this._info.text(x + ' ' + y);
          var fixP = this._fixedValue;
          if (fixP) {
            var diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            diffX = this.format.timeDiff.call(this, diffX);
            diffY = this.format.Number(diffY);
            this._infoDeltaX.text(diffX);
            this._infoDeltaY.text(diffY);
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        this.cancelDebouncer('hideinfo');
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _debouncedHideInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._activeHideInfoJob = setTimeout(() => {
          // this._hideInfo();
        }, 1000);
      }

      _hideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);
        // this._nodes.axis.select('.x.axis').call(this._xAxisFn);
        // this._nodes.axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        var focP = this._focusedValue;
        var x = this.scale.x(+focP.x),
          y = this.scale.y(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        switch (this.modus) {
          case 'delta':
            var fixP = this._fixedValue;
            if (fixP && fixP.x && focP.x !== fixP.x && fixP.y && focP.y !== fixP.y) {
              var xFix = this.scale.x(+fixP.x),
                yFix = this.scale.y(+fixP.y);
              var x1D, x2D, y1D, y2D;
              this._deltaX.attr('x1', x).attr('x2', xFix).attr('y1', yFix).attr('y2', yFix);
              this._deltaY.attr('y1', y).attr('y2', yFix);
              if (yFix < y || x < xFix) {
                this._deltaY.attr('x1', x).attr('x2', x);
                this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
              } else {
                this._deltaY.attr('x1', xFix).attr('x2', xFix);
                this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
              }
              this._deltaX
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
              this._deltaDot.attr('cy', yFix).attr('cx', xFix);
            } else {
              this._hideDelta();
            }
          case 'integral':
          default: // always performed
            this._focusX.attr('x1', focP._y_axis).attr('x2', x).attr('y2', y).attr('y1', y);
            this._focusY.attr('y1', focP._x_axis).attr('y2', y).attr('x2', x).attr('x1', x);
            this._focusDot.attr('cy', y).attr('cx', x);
        }

        // this._xAxisFn.tickValues([this._focusedValue.x]);
        // this._xAxisFn.tickFormat(null);
        // this._yAxisFn.tickValues([this._focusedValue.y]);
        // this._yAxisFn.tickFormat(null);
        // this._nodes.axis.select('.x.axis').call(this._xAxisFn);
        // this._nodes.axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        var bbox = node.getBBox(),
          height = this._height,
          width = this._width,
          textAnchor = textAnchor || 'middle',
          alignmentBaseline = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;

        switch (textAnchor) { // list is not complete!
          case 'middle':
            limitLeft += bbox.width / 2;
          case 'end ':
            limitLeft += bbox.width;
        }
        switch (alignmentBaseline) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
          case 'middle':
            limitBottom += bbox.height / 2;
          case 'hanging':
            limitBottom -= bbox.height;
        }

        if (y - limitBottom < 0) { // above top
          alignmentBaseline = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft > width) { // beyond right
          textAnchor = 'end';
        } else if (x - limitLeft < 0) { // beyond left
          textAnchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', textAnchor);
        node.setAttribute('alignment-baseline', alignmentBaseline);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
      }

      _dotClicked(d) {
        switch (this.modus) {
          case 'zoom':
            var offsetX = (this.scale.x(this.scale.x.domain()[1]) - this.scale.x(this.scale.x.domain()[0])) / 4,
              offsetY = (this.scale.y(this.scale.y.domain()[0]) - this.scale.y(this.scale.y.domain()[1])) / 4,
              x = this.scale.x(+d.x),
              y = this.scale.y(+d.y) || 0;
            d3.event.selection = [
              [x - offsetX, y - offsetY],
              [x + offsetX, y + offsetY]
            ];
            this.brushed();
            break;
          case 'delta':
            var fP = this._fixedValue;
            if (fP && fP.x && fP.y && fP.x === d.x && fP.y === d.y) {
              this._fixedValue = null;
              this._hideDelta();
              this._updateInfo();
              return;
            }
            this._fixedValue = d;
            this._deltaDot.datum(this._fixedValue)
              .attr('cx', d => {
                return this.scale.x(d.x)
              })
              .attr('cy', d => {
                return this.scale.y(d.y)
              })
              .attr('r', this._focusDot.attr('r'))
              .attr('fill', this._focusDot.attr('fill'));
            break;
          case 'integral':
            break;
        }
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation, oldValue) {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.set('interpolation', interpolation);
        })
      }

      //
      // changeScale(newValue, oldValue) {
      //   // if (oldValue === undefined) return;
      //   // var domainY = this.scale.y.domain();
      //   // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
      //   //   if (domainY[0] <= 0) {
      //   //     domainY[0] = Number.EPSILON;
      //   //   }
      //   //   if (domainY[1] <= 0) {
      //   //     domainY[1] = Number.EPSILON;
      //   //   }
      //   // }
      //   // this._debouncedHideInfo();
      //   // this.scale.y = this._createScaleFn(this.yScale);
      //   // this.scale.y.domain(domainY).nice(this.yTicks);
      //   // this.set('domainY', domainY);
      //   // this._sizeChanged();
      // }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this._hideInfo();
        this.redraw();
      }

      // _refresh() {
      //   this._buildLayout();
      //   this._graphs.forEach( g => {
      //     if (g && g._isAttached) {
      //       g.clearValues(true);
      //       g.requestValues(null, null, this.viewLength)
      //         .then(function(data) {
      //           for (var mount in data) {
      //             if (mount === this.item.mount) {
      //               this.insertValues(data[mount]);
      //               break;
      //             }
      //           }
      //         }.bind(g))
      //         .catch(err => {
      //           if (err) console.log(err);
      //         });
      //     }
      //   })
      //   this._isZoomed = false;
      //   this.redraw();
      // }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
