<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="mixins/axes-mixin.html">
<link rel="import" href="mixins/fullscreen-mixin.html">

<link rel="import" href="components/icon-button.html">
<link rel="import" href="style/selectbox-style.html">
<link rel="import" href="style/button-style.html">

<link rel="import" href="device-graph.html">

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        box-sizing: border-box;
        position: relative;
        font-family: inherit;
        color: white;
        letter-spacing: normal !important;
        user-select: none !important;
        z-index: auto;
        transition: background 150ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100vh;
        min-width: 100vw;
        padding: 1.25em !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        isolation: isolate;
      }
      #svg {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        width: 100%; height: 100%;
        overflow: opened;
        font-family: inherit !important;
      }
      text {
        fill: currentColor;
        stroke: white;
        stroke-width: 0.1;
        stroke-opacity: 0.2;
        font-size: 1em;
        letter-spacing: -0.0125em;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
      }
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.15;
      }
      .grid {
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis {
        cursor: -webkit-grab;
        cursor: grab;
        pointer-events: all;
        font-family: inherit !important;
      }
      .axis.dragged {
        cursor: -webkit-grabbing;
        cursor: grabbing;
      }
      .axis path, .axis line {
        fill: currentColor;
        fill-opacity: 0.01;
        stroke: currentColor;
        stroke-opacity: 0.75;
        transition: fill-opacity 150ms linear;
      }
      .axis:hover path {
        fill-opacity: 0.3;
      }
      .axis.expanded path, .axis.expanded line {
        stroke-opacity: 0.9;
      }
      .axis.dragged path {
        fill-opacity: 0.2;
      }
      .brush .selection {
        fill: currentColor;
        fill-opacity: 0.5;
        stroke: currentColor;
        stroke-width: 0;
      }
      .axis.vertical .brush .overlay {
        cursor: ns-resize;
      }
      .axis:not(.vertical) .brush .overlay {
        cursor: ew-resize;
      }
      #graphs .area {
        fill-opacity: 0.3;
        transition: fill-opacity 200ms linear;
        @apply --chart-area;
      }
      #graphs .area:last-of-type {
        fill-opacity: 0.4;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.9;
        @apply --chart-line;
      }
      #graphs .line:last-of-type {
        stroke-opacity: 1;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *,
      #delta > * {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #focus .line {
        stroke-dasharray: 2;
        mix-blend-mode: darken;
      }
      .zoom {
        cursor: default;
        fill: none;
        stroke: none;
        pointer-events: all;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
        mix-blend-mode: exclusion;
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      #control > * {
        background: rgba(255,255,255,0.0625);
      }
      .selectbox,
      .button {
        font-size: 0.8em;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
      }
      .button {
        padding: 0.3em;
      }
      #controlcontent {
        transform: translateY(-100%);
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        background-color: rgba(255, 255, 255, 0.25);
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer" on-contextmenu="_resetZoom">
      <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <marker id="arrowToLeft" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m 5.29167,-1.7197893 v 3.439581 L 0,2.6966667e-6 Z"/>
          </marker>
          <marker id="arrowToRight" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m -5.2916667,-1.7197893 v 3.439581 L 3.3333333e-6,2.6966667e-6 Z"/>
          </marker>
          <marker id="stub" markerWidth="5" markerHeight="5" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-1 -5 2 10">
            <path d="M0,0 m-1,-5 L1,-5 L1,5 L-1,5 z"/>
            <path d="M -2,0 M -5,-1 H 1 V 1 H -5 Z"/>
          </marker>
          <filter x="0" y="0" width="1" height="1" id="solid">
            <feFlood flood-color="white" id="flood"/>
            <feMerge>
              <feMergeNode in="flood" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <!-- <g id="xGrid" class="grid" clip-path="url(#clip)"></g> -->
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="area"></g>
            <g id="line"></g>
            <g id="boundery"></g>
          </g>
          <g id="zoom"  clip-path="url(#clip)"></g>
          <g id="delta" hidden>
            <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <circle id="deltaDot" class="dot"></circle>
          </g>
          <g id="focus" hidden>
            <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <circle id="focusDot" class="dot"></circle>
          </g>
          <g id="axis" on-tap="_resetZoom"></g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </svg>
      <section id="control">
        <iron-collapse id="controlcontent" opened="[[showControl]]">
          <div class="selectbox">
            <select value="{{interpolation::change}}">
              <option value="Lineare Verbindung">Lineare Verbindung</option>
              <option value="Basis Spline">Basis Spline</option>
              <option value="Kubischer Spline">Kubischer Spline</option>
              <option value="Cardinaler Spline">Cardinaler Spline</option>
              <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
              <option value="Stufe (mitte)">Stufe (mitte)</option>
              <option value="Stufe (davor)">Stufe (davor)</option>
              <option value="Stufe (danach)">Stufe (danach)</option>
            </select>
          </div>
          <div class="selectbox">
            <select value="{{yScale::change}}">
              <option value="linear">linear</option>
              <option value="√">√</option>
              <option value="ln">ln</option>
              <option value="log₁₀">log₁₀</option>
            </select>
          </div>
          <div class="selectbox">
            <select value="{{modus::change}}">
              <option value="zoom">zoom</option>
              <option value="delta">delta</option>
            </select>
          </div>
        </iron-collapse>
        <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
        <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></icon-button>
      </section>
  	</div>

    <template is="dom-if" if="[[multi]]" restamp>
      <template is="dom-repeat" items="[[items]]">
        <device-graph item="[[item]]" interpolation="[[interpolation]]" locale-date="[[localeDate]]" locale-number=[[localeNumber]] range-x=[[rangeX]] range-y=[[rangeY]] no-link="[[!opened]]"></device-graph>
      </template>
    </template>
    <template is="dom-if" if="[[!multi]]" restamp>
      <device-graph item="[[item]]" interpolation="[[interpolation]]" locale-date="[[localeDate]]" locale-number=[[localeNumber]] range-x=[[rangeX]]  range-y=[[rangeY]] no-link="[[!opened]]"></device-graph>
    </template>
  </template>
  <script>
    class DeviceChart extends Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], WebvisualMixins.AxesMixin(WebvisualMixins.FullscreenMixin(WebvisualMixins.LocalizeMixin(Polymer.Element)))) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {

          opened: {
            type: Boolean
          },

          margin: {
            type: Object,
            value: function() {
              return {
                top: 6,
                right: 6,
                bottom: 6,
                left: 6
              }
            }
          },

          gridMult: {
            type: Number,
            value: 2
          },

          multiAxesX: {
            type: Boolean,
            value: false
          },

          multiAxesY: {
            type: Boolean,
            value: true
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          noLink: {
            type: Boolean
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          },

          /**
           * folder for date/time-format file
           */
          languageResourcePrefix: {
            type: String,
            value: '/locales/format/'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._graphs = new Set();
      }

      get _self() {
        return this;
      }

      static get observers() {
        return [
          "_localizeChanged(localize)"
        ]
      }

      _localizeChanged(localize) {
        this.set('localeDate', localize('date'));
        this.set('localeNumber', localize('number'));
      }

      _fireResize() {
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: false,
          composed: true,
          node: this
        }));
        this.sizeChanged();
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _buildLayout() {
        // console.log('_buildLayout');
        this._svg = d3.select(this.$.svg)
          .attr('height', null)
          .attr('width', null);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._axisInsertionPoint = d3.select(this.$.axis);
        this._area = d3.select(this.$.area);
        this._line = d3.select(this.$.line);
        this._boundery = d3.select(this.$.boundery);

        this.axisX = this._computeAxisNode(this._axisInsertionPoint, this.axisOrientX)
                           .attr('hidden', (this.multiAxesX) ? true: null)
                           .classed('expanded', true)
                           .classed('x', true);
        this.axisY = this._computeAxisNode(this._axisInsertionPoint, this.axisOrientY)
                           .attr('hidden', (this.multiAxesY) ? true: null)
                           .classed('expanded', true)
                           .classed('vertical', true)
                           .classed('y', true);
        this.axisGeneratorX = this._computeAxisGenerator(this.axisOrientX, this.scaleX, this.scalingX, this.scaleBaseX);
        this.axisGeneratorY = this._computeAxisGenerator(this.axisOrientY, this.scaleY, this.scalingY, this.scaleBaseY);

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            this.cancelDebouncer('hideinfo');
          }, {
            passive: true
          })
          .on('mouseleave', this._debouncedHideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        this._zoomBehavior = d3.zoom()
              .scaleExtent([1, Infinity])
              .on("zoom", this._onZoomed.bind(this));

        this._zoom = d3.select(this.$.zoom)
                      .append('svg:rect')
                      .classed('zoom', true)
                      .call(this._zoomBehavior);
        // this._brushMixin = d3.brush()
        //   // .on('end', this.brushed.bind(this._self()));
        //   .on('end', this.brushed.bind(this));
        // this._brush = d3.select(this.$.brush);
        // this._brush
        //   .on('mouseenter touchstart', this._showInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mouseleave touchend', this._debouncedHideInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mousemove', () => {
        //     var m = d3.mouse(this._chart.node());
        //     requestAnimationFrame( () => {
        //       var closestGraph, closestPoint, closestDistance;
        //       var mounts = Object.keys(this._graphs), g;
        //       for (var i = 0; mounts && i < mounts.length; i++) {
        //         g = this._graphs[mounts[i]]
        //         if (g.values && g.values.length) {
        //           var d = g._closestPoint(m);
        //           var currentMin2 = Math.pow(m[0] - g.scaleX(d.x), 2) + Math.pow(m[1] - g.scaleY(d.y), 2); // in px²
        //           if (closestDistance === undefined || currentMin2 < closestDistance) {
        //             closestDistance = currentMin2;
        //             closestPoint = d;
        //             closestGraph = g;
        //           }
        //         }
        //       }
        //       if (closestPoint) {
        //         var fill = closestGraph.getComputedStyleValue('--device-color') || '#000';
        //         if (closestGraph.item.threshold) {
        //           switch (closestPoint.state) {
        //             case 1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
        //               break;
        //             case -1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
        //               break;
        //           }
        //         }
        //         this._focusedValue = closestPoint;
        //         this._focusedValue.g = closestGraph;
        //         this._focusedValue._y_axis = this.multiAxesY ? (closestGraph._y_left + closestGraph._y_right) : 0;
        //         this._focusedValue._x_axis = this.multiAxesX ? (closestGraph._x_bottom + closestGraph._x_top) : this._height;
        //         this._focusDot.datum(closestPoint)
        //           .attr('fill', fill)
        //           .attr('r', closestGraph.dotRadius);
        //         this._showInfo();
        //         this._moveInfo(closestPoint);
        //       } else {
        //         this._debouncedHideInfo();
        //       }
        //     });
        //   }, {
        //     passive: true
        //   })
        //   .on('touchmove', this._resetZoom.bind(this), {
        //     passive: true
        //   });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._multiAxesChanged(this.multiAxesX, this.multiAxesY);
        this.sizeChanged();
      }

      reset() {
        this.opened = false;
        this.set('item', {});
        this.set('items', []);
        this.set('exceeding', []);
      }

      sizeChanged() {
        // only resize if initialized
        if (!(this.opened && this._isAttached)) return;
        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }
        this._activeSizeJob = requestAnimationFrame(() => {
          this.sizeLayout();
        }, 0);
      }

      sizeLayout() {
        if (!(this.opened && this._isAttached)) return;
        var bRect = this.$.svg.getBoundingClientRect();

        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }

        if (bRect.height === 0 || bRect.width === 0) {
          requestAnimationFrame(() => {
            this.sizeChanged();
          });
          return;
        }

        console.log('sizeLayout');
        var top = -2,
          right = 1,
          bottom = 1,
          left = -2,
          axisSizeX = this.axisSizeX,
          axisSizeY = this.axisSizeY,
          tickSize = this.tickSize,
          axisMargin = this.axisMargin,
          condensedSize = tickSize + axisMargin;

        var q = [];

        function incremPosition(pos, size) {
          if (pos === 'left') {
            this._left = left;
            this._right = 0;
            left -= size;
          } else if (pos === 'right') {
            this._left = 0;
            this._right = right;
            right += size;
          } else {
            this._left = 0;
            this._right = 0;
          }
          if (pos === 'top') {
            this._bottom = 0;
            this._top = top;
            top -= size;
          } else if (pos === 'bottom') {
            this._bottom = bottom;
            this._top = 0;
            bottom += size;
          } else {
            this._bottom = 0;
            this._top = 0;
          }
          return true;
        }

        function finalizePosition(pos, width, height) {
          this._left += this._right;
          this._top += this._bottom;
          this._bottom = 0; this._right = 0;
          if (pos === 'right') {
            this._left += width;
          } else if (pos === 'bottom') {
            this._top += height;
          }
          return true;
        }

        this._graphs.forEach( g => {
          if (g._isAttached) {
            if (!g.axisX.attr('hidden')) {
              var size = g.axisX.classed('expanded') ? axisSizeX : condensedSize;
              q.push(incremPosition.call(g.axisX, g.axisOrientX, size));
            }
            if (!g.axisY.attr('hidden')) {
              var size = g.axisY.classed('expanded') ? axisSizeY : condensedSize;
              q.push(incremPosition.call(g.axisY, g.axisOrientY, size));
            }
          }
        })
        if (!this.axisX.attr('hidden')) {
          var size = this.axisX.classed('expanded') ? axisSizeX : condensedSize;
          q.push(incremPosition.call(this.axisX, this.axisOrientX, size));
        }
        if (!this.axisY.attr('hidden')) {
          var size = this.axisY.classed('expanded') ? axisSizeY : condensedSize;
          q.push(incremPosition.call(this.axisY, this.axisOrientX, size));
        }

        Promise.all(q).then(() => {
          var bRect = this.$.svg.getBoundingClientRect();
          this._width = Math.abs(bRect.width - Math.abs(left || 0) - Math.abs(right || 0) - (this.margin.left || 0) - (this.margin.right || 0));
          this._height = Math.abs(bRect.height - Math.abs(bottom || 0) - Math.abs(top || 0) - (this.margin.bottom || 0) - (this.margin.top || 0));

          this.set('rangeX', [0, this._width]);
          this.set('rangeY', [this._height,0]);
          this.ticksX = Math.ceil(this._width / 75);
          this.ticksY = Math.ceil(this._height / 50);

          this._zoom.attr('height', this._height).attr('width', this._width);
          this._zoomBehavior.extent([[0, 0], [this._width, this._height]]);
          this._zoom.call(this._zoomBehavior.transform, d3.zoomIdentity);

          var p = [];

          this._graphs.forEach( g => {
            if (g._isAttached) {
              if (!g.axisX.attr('hidden')) {
                p.push(finalizePosition.call(g.axisX, g.axisOrientX, this._width, this._height));
              }
              if (!g.axisY.attr('hidden')) {
                p.push(finalizePosition.call(g.axisY, g.axisOrientY, this._width, this._height));
              }
            }
          })
          if (!this.axisX.attr('hidden')) {
            p.push(finalizePosition.call(this.axisX, this.axisOrientX, this._width, this._height));
          }
          if (!this.axisY.attr('hidden')) {
            p.push(finalizePosition.call(this.axisY, this.axisOrientY, this._width, this._height));
          }

          Promise.all(p).then(() => {
            top -= (this.margin.top || 0);
            right += (this.margin.right || 0);
            bottom += (this.margin.bottom || 0);
            left -= (this.margin.left || 0);
            this._chart._top = top;
            this._chart._right = right;
            this._chart._bottom = bottom;
            this._chart._left = left;

            if (!this.domainX || !this.domainY || this.domainX.some(e => { return e === undefined || e === null; }) || this.domainY.some(e => { return e === undefined || e === null; })) {
              this.redraw(true);
            } else {
              this.redraw();
            }
          })
        })
      }

      _domainXChanged(domainX) {
        if (domainX === undefined || this.scaleX === undefined || domainX.some(e => { return e === undefined || e === null; })) return;
        console.log('domainchanged')
        this.scaleX.domain(domainX);
        if (!this.multiAxesX) {
          var te = this._zoomBehavior.translateExtent();
          this._zoomBehavior.translateExtent([[this.scaleX(this.domainX[0]), te[0][1]], [this.scaleX(this.domainX[1]), te[1][1]]]);
        }
      }

      _domainYChanged(domainY) {
        if (domainY === undefined || this.scaleY === undefined || domainY.some(e => { return e === undefined || e === null; })) return;
        this.scaleY.domain(domainY).nice();
        if (!this.multiAxesY) {
          var te = this._zoomBehavior.translateExtent();
          this._zoomBehavior.translateExtent([[te[0][0], this.scaleY(this.domainY[0])], [te[1][0], this.scaleY(this.domainY[1])]]);
        }
      }

      _multiAxesChanged(multiAxesX, multiAxesY) {
        if (!this._isAttached) return;
        var hidden;
        this._graphs.forEach( g => {
          if (g._isAttached) {
            hidden = (multiAxesX && g.axisX) ? null : true;
            g.axisX.attr('hidden', hidden);
            if (hidden) {
              g.set('domainX', this.domainX);
            }
            hidden = (multiAxesY && g.axisY) ? null : true;
            g.axisY.attr('hidden', hidden);
            if (hidden) {
              g.set('domainY', this.domainY);
            }
          }
        })
        hidden = (multiAxesX && this.axisX) ? true : null;
        this.axisX.attr('hidden', hidden);
        hidden = (multiAxesY && this.axisY) ? true : null;
        this.axisY.attr('hidden', hidden);

        if (!multiAxesX && this.scaleX && this.domainX) {
          var te = this._zoomBehavior.translateExtent();
          this._zoomBehavior.translateExtent([[this.scaleX(this.domainX[0]), te[0][1]], [this.scaleX(this.domainX[1]), te[1][1]]]);
        }

        if (!multiAxesY && this.scaleY && this.domainY) {
          var te = this._zoomBehavior.translateExtent();
          this._zoomBehavior.translateExtent([[te[0][0], this.scaleY(this.domainY[0])], [te[1][0], this.scaleY(this.domainY[1])]]);
        }
      }

      _addGraph(g) {
        this._graphs.add(g);
      }
      _removeGraph(g) {
        this._graphs.delete(g);
        if (this._graphs.size === 0) {
          this.set('domainX', [null,null])
          this.set('domainY', [null,null])
        }
      }

      _redomain(keys) {
        if (!this._isAttached) return;
        if (this._activeRedrawJob) {
          clearTimeout(this._activeRedrawJob);
        }
        console.log('_redomain')
        Promise.resolve(this._getDomain.call(this))
          .then(this.redraw.bind(this, false))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      redraw(force) {
        if (!this._isAttached) return;

        if (force) {
          console.log('force')
          this._redomain();
          return;
        }
        console.log('chart redraw')
        // async redrawing
        if (this._activeRedrawJob) {
          clearTimeout(this._activeRedrawJob);
        }
        this._activeRedrawJob = setTimeout(() => {
          this._graphs.forEach( g => {
            if (g._isAttached) {
              if (!g.axisX.attr('hidden')) {
                g._updateAxisBrushGenerator.call(g.axisBrushGeneratorX, this.rangeX, g.axisOrientX);
                g.axisX.select('.brush').raise().call(g.axisBrushGeneratorX);
                g.axisX.attr('transform', 'translate(' + (g.axisX._left || 0) + ',' + (g.axisX._top || 0) + ')');
              } else {
                g.set('domainX', this.domainX);
              }
              if (!g.axisY.attr('hidden')) {
                g._updateAxisBrushGenerator.call(g.axisBrushGeneratorY, this.rangeY, g.axisOrientY);
                g.axisY.select('.brush').raise().call(g.axisBrushGeneratorY);
                g.axisY.attr('transform', 'translate(' + (g.axisY._left || 0) + ',' + (g.axisY._top || 0) + ')');
              } else {
                g.set('domainY', this.domainY);
              }
              g.redraw();
            }
          })

          if (!this.axisX.attr('hidden')) {

            this._updateAxisBrushGenerator.call(this.axisBrushGeneratorX, this.rangeX, this.axisOrientX);
            this.axisX.select('.brush').raise().call(this.axisBrushGeneratorX);
            this.axisX.transition(100).call(this.axisGeneratorX.tickSize(this.tickSize).tickFormat(this.axisX.classed('expanded') ? this._computeFormatFn(this.scalingX, this.scaleBaseX) : ''))
                .transition(100)
                .attr('transform', 'translate(' + (this.axisX._left || 0) + ',' + (this.axisX._top || 0) + ')');
          }
          if (!this.axisY.attr('hidden')) {
            // this.axisGeneratorY = this._computeAxisGenerator(this.axisOrientY, this.scaleY, this.scalingY, this.scaleBaseY);
            this._updateAxisBrushGenerator.call(this.axisBrushGeneratorY, this.rangeY, this.axisOrientY);
            this.axisY.select('.brush').raise().call(this.axisBrushGeneratorY);
            this.axisY.transition(100).call(this.axisGeneratorY.tickSize(this.tickSize).tickFormat(this.axisY.classed('expanded') ? this._computeFormatFn(this.scalingY, this.scaleBaseY) : ''))
                .transition(100)
                .attr('transform', 'translate(' + (this.axisY._left || 0) + ',' + (this.axisY._top || 0) + ')');
          }

          this._control.transition(100).style('transform', 'translate(-' + this._chart._right + 'px,-' + this._chart._bottom + 'px)');

          // Limiting Projection to Margin
          this._chart.select('clipPath#clip rect').transition(100)
            .attr('width', this._width)
            .attr('height', this._height);

          this._chart.select('rect#plot').transition(100)
            .attr('width', this._width)
            .attr('height', this._height);

          this._chart.transition(100).attr('transform', 'translate(' + (-this._chart._left || 0) + ',' + (-this._chart._top || 0) + ')');

          this._focusY.attr('y1', this._height);

          this._svg.selectAll('g,line,text,path,rect')
            .classed('style-scope device-chart', true)
            .classed('device-chart', true);

          this._updateInfo();
        }, 0);
      }

      _getDomain() {
        console.log('_getDomain');
        return new Promise((resolve, reject) => {
          var p = [], q = [];
          this._graphs.forEach( g => {
            p.push( g._getDomain('x', this.multiAxesX) )
            q.push( g._getDomain('y', this.multiAxesX) )
          })
          Promise.all(p)
            .then(res => {
              var min, max, domain;
              for (var i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
              }
              if (min === undefined || max === undefined) {
                resolve();
              }
              domain = [min, max];
              this.set('domainX', domain);
              this.scaleX.domain(domain);
              if (this.multiAxesX === false) {
                this._graphs.forEach( g => {
                  g.axisX._isBrushed = false;
                  g.set('domainX', domain);
                  g.scaleX.domain(domain);
                })
              }
              Promise.all(q)
                .then(res => {
                  var min, max, domain;
                  for (var i = 0; i < res.length; i++) {
                    min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                    max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
                  }
                  if (min === undefined || max === undefined) {
                    resolve();
                  }
                  domain = [min, max];
                  this.set('domainY', domain);
                  if (this.multiAxesY === false) {
                    this._graphs.forEach( g => {
                      g.axisY._isBrushed = false;
                      g.set('domainY', domain);
                    })
                  }
                  resolve();
                })
                .catch(error => {
                  reject(error);
                })
              })
              .catch(error => {
                reject(error);
              });
        });
      }

      insertValues(data) {
        this._graphs.forEach( g => {
          if (g && g._isAttached && g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        })
      }

      clearValues() {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.clearValues();
        })
      }

      _moveInfo(d) {
        if (Number.isFinite(this.scaleY(d.y))) {
          var x = this.timeFormatRange.call(this, d.x, this.scaleX.domain(), this._width);
          var y = this.numberFormat.call(this, d.y);
          this._info.text(x + ' ' + y);
          var fixP = this._fixedValue;
          if (fixP) {
            var diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            diffX = this.timeFormat.call(this, diffX);
            diffY = this.numberFormat.call(this, diffY);
            this._infoDeltaX.text(diffX);
            this._infoDeltaY.text(diffY);
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        this.cancelDebouncer('hideinfo');
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _debouncedHideInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._activeHideInfoJob = setTimeout(() => {
          // this._hideInfo();
        }, 1000);
      }

      _hideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);
        // this._axis.select('.x.axis').call(this._xAxisFn);
        // this._axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        var focP = this._focusedValue;
        var x = this.scaleX(+focP.x),
          y = this.scaleY(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        switch (this.modus) {
          case 'delta':
            var fixP = this._fixedValue;
            if (fixP && fixP.x && focP.x !== fixP.x && fixP.y && focP.y !== fixP.y) {
              var xFix = this.scaleX(+fixP.x),
                yFix = this.scaleY(+fixP.y);
              var x1D, x2D, y1D, y2D;
              this._deltaX.attr('x1', x).attr('x2', xFix).attr('y1', yFix).attr('y2', yFix);
              this._deltaY.attr('y1', y).attr('y2', yFix);
              if (yFix < y || x < xFix) {
                this._deltaY.attr('x1', x).attr('x2', x);
                this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
              } else {
                this._deltaY.attr('x1', xFix).attr('x2', xFix);
                this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
              }
              this._deltaX
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
              this._deltaDot.attr('cy', yFix).attr('cx', xFix);
            } else {
              this._hideDelta();
            }
          case 'integral':
          default: // always performed
            this._focusX.attr('x1', focP._y_axis).attr('x2', x).attr('y2', y).attr('y1', y);
            this._focusY.attr('y1', focP._x_axis).attr('y2', y).attr('x2', x).attr('x1', x);
            this._focusDot.attr('cy', y).attr('cx', x);
        }

        // this._xAxisFn.tickValues([this._focusedValue.x]);
        // this._xAxisFn.tickSize(this.tickSize).tickFormat(null);
        // this._yAxisFn.tickValues([this._focusedValue.y]);
        // this._yAxisFn.tickSize(this.tickSize).tickFormat(null);
        // this._axis.select('.x.axis').call(this._xAxisFn);
        // this._axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        var bbox = node.getBBox(),
          height = this._height,
          width = this._width,
          textAnchor = textAnchor || 'middle',
          alignmentBaseline = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;

        switch (textAnchor) { // list is not complete!
          case 'middle':
            limitLeft += bbox.width / 2;
          case 'end ':
            limitLeft += bbox.width;
        }
        switch (alignmentBaseline) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
          case 'middle':
            limitBottom += bbox.height / 2;
          case 'hanging':
            limitBottom -= bbox.height;
        }

        if (y - limitBottom < 0) { // above top
          alignmentBaseline = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft > width) { // beyond right
          textAnchor = 'end';
        } else if (x - limitLeft < 0) { // beyond left
          textAnchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', textAnchor);
        node.setAttribute('alignment-baseline', alignmentBaseline);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
      }

      _dotClicked(d) {
        switch (this.modus) {
          case 'zoom':
            var offsetX = (this.scaleX(this.scaleX.domain()[1]) - this.scaleX(this.scaleX.domain()[0])) / 4,
              offsetY = (this.scaleY(this.scaleY.domain()[0]) - this.scaleY(this.scaleY.domain()[1])) / 4,
              x = this.scaleX(+d.x),
              y = this.scaleY(+d.y) || 0;
            d3.event.selection = [
              [x - offsetX, y - offsetY],
              [x + offsetX, y + offsetY]
            ];
            this.brushed();
            break;
          case 'delta':
            var fP = this._fixedValue;
            if (fP && fP.x && fP.y && fP.x === d.x && fP.y === d.y) {
              this._fixedValue = null;
              this._hideDelta();
              this._updateInfo();
              return;
            }
            this._fixedValue = d;
            this._deltaDot.datum(this._fixedValue)
              .attr('cx', d => {
                return this.scaleX(d.x)
              })
              .attr('cy', d => {
                return this.scaleY(d.y)
              })
              .attr('r', this._focusDot.attr('r'))
              .attr('fill', this._focusDot.attr('fill'));
            break;
          case 'integral':
            break;
        }
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation, oldValue) {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.set('interpolation', interpolation);
        })
      }
      _onAxisBrushEnd(key) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection;
        if (!s) {
          return;
        }
        // super._onAxisBrushEnd(key);
        if (!this.multiAxesX) {
          var domain = s.map(this.scaleX.invert, this.scaleX).sort((a, b) => { return a > b});
          this._graphs.forEach(g => {
            g.scaleX.domain(domain);
            g.axisGeneratorX.scale(g.scaleX);
            g.redraw();
          })
          this.axisX._isBrushed = true;
          this.axisX.call(this.axisGeneratorX.scale().domain(domain));
          this.axisX.select(".brush").call(this.axisBrushGeneratorX.move, null);
        }
        if (!this.multiAxesY) {
          var domain = s.map(this.scaleY.invert, this.scaleY).sort((a, b) => { return a > b});
          this._graphs.forEach(g => {
            g.scaleY.domain(domain);
            g.axisGeneratorY.scale(g.scaleY);
            g.redraw();
          })
          this.axisY._isBrushed = true;
          this.axisY.call(this.axisGeneratorY.scale().domain(domain));
          this.axisY.select(".brush").call(this.axisBrushGeneratorY.move, null);
        }
        this._zoom.call(this._zoomBehavior.transform, d3.zoomIdentity
          .scale(this._width / (s[1] - s[0]))
          .translate(-s[0], 0));
        // this.redraw();
      }
      _onZoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
        var t = d3.event.transform;

        if (!this.multiAxesX) {
          var x = d3.event.transform.rescaleX(this.scaleX);
          this._graphs.forEach(g => {
            g.scaleX.domain(x.domain());
            g.axisGeneratorX.scale(g.scaleX);
            console.log(g.scaleX.domain(), g.scaleY.domain())
            g.redraw();
          })
          this.axisX.call(this.axisGeneratorX.scale(x));
          this._isZoomed = !(t.k === 1 && t.x === 0 && t.y === 0);
          console.log('zoomed x', this._isZoomed)
        }
        if (!this.multiAxesY) {
          var y = d3.event.transform.rescaleY(this.scaleY);
          this._graphs.forEach(g => {
            g.scaleY.domain(y.domain());
            g.axisGeneratorY.scale(g.scaleY);
            g.redraw();
          })
          this.axisY.call(this.axisGeneratorY.scale(y));
          this._isZoomed = !(t.k === 1 && t.x === 0 && t.y === 0);
          console.log('zoomed', this._isZoomed)
        }
        // this.redraw();
      }
      //
      // changeScale(newValue, oldValue) {
      //   // if (oldValue === undefined) return;
      //   // var domainY = this.scaleY.domain();
      //   // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
      //   //   if (domainY[0] <= 0) {
      //   //     domainY[0] = Number.EPSILON;
      //   //   }
      //   //   if (domainY[1] <= 0) {
      //   //     domainY[1] = Number.EPSILON;
      //   //   }
      //   // }
      //   // this._debouncedHideInfo();
      //   // this.scaleY = this._createScaleFn(this.yScale);
      //   // this.scaleY.domain(domainY).nice(this.yTicks);
      //   // this.set('domainY', domainY);
      //   // this.sizeChanged();
      // }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this.axisX._isBrushed = false;
        this.axisY._isBrushed = false;
        this._zoom.call(this._zoomBehavior.transform, d3.zoomIdentity.scale(1));
        this._graphs.forEach(g => {
          g.axisX._isBrushed = false;
          g.axisY._isBrushed = false;
        })
        this._hideInfo();
        this._redomain();
      }

      // _refresh() {
      //   this._buildLayout();
      //   this._graphs.forEach( g => {
      //     if (g && g._isAttached) {
      //       g.clearValues(true);
      //       g.requestValues(null, null, this.viewLength)
      //         .then(function(data) {
      //           for (var mount in data) {
      //             if (mount === this.item.mount) {
      //               this.insertValues(data[mount]);
      //               break;
      //             }
      //           }
      //         }.bind(g))
      //         .catch(err => {
      //           if (err) console.log(err);
      //         });
      //     }
      //   })
      //   this._isZoomed = false;
      //   this._redomain();
      // }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
