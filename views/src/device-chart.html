<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="behaviors/fullscreen-behavior.html" />

<link rel="import" href="components/icon-button.html" />
<link rel="import" href="style/selectbox-style.html" />
<link rel="import" href="style/button-style.html" />

<link rel="import" href="device-graph.html" />

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        box-sizing: border-box;
        position: relative;
        font-family: inherit;
        color: white;
        letter-spacing: normal !important;
        user-select: none !important;
        z-index: auto;
        transition: background 250ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100%;
        min-width: 100%;
        padding: 0 !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        isolation: isolate;
      }
      :host([fullscreen]) > #svgContainer {
        position: fixed;
        padding: 1em 1em 3em 1em !important;
      }
      #svgChart {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        width: 100%; height: 100%;
        overflow: visible;
        font-family: inherit;
      }
      text {
        fill: currentColor;
        font-size: 10px;
        letter-spacing: normal !important;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
      }
      g#chart .axis {
        font-size: inherit;
      }
      g#brush .selection {
        stroke: currentColor;
        stroke-opacity: 0.7;
      }
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.15;
      }
      .grid {
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis path, .axis line {
        stroke: currentColor;
        stroke-opacity: 0.15;
        stroke-width: 1.5px;
      }
      .axis.expanded path {
        fill-opacity: 0.75;
        stroke-opacity: 0.6;
      }
      .axis {
        font-family: inherit;
      }
      .axis.button {
        pointer-events: all;
        cursor: pointer;
      }
      .x.axis > .tick:first-of-type:not(:only-of-type) > text {
        text-anchor: start;
      }
      .x.axis > .tick:last-of-type:not(:only-of-type) > text {
        text-anchor: end;
      }
      .y.axis > .tick:first-of-type:not(:only-of-type) > text {
        alignment-baseline: after-edge;
      }
      .y.axis > .tick:last-of-type:not(:only-of-type) > text {
        alignment-baseline: before-edge;
      }
      #graphs .area {
        fill-opacity: 0.3;
        mix-blend-mode: overlay;
        @apply --chart-area;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.7;
        @apply --chart-line;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *,
      #delta > * {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #focus .line {
        stroke-dasharray: 2;
        mix-blend-mode: darken;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      #control > * {
        background: rgba(255,255,255,0.0625);
      }
      .selectbox,
      .button {
        font-size: 12px;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
        color: var(--primary-text-color);
      }
      .button {
        padding: 0.3em;
      }
      #controlcontent {
        transform: translateY(-100%);
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        background-color: rgba(255, 255, 255, 0.25);
      }
      icon-button {
        mix-blend-mode: overlay;
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer" on-contextmenu="_resetZoom">
      <svg id="svgChart" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <marker id="arrowToLeft" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m 5.29167,-1.7197893 v 3.439581 L 0,2.6966667e-6 Z"/>
          </marker>
          <marker id="arrowToRight" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m -5.2916667,-1.7197893 v 3.439581 L 3.3333333e-6,2.6966667e-6 Z"/>
          </marker>
          <marker id="stub" markerWidth="5" markerHeight="5" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-1 -5 2 10">
            <path d="M0,0 m-1,-5 L1,-5 L1,5 L-1,5 z"/>
          </marker>
          <filter x="0" y="0" width="1" height="1" id="solid">
            <feFlood flood-color="white" id="flood"/>
            <feMerge>
              <feMergeNode in="flood" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <!-- <g id="xGrid" class="grid" clip-path="url(#clip)"></g> -->
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="areas"></g>
            <g id="lines"></g>
            <g id="bounderies"></g>
            <g id="brush"></g>
          </g>
          <g id="delta" clip-path="url(#clip)" hidden>
            <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <circle id="deltaDot" class="dot"></circle>
          </g>
          <g id="focus" clip-path="url(#clip)" hidden>
            <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <circle id="focusDot" class="dot"></circle>
          </g>
          <g id="xAxes" on-tap="_resetZoom"></g>
          <g id="yAxes" on-tap="_resetZoom"></g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </svg>
  	</div>
    <section id="control">
      <iron-collapse id="controlcontent" opened="[[showControl]]">
        <div class="selectbox">
          <select value="{{interpolation::change}}">
            <option value="Lineare Verbindung">Lineare Verbindung</option>
            <option value="Basis Spline">Basis Spline</option>
            <option value="Kubischer Spline">Kubischer Spline</option>
            <option value="Cardinaler Spline">Cardinaler Spline</option>
            <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
            <option value="Stufe (mitte)">Stufe (mitte)</option>
            <option value="Stufe (davor)">Stufe (davor)</option>
            <option value="Stufe (danach)">Stufe (danach)</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{yScale::change}}">
            <option value="linear">linear</option>
            <option value="√">√</option>
            <option value="ln">ln</option>
            <option value="log₁₀">log₁₀</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{modus::change}}">
            <option value="zoom">zoom</option>
            <option value="delta">delta</option>
            <!-- <option value="integral">integral</option> -->
          </select>
        </div>
      </iron-collapse>
      <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
      <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></icon-button>
    </section>

    <template is="dom-if" if="[[multi]]" restamp>
      <template is="dom-repeat" items="[[items]]">
        <device-graph
          item="[[item]]"
          interpolation="[[interpolation]]"
          store-inside
          no-link="[[noLink]]">
        </device-graph>
      </template>
    </template>

    <template is="dom-if" if="[[!multi]]" restamp>
      <device-graph
        item="[[item]]"
        interpolation="[[interpolation]]"
        store-inside
        no-link="[[noLink]]">
      </device-graph>
    </template>

  </template>
  <script>
    class DeviceChart extends WebvisualBehaviors.FullscreenBehavior(Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], Polymer.Element)) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {
          opened: {
            type: Boolean,
            reflectToAttribute: true
          },

          openOnSelect: {
            type: Boolean,
            value: true
          },

          margin: {
            type: Object,
            value: function() {
              return {
                top: 6,
                right: 20,
                bottom: 6,
                left: 6
              }
            }
          },

          gridMult: {
            type: Number,
            value: 2
          },

          yAxisWidth: {
            type: Number,
            value: 48
          },

          xAxisHeight: {
            type: Number,
            value: 24
          },

          yAxisCondensedWidth: {
            type: Number,
            value: 12
          },

          xAxisCondensedHeight: {
            type: Number,
            value: 12
          },

          xScale: {
            type: String,
            value: 'time',
            observer: 'changeScale'
          },

          yScale: {
            type: String,
            value: 'linear',
            observer: 'changeScale'
          },

          domainX: {
            type: Array,
            value: function() {
              return [null, null];
            },
            notify: true
          },

          domainY: {
            type: Array,
            value: function() {
              return [null, null];
            },
            notify: true
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          noLine: {
            type: Boolean,
            value: false
          },

          noArea: {
            type: Boolean,
            value: false
          },

          noLink: {
            type: Boolean
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._yGrid = {};
        this._brush = {};
        this._chart = {};
        this._control = {};
        this._svg = {};
        this._info = {};
        this._focus = {};
        this._focusX = {};
        this._focusY = {};
        this._focusDot = {};
        this._infoDeltaX = {};
        this._infoDeltaY = {};
        this._delta = {};
        this._deltaX = {};
        this._deltaY = {};
        this._deltaDot = {};
        this._areas = {};
        this._lines = {};
        this._bounderies = {};
        this._focusedValue = null;
        this._fixedValue = null;
        this._x = Function.prototype;
        this._y = Function.prototype;
        this._xAxes = {};
        this._yAxes = {};
        // this._xAxisFn = {};
        // this._yAxisFn = {};
        this._isAttached = false;
        this._isBrushed = false;
        this._isZoomed = false;
        this._brushBehavior = Function.prototype;
        this._graphs = {};
        var localeDateFormat = {
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        }
        var localeNumberFormat = {
          'decimal': ',',
          'thousands': '.',
          'grouping': [3],
          'currency': ['', '\u00a0€']
        };
        d3.timeFormatDefaultLocale(localeDateFormat);
        d3.formatDefaultLocale(localeNumberFormat);
        this.format = {
          Millisecond: d3.timeFormat(':%S,%L'),
          LongSecond: d3.timeFormat(':%M:%S,%L'),
          Second: d3.timeFormat(':%M:%S'),
          LongMinute: d3.timeFormat('%H:%M:%S'),
          Minute: d3.timeFormat('%H:%M'),
          Hour: d3.timeFormat('%X'),
          Day: d3.timeFormat('%d.%m'),
          Week: d3.timeFormat('%d.%m'),
          Month: d3.timeFormat('%d. %b'),
          Year: d3.timeFormat('%Y'),
          timeDiff: function(date) {
            // one year = 365.25 days = 315576E5ms (Julian Calendar)
            var ry = date % 315576E5,
              y = (date - ry) / 315576E5,
              rd = ry % 864E5,
              d = (ry - rd) / 864E5,
              rh = rd % 36E5,
              h = (rd - rh) / 36E5,
              rm = rh % 6E4,
              m = (rh - rm) / 6E4,
              rs = rm % 1E3,
              s = (rm - rs) / 1E3,
              ret = '';
            if (y)
              ret += y + 'y ';
            if (d)
              ret += d + 'd ';
            if (h)
              ret += h + 'h ';
            if (m)
              ret += m + 'm ';
            if (s)
              ret += s + 's ';
            if (rs)
              ret += rs + 'ms';
            return ret;
          },
          Number: d3.format(',')
        }
      }

      _self() {
        return this;
      }

      static get listeners() {
        return {
          'iron-resize': '_sizeChanged'
        }
      }

      static get observers() {
        return [
          '_sizeChanged(opened)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _sizeChanged() {
        // only resize if initialized & opened
        if (this._isAttached && this.opened) {
          if (this._activeSizeJob) {
            clearTimeout(this._activeSizeJob);
          }
          this._activeSizeJob = setTimeout( () => {
            this._sizeLayout();
          }, 150);
        }
      }

      _buildLayout() {
        this._svg = d3.select(this.$.svgChart)
          .attr('height', null)
          .attr('width', null);
        this._x = this._createScaleFn(this.xScale);
        this._y = this._createScaleFn(this.yScale);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._xAxes = d3.select(this.$.xAxes);
        this._yAxes = d3.select(this.$.yAxes);

        this._areas = d3.select(this.$.areas);
        this._lines = d3.select(this.$.lines);
        this._bounderies = d3.select(this.$.bounderies);

        // Test
        // this._xAxes
        //   .append('svg:g')
        //   .classed('x axis', true);
        // this._yAxes
        //   .append('svg:g')
        //   .classed('y axis', true);
        // this._yAxes
        //   .append('svg:g')
        //   .classed('y axis', true);
        //

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            this.cancelDebouncer('hideinfo');
          }, {
            passive: true
          })
          .on('mouseleave', this._hideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        this._brushBehavior = d3.brush()
          // .on('end', this.brushed.bind(this._self()));
          .on('end', this.brushed.bind(this));
        this._brush = d3.select(this.$.brush);
        this._brush
          .on('mouseenter touchstart', this._showInfo.bind(this), {
            passive: true
          })
          .on('mouseleave touchend', this._hideInfo.bind(this), {
            passive: true
          })
          .on('mousemove', () => {
            var m = d3.mouse(this._chart.node());
            requestAnimationFrame( () => {
              var closestGraph, closestPoint, closestDistance;
              var mounts = Object.keys(this._graphs), g;
              for (var i = 0; mounts && i < mounts.length; i++) {
                g = this._graphs[mounts[i]]
                if (g.values && g.values.length) {
                  var d = g._closestPoint(m);
                  var currentMin2 = Math.pow(m[0] - this._x(d.x), 2) + Math.pow(m[1] - this._y(d.y), 2); // in px²
                  if (closestDistance === undefined || currentMin2 < closestDistance) {
                    closestDistance = currentMin2;
                    closestPoint = d;
                    closestGraph = g;
                  }
                }
              }
              if (closestPoint) {
                var fill = closestGraph.getComputedStyleValue('--device-color') || '#000';
                if (closestGraph.item.threshold) {
                  switch (closestPoint.state) {
                    case 1:
                      fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
                      break;
                    case -1:
                      fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
                      break;
                  }
                }
                this._focusedValue = closestPoint;
                this._focusDot.datum(closestPoint)
                  .attr('fill', fill)
                  .attr('r', closestGraph.dotRadius);
                this._showInfo();
                this._moveInfo(closestPoint);
              } else {
                this._hideInfo();
              }
            });
          }, {
            passive: true
          })
          .on('touchmove', this._resetZoom.bind(this), {
            passive: true
          });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._sizeChanged();
      }

      _sizeLayout() {
        if (!this._isAttached) return;

        var bRect = this.$.svgChart.getBoundingClientRect();
        // console.log('sizeLayout', bRect);

        if (bRect.height === 0 || bRect.width === 0) return;

        var top = this.margin.top,
          right = this.margin.right,
          bottom = this.margin.bottom,
          left = this.margin.left,
          yAxisWidth = this.yAxisWidth,
          yAxisCondensedWidth = this.yAxisCondensedWidth,
          xAxisCondensedHeight = this.xAxisCondensedHeight,
          xAxisHeight = this.xAxisHeight,
          lineWidth = 1;

        var mounts = Object.keys(this._graphs), g, yexp, xexp;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          yexp = g.yAxisExpanded;
          xexp = g.xAxisExpanded;

          if (g.yAxisPosition === 'left') {
            left += yexp ? yAxisWidth : yAxisCondensedWidth;
            g._y_left = left; g._y_right = null;
            // g.yAxisExpandButton.transition(150).attr('x', left).attr('y', 0);
          }
          else {
            right += yexp ? yAxisWidth : yAxisCondensedWidth;
            g._y_left = null; g._y_right = right;
            // g.yAxisExpandButton.transition(150).attr('x', right).attr('y', 0);
          }
          if (g.xAxisPosition === 'bottom') {
            g._x_bottom = bottom; g._x_top = null;
            // g.xAxisExpandButton.transition(150).attr('y', bottom).attr('x', this._width);
            bottom += xexp ? xAxisHeight : xAxisCondensedHeight;
          }
          else {
            g._x_bottom = null; g._x_top = top;
            // g.xAxisExpandButton.transition(150).attr('y', top).attr('x', this._width);
            top += xexp ? xAxisHeight : xAxisCondensedHeight;
          }

        }

        this._width = bRect.width - (left || 0) - (right || 0);
        this._height = bRect.height - (bottom || 0) - (top || 0);

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this.xTicks = Math.ceil(this._width / 75);
        this.yTicks = Math.ceil(this._height / 50);

        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          yexp = g.yAxisExpanded;
          xexp = g.xAxisExpanded;
          g.xAxisFn.tickFormat(xexp ? null : '').tickSize(xAxisCondensedHeight);
          g.yAxisFn.tickFormat(yexp ? null : '').tickSize(yAxisCondensedWidth);
          g.xAxisNode.call(g.xAxisFn).attr('transform', 'translate(0,' + this._height + ')');
          g.yAxisNode.call(g.yAxisFn).attr('transform', 'translate(0,0)');
          g.xAxisExpandButton.transition(150).attr('height', xexp ? xAxisHeight : xAxisCondensedHeight).attr('width', xexp ? xAxisCondensedHeight : lineWidth);
          g.yAxisExpandButton.transition(150).attr('height', yexp ? yAxisCondensedWidth : lineWidth).attr('width', yexp ? yAxisWidth : yAxisCondensedWidth);
        }

        this._control.transition(150).style('transform', 'translate('+right+'px,-'+bottom+'px)');

        // Limiting Projection to Margin
        this._chart.select('clipPath#clip rect').transition(150)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.select('rect#plot').transition(150)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.transition(150).attr('transform', 'translate(' + (-left || 0) + ',' + (top || 0) + ')');
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);

        // this._xGrid = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._height)
        //   .tickFormat('');
        // this._yGrid = this._createAxisFn(this._y, 'left', this.yScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._width)
        //   .tickFormat('');

        // this._xAxes.selectAll('.x.axis')
        //   .call(this._xAxisFn)
        //   .attr('transform', 'translate(0,' + this._height + ')');
        // this._yAxes.selectAll('.y.axis')
        //   .call(this._yAxisFn)
        //   .attr('transform', 'translate(0,' + 0 + ')');

        // this._chart.select('#xGrid')
        //   .attr('transform', 'translate(0,' + this._height + ')')
        //   .call(this._xGrid);
        // this._chart.select('#yGrid')
        //   .call(this._yGrid)
        //   .attr('transform', 'translate(0,' + 0 + ')');;

        if (this._isBrushed !== true || this._isZoomed !== true) {
          this._brushBehavior.extent([
            [0, 0],
            [this._width, this._height]
          ])
          this._brush.call(this._brushBehavior);
        }

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope device-chart', true)
        this._focusY.attr('y1', this._height);

        this._redraw(true);
      }

      _createScaleFn(option) {
        switch (option) {
          case 'time':
            return d3.scaleTime();
            break;
          case 'ln':
            return d3.scaleLog().base(Math.E);
            break;
          case 'log₁₀':
            return d3.scaleLog();
            break;
          case '√':
            return d3.scaleSqrt();
            break;
          default:
            return d3.scaleLinear();
        }
      }

      _createAxisFn(scale, orient, kind, ticks) {
        var axis;
        ticks = ticks || 5;
        switch (orient) {
          case 'top':
            axis = d3.axisTop();
            break;
          case 'bottom':
            axis = d3.axisBottom();
            break;
          case 'left':
            axis = d3.axisLeft();
            break;
          case 'right':
            axis = d3.axisRight();
            break;
        }
        axis.scale(scale).ticks(ticks);
        if (kind === 'time')
          axis.ticks(ticks).tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat(d => {
            return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
          })

        return axis;
      }

      timeFormat(date) {
        return (d3.timeSecond(date) < date ? this.format.Millisecond :
          d3.timeMinute(date) < date ? this.format.Second :
          d3.timeHour(date) < date ? this.format.Minute :
          d3.timeDay(date) < date ? this.format.Hour :
          d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.format.Day : this.format.Week) :
          d3.timeYear(date) < date ? this.format.Month :
          this.format.Year)(date);
      }

      timeFormatRange(date, r, pixels) {
        var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.format.Millisecond :
          rangeRatio < 5E2 ? this.format.LongSecond :
          rangeRatio < 5E3 ? this.format.Second :
          rangeRatio < 2E4 ? this.format.LongMinute :
          rangeRatio < 6E4 ? this.format.Minute :
          rangeRatio < 36E5 ? this.format.Hour :
          rangeRatio < 864E5 ? this.format.Day :
          rangeRatio < 6048E5 ? this.format.Week :
          rangeRatio < 24192E5 ? this.format.Month :
          this.format.Year)(date);
      }

      redraw() {
        if (!(this.opened && this._chart && this._chart.select)) return;

        Promise.resolve(this.setDomains.call(this))
          .then(this._redraw.bind(this))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      _redraw(force) {
        if (!(this.opened && this._chart && this._chart.select)) return;

        if (force || !this.domainY || !this.domainX) {
          this.redraw();
          return;
        }
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          g.redraw();
        }

        // this._chart.transition(50).select('#xGrid').call(this._xGrid);
        // this._chart.transition(50).select('#yGrid').call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
        this._updateInfo();
      }

      brushed() {
        // var s = d3.event.selection;
        // this._hideInfo();
        // if (s) {
        //   this._isBrushed = true;
        //   this._isZoomed = true;
        //   this._x.domain([s[0][0], s[1][0]].map(this._x.invert, this._x)).nice(this.xTicks);
        //   this._y.domain([s[1][1], s[0][1]].map(this._y.invert, this._y)).nice(this.yTicks);
        //   this._brush.call(this._brushBehavior.move, null);
        //   return;
        // } else if (this._isBrushed === true) {
        //   this._isBrushed = false;
        // } else {
        //   this._isZoomed = false;
        //   this.redraw();
        //   return;
        // }
        // this._redraw();
      }

      setDomains() {
        return new Promise((resolve, reject) => {
          if (!Object.keys(this._graphs).length)
            reject('No Graphs are attached');
          if (this._isZoomed === true || this._isBrushed === true) {
            resolve();
          }

          this.requestRange('x')
            .then(rangeX => {
              var domainX = rangeX;
              this.requestRange('y')
                .then(rangeY => {

                  var domainY = rangeY;

                  // if min, max are equal, add a little space
                  if (domainY[0] !== undefined && domainY[1] !== undefined && domainY[0] === domainY[1]) {
                    domainY[0] -= 0.5;
                    domainY[1] += 0.5;
                  }

                  if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
                    if (domainY[0] <= 0) {
                      domainY[0] = Number.EPSILON;
                    }
                    if (domainY[1] <= 0) {
                      domainY[1] = Number.EPSILON;
                    }
                  }

                  this._x.domain(domainX);
                  this.set('domainX', domainX);
                  this._y.domain(domainY).nice(this.yTicks);

                  // if domain is on the edge of data, add a little space
                  domainY = this._y.domain();
                  if (domainY[0] === rangeY[0]) {
                    domainY[0] -= (rangeY[1] - rangeY[0]) / this.yTicks;
                  }
                  if (domainY[1] === rangeY[1]) {
                    domainY[1] += (rangeY[1] - rangeY[0]) / this.yTicks;
                  }
                  this._y.domain(domainY);
                  this.set('domainY', domainY);
                  resolve();

                })
                .catch(err => {
                  reject(err);
                });
            })
            .catch(err => {
              reject(err);
            });
        });
      }

      insertValues(data) {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        }
      }

      clearValues() {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          if (g.item && g.item.mount)
            g.clearValues();
        }
      }

      requestRange(key) {
        return new Promise((resolve, reject) => {
          var p = [];
          var mounts = Object.keys(this._graphs), g;
          for (var i = 0; mounts && i < mounts.length; i++) {
            g = this._graphs[mounts[i]];
            if (g.item && g.item.mount)
              p.push(g.requestRange(key));
          }
          Promise.all(p)
            .then(res => {
              var min, max;
              for (var i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i][0]) ? res[i][0] : min;
                max = (max === undefined || max < res[i][1]) ? res[i][1] : max;
              }
              if (min === undefined || max === undefined) {
                reject();
              }
              resolve([min, max]);
            })
            .catch(function(err) {
              //  reject(err);
              //  if (err) {
              //    console.log(err);
              //  }
            });
        });
      }

      _moveInfo(d) {
        if (Number.isFinite(this._y(d.y))) {
          var x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
          var y = this.format.Number(d.y);
          this._info.text(x + ' ' + y);
          var fixP = this._fixedValue;
          if (fixP) {
            var diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            diffX = this.format.timeDiff.call(this, diffX);
            diffY = this.format.Number(diffY);
            this._infoDeltaX.text(diffX);
            this._infoDeltaY.text(diffY);
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        this.cancelDebouncer('hideinfo');
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _hideInfo() {
        this.debounce('hideinfo', this._debounceHideInfo, 1000);
      }

      _debounceHideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);
        // this._xAxes.select('.x.axis').call(this._xAxisFn);
        // this._yAxes.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        var focP = this._focusedValue;
        var x = this._x(+focP.x),
          y = this._y(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        switch (this.modus) {
          case 'delta':
            var fixP = this._fixedValue;
            if (fixP && fixP.x && focP.x !== fixP.x && fixP.y && focP.y !== fixP.y) {
              var xFix = this._x(+fixP.x),
                yFix = this._y(+fixP.y);
              var x1D, x2D, y1D, y2D;
              this._deltaX.attr('x1', x).attr('x2', xFix).attr('y1', yFix).attr('y2', yFix);
              this._deltaY.attr('y1', y).attr('y2', yFix);
              if (yFix < y || x < xFix) {
                this._deltaY.attr('x1', x).attr('x2', x);
                this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
              } else {
                this._deltaY.attr('x1', xFix).attr('x2', xFix);
                this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
              }
              this._deltaX
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
              this._deltaDot.attr('cy', yFix).attr('cx', xFix);
            } else {
              this._hideDelta();
            }
          case 'integral':
          default:
            this._focusX.attr('x1', 0).attr('x2', x).attr('y2', y).attr('y1', y);
            this._focusY.attr('y1', this._height).attr('y2', y).attr('x2', x).attr('x1', x);
            this._focusDot.attr('cy', y).attr('cx', x);
        }

        // this._xAxisFn.tickValues([this._focusedValue.x]);
        // this._xAxisFn.tickFormat(null);
        // this._yAxisFn.tickValues([this._focusedValue.y]);
        // this._yAxisFn.tickFormat(null);
        // this._xAxes.select('.x.axis').call(this._xAxisFn);
        // this._yAxes.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        var bbox = node.getBBox(),
          height = this._height,
          width = this._width,
          textAnchor = textAnchor || 'middle',
          alignmentBaseline = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;

        switch (textAnchor) { // list is not complete!
          case 'middle':
            limitLeft += bbox.width / 2;
          case 'end ':
            limitLeft += bbox.width;
        }
        switch (alignmentBaseline) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
          case 'middle':
            limitBottom += bbox.height / 2;
          case 'hanging':
            limitBottom -= bbox.height;
        }

        if (y - limitBottom < 0) { // above top
          alignmentBaseline = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft > width) { // beyond right
          textAnchor = 'end';
        } else if (x - limitLeft < 0) { // beyond left
          textAnchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', textAnchor);
        node.setAttribute('alignment-baseline', alignmentBaseline);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
      }

      _dotClicked(d) {
        switch (this.modus) {
          case 'zoom':
            var offsetX = (this._x(this._x.domain()[1]) - this._x(this._x.domain()[0])) / 4,
              offsetY = (this._y(this._y.domain()[0]) - this._y(this._y.domain()[1])) / 4,
              x = this._x(+d.x),
              y = this._y(+d.y) || 0;
            d3.event.selection = [
              [x - offsetX, y - offsetY],
              [x + offsetX, y + offsetY]
            ];
            this.brushed();
            break;
          case 'delta':
            var fP = this._fixedValue;
            if (fP && fP.x && fP.y && fP.x === d.x && fP.y === d.y) {
              this._fixedValue = null;
              this._hideDelta();
              this._updateInfo();
              return;
            }
            this._fixedValue = d;
            this._deltaDot.datum(this._fixedValue)
              .attr('cx', d => {
                return this._x(d.x)
              })
              .attr('cy', d => {
                return this._y(d.y)
              })
              .attr('r', this._focusDot.attr('r'))
              .attr('fill', this._focusDot.attr('fill'));
            break;
          case 'integral':
            break;
        }
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation, oldValue) {
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          g.set('interpolation', interpolation);
        }
      }

      changeScale(newValue, oldValue) {
        // if (oldValue === undefined) return;
        // var domainY = this._y.domain();
        // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
        //   if (domainY[0] <= 0) {
        //     domainY[0] = Number.EPSILON;
        //   }
        //   if (domainY[1] <= 0) {
        //     domainY[1] = Number.EPSILON;
        //   }
        // }
        // this._hideInfo();
        // this._y = this._createScaleFn(this.yScale);
        // this._y.domain(domainY).nice(this.yTicks);
        // this.set('domainY', domainY);
        // this._sizeChanged();
      }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this._debounceHideInfo();
        this.redraw();
      }

      _refresh() {
        this._buildLayout();
        var mounts = Object.keys(this._graphs), g;
        for (var i = 0; mounts && i < mounts.length; i++) {
          g = this._graphs[mounts[i]];
          g.clearValues(true);
          g.requestValues(null, null, this.viewLength)
            .then(function(data) {
              for (var mount in data) {
                if (mount === this.item.mount) {
                  this.insertValues(data[mount]);
                  break;
                }
              }
            }.bind(g))
            .catch(err => {
              if (err) {
                console.log(err);
              }
            });
        }
        this._isZoomed = false;
        this.redraw();
      }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
