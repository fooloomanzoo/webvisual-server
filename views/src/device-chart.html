<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="mixins/axes-mixin.html">
<link rel="import" href="mixins/fullscreen-mixin.html">

<link rel="import" href="components/icon-button.html">
<link rel="import" href="style/selectbox-style.html">
<link rel="import" href="style/button-style.html">

<link rel="import" href="device-graph.html">

<dom-module id="device-chart">
  <template strip-whitespace>
    <style include="selectbox-style button-style">
      :host {
        box-sizing: border-box;
        position: relative;
        font-family: inherit;
        color: white;
        letter-spacing: normal !important;
        user-select: none !important;
        z-index: auto;
        transition: background 150ms linear;
      }
      :host([fullscreen]) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
        min-height: 100%;
        min-width: 100%;
        padding: 0 !important;
        margin: 0 !important;
        --control-bottom: 8px;
        --control-right: 16px;
        --control-button-distance: 8px;
      }
      :host(:-webkit-full-screen) {
        color: var(--fullscreen-color, white);
        background-color: var(--fullscreen-background-color);
      }
      #svgContainer {
        position: relative;
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        isolation: isolate;
      }
      :host([fullscreen]) > #svgContainer {
        position: fixed;
        padding: 1em 1em 3em 1em !important;
      }
      #svg {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        width: 100%; height: 100%;
        overflow: opened;
        font-family: inherit !important;
      }
      text {
        fill: currentColor;
        stroke: white;
        stroke-width: 0.1;
        stroke-opacity: 0.2;
        font-size: 1em;
        letter-spacing: normal !important;
        font-family: inherit !important;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      }
      text.info {
        fill: var(--primary-text-color);
      }
      /*g#brush .selection {
        stroke: currentColor;
        stroke-opacity: 0.7;
      }*/
      rect#plot {
        fill: var(--chart-plot-background-color, #fff);
        stroke: currentColor;
        fill-opacity: var(--chart-plot-background-opacity, 0.2);
        stroke-opacity: 0.5;
        stroke-width: 1px;
      }
      .grid .tick line {
        stroke: currentColor;
        stroke-opacity: 0.15;
      }
      .grid {
        mix-blend-mode: exclusion;
      }
      .grid path {
        stroke-width: 0;
      }
      .axis {
        cursor: -webkit-grab;
        cursor: grab;
        font-family: inherit !important;
      }
      .axis.dragged {
        cursor: -webkit-grabbing;
        cursor: grabbing;
      }
      .axis path, .axis line {
        fill: currentColor;
        fill-opacity: 0.01;
        stroke: currentColor;
        stroke-opacity: 0.75;
        transition: fill-opacity 150ms linear;
      }
      .axis:hover path {
        fill-opacity: 0.3;
      }
      .axis.expanded path, .axis.expanded line {
        stroke-opacity: 0.9;
      }
      .axis.dragged path {
        fill-opacity: 0.2;
      }
      .axis:not(.vertical) .tick > text {
        alignment-baseline: after-edge;
      }
      .axis:not(.vertical) .tick:first-of-type:not(:only-of-type) > text {
        text-anchor: start;
      }
      .axis:not(.vertical) .tick:nth-last-of-type(2):not(:only-of-type) > text {
        text-anchor: end;
      }
      .axis.vertical[position="left"]:not(.dragged) .tick > text {
        text-anchor: end;
      }
      .axis.vertical[position="right"]:not(.dragged) .tick > text {
        text-anchor: start;
      }
      .brush .selection {
        fill: currentColor;
        fill-opacity: 0.5;
        stroke: currentColor;
        stroke-width: 0;
      }
      .axis.vertical .brush .overlay {
        cursor: ns-resize;
      }
      .axis:not(.vertical) .brush .overlay {
        cursor: ew-resize;
      }
      #graphs .area {
        fill-opacity: 0.3;
        mix-blend-mode: overlay;
        @apply --chart-area;
      }
      #graphs .line {
        cursor: pointer;
        stroke-opacity: 0.9;
        @apply --chart-line;
      }
      .focus,
      .delta {
        color: var(--focus-color, currentColor);
      }
      #focus > *,
      #delta > * {
        stroke: var(--focus-color, currentColor);
        stroke-opacity: 0.5;
        stroke-width: 1.5px;
      }
      marker {
        fill: var(--focus-color, currentColor);
      }
      #focus .line {
        stroke-dasharray: 2;
        mix-blend-mode: darken;
      }
      .dot {
        fill-opacity: 0.9;
        cursor: pointer;
        pointer-events: all;
      }
      .selectbox > * {
        flex: 1 0 auto;
        padding: 0.6em 0.3em;
        font-size: inherit !important;
      }
      .selectbox {
        padding: 0;
      }
      #control {
        position: absolute;
        bottom: var(--control-bottom, 0px);
        right: var(--control-right, 0px);
        mix-blend-mode: exclusion;
      }
      #control > *:not(:first-of-type) {
        margin-left: var(--control-button-distance, 0px);
      }
      #control > * {
        background: rgba(255,255,255,0.0625);
      }
      .selectbox,
      .button {
        font-size: 0.8em;
        margin-top: 0.25em;
        margin-left: 0.25em;
        margin-right: 0.25em;
      }
      .button {
        padding: 0.3em;
      }
      #controlcontent {
        transform: translateY(-100%);
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        background-color: rgba(255, 255, 255, 0.25);
      }
      [hidden] {
        display: none !important;
      }
    </style>

    <div id="svgContainer" on-contextmenu="_resetZoom">
      <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <marker id="arrowToLeft" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m 5.29167,-1.7197893 v 3.439581 L 0,2.6966667e-6 Z"/>
          </marker>
          <marker id="arrowToRight" markerWidth="20" markerHeight="20" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-10 0 15 10">
            <path d="m -5.2916667,-1.7197893 v 3.439581 L 3.3333333e-6,2.6966667e-6 Z"/>
          </marker>
          <marker id="stub" markerWidth="5" markerHeight="5" refX="0" refY="0" orient="auto" markerUnits="strokeWidth" viewBox="-1 -5 2 10">
            <path d="M0,0 m-1,-5 L1,-5 L1,5 L-1,5 z"/>
            <path d="M -2,0 M -5,-1 H 1 V 1 H -5 Z"/>
          </marker>
          <filter x="0" y="0" width="1" height="1" id="solid">
            <feFlood flood-color="white" id="flood"/>
            <feMerge>
              <feMergeNode in="flood" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <g id="chart">
          <clipPath id="clip">
            <rect x="0" y="0"></rect>
          </clipPath>
          <rect id="plot" clip-path="url(#clip)"></rect>
          <!-- <g id="xGrid" class="grid" clip-path="url(#clip)"></g> -->
          <g id="yGrid" class="grid" clip-path="url(#clip)"></g>
          <g id="graphs" clip-path="url(#clip)">
            <g id="area"></g>
            <g id="line"></g>
            <g id="boundery"></g>
            <g id="brush"></g>
          </g>
          <g id="delta" hidden>
            <line id="deltaX" class="line x" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <line id="deltaY" class="line y" marker-start="url(#arrowToLeft)" marker-end="url(#arrowToRight)"></line>
            <circle id="deltaDot" class="dot"></circle>
          </g>
          <g id="focus" hidden>
            <line id="focusX" class="line x" x1="0" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <line id="focusY" class="line y" marker-start="url(#stub)" marker-end="url(#arrowToRight)"></line>
            <circle id="focusDot" class="dot"></circle>
          </g>
          <g id="axis" on-tap="_resetZoom"></g>
          <text id="info" class="focus info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaX" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
          <text id="infoDeltaY" class="delta info" x="0" y="0" filter="url(#solid)" hidden></text>
        </g>
      </svg>
  	</div>
    <section id="control">
      <iron-collapse id="controlcontent" opened="[[showControl]]">
        <div class="selectbox">
          <select value="{{interpolation::change}}">
            <option value="Lineare Verbindung">Lineare Verbindung</option>
            <option value="Basis Spline">Basis Spline</option>
            <option value="Kubischer Spline">Kubischer Spline</option>
            <option value="Cardinaler Spline">Cardinaler Spline</option>
            <option value="Catmull-Rom-Spline">Catmull-Rom-Spline</option>
            <option value="Stufe (mitte)">Stufe (mitte)</option>
            <option value="Stufe (davor)">Stufe (davor)</option>
            <option value="Stufe (danach)">Stufe (danach)</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{yScale::change}}">
            <option value="linear">linear</option>
            <option value="√">√</option>
            <option value="ln">ln</option>
            <option value="log₁₀">log₁₀</option>
          </select>
        </div>
        <div class="selectbox">
          <select value="{{modus::change}}">
            <option value="zoom">zoom</option>
            <option value="delta">delta</option>
          </select>
        </div>
      </iron-collapse>
      <icon-button title="settings" icon="tune" checked="{{showControl}}"></icon-button>
      <icon-button icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></icon-button>
    </section>

    <template is="dom-if" if="[[multi]]" restamp>
      <template is="dom-repeat" items="[[items]]">
        <device-graph item="[[item]]" interpolation="[[interpolation]]" language-resource="[[languageResource]]" multi-axes=[[multiAxes]] range-x=[[rangeX]] range-y=[[rangeY]] no-link="[[!opened]]"></device-graph>
      </template>
    </template>
    <template is="dom-if" if="[[!multi]]" restamp>
      <device-graph item="[[item]]" interpolation="[[interpolation]]" language-resource="[[languageResource]]" multi-axes=[[multiAxes]] range-x=[[rangeX]]  range-y=[[rangeY]] no-link="[[!opened]]"></device-graph>
    </template>
  </template>
  <script>
    class DeviceChart extends Polymer.mixinBehaviors(
      [Polymer.IronResizableBehavior], WebvisualMixins.AxesMixin(WebvisualMixins.FullscreenMixin(Polymer.Element))) {

      static get is() {
        return 'device-chart';
      }

      static get properties() {
        return {

          opened: {
            type: Boolean
          },

          margin: {
            type: Object,
            value: function() {
              return {
                top: 6,
                right: 6,
                bottom: 6,
                left: 6
              }
            }
          },

          gridMult: {
            type: Number,
            value: 2
          },

          multiAxes: {
            type: Object,
            value: function() {
              return {
                x: false,
                y: true
              };
            }
          },

          tickSize: {
            type: Number,
            value: 8
          },

          axisMargin: {
            type: Number,
            value: 6
          },

          axisSize: {
            type: Object,
            value: function() {
              return {
                x: 20,
                y: 54
              };
            }
          },

          interpolation: {
            type: String,
            value: 'Lineare Verbindung',
            observer: 'changeInterpolation'
          },

          noLink: {
            type: Boolean
          },

          item: {
            type: Object
          },

          items: {
            type: Array
          },

          multi: {
            type: Boolean,
            value: false
          },

          showControl: {
            type: Boolean,
            value: false
          },

          modus: {
            type: String,
            value: 'delta',
            observer: '_modusChanged'
          }
        }
      }

      constructor() {
        super();
        this._width = 0;
        this._height = 0;
        this._yGrid = {};
        this._brush = {};
        this._chart = {};
        this._control = {};
        this._svg = {};
        this._info = {};
        this._focus = {};
        this._focusX = {};
        this._focusY = {};
        this._focusDot = {};
        this._infoDeltaX = {};
        this._infoDeltaY = {};
        this._delta = {};
        this._deltaX = {};
        this._deltaY = {};
        this._deltaDot = {};
        this._focusedValue = null;
        this._fixedValue = null;
        // this._xAxisFn = {};
        // this._yAxisFn = {};
        this._isAttached = false;
        this._isZoomed = false;
        this._graphs = new Set();
      }

      get _self() {
        return this;
      }

      _fireResize() {
        this.dispatchEvent(new CustomEvent('iron-resize', {
          bubbles: false,
          composed: true,
          node: this
        }));
        this._sizeChanged();
      }

      connectedCallback() {
        super.connectedCallback();
        this._buildLayout();
      }

      _buildLayout() {
        console.log('_buildLayout');
        this._svg = d3.select(this.$.svg)
          .attr('height', null)
          .attr('width', null);
        // this.scaleX = this._createScaleFn(this.scaleX);
        // this.scaleY = this._createScaleFn(this.scaleY);

        this._chart = d3.select(this.$.chart);
        this._control = d3.select(this.$.control);

        this._axisInsertionPoint = d3.select(this.$.axis);
        this._area = d3.select(this.$.area);
        this._line = d3.select(this.$.line);
        this._boundery = d3.select(this.$.boundery);

        this.axisX = this._computeAxisNode(this._axisInsertionPoint, 'x', this.axisPositionX, this.multiAxes.x);
        this.axisY = this._computeAxisNode(this._axisInsertionPoint, 'y', this.axisPositionY, this.multiAxes.x);
        this.axisGeneratorX = this._computeAxisGenerator(this.axisPositionX, this.scaleX, this.scalingX, this.scaleBaseX);
        this.axisGeneratorY = this._computeAxisGenerator(this.axisPositionY, this.scaleY, this.scalingY, this.scaleBaseY);
        this.axisBrushGeneratorX = this._computeAxisBrushGenerator(this.axisPositionX);
        this.axisBrushGeneratorY = this._computeAxisBrushGenerator(this.axisPositionY);
        // Test
        // this._axis
        //   .append('svg:g')
        //   .classed('x axis', true);
        // this._axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        // this._axis
        //   .append('svg:g')
        //   .classed('y axis', true);
        //

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus);
        this._focusX = d3.select(this.$.focusX);
        this._focusY = d3.select(this.$.focusY);
        this._focusDot = d3.select(this.$.focusDot);
        this._focusDot
          .on('mouseenter', () => {
            this.cancelDebouncer('hideinfo');
          }, {
            passive: true
          })
          .on('mouseleave', this._debouncedHideInfo.bind(this), {
            passive: true
          })
          .on('click', this._dotClicked.bind(this), {
            passive: true
          });

        this._infoDeltaX = d3.select(this.$.infoDeltaX);
        this._infoDeltaY = d3.select(this.$.infoDeltaY);
        this._delta = d3.select(this.$.delta);
        this._deltaX = d3.select(this.$.deltaX);
        this._deltaY = d3.select(this.$.deltaY);
        this._deltaDot = d3.select(this.$.deltaDot);

        // this._brushMixin = d3.brush()
        //   // .on('end', this.brushed.bind(this._self()));
        //   .on('end', this.brushed.bind(this));
        // this._brush = d3.select(this.$.brush);
        // this._brush
        //   .on('mouseenter touchstart', this._showInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mouseleave touchend', this._debouncedHideInfo.bind(this), {
        //     passive: true
        //   })
        //   .on('mousemove', () => {
        //     var m = d3.mouse(this._chart.node());
        //     requestAnimationFrame( () => {
        //       var closestGraph, closestPoint, closestDistance;
        //       var mounts = Object.keys(this._graphs), g;
        //       for (var i = 0; mounts && i < mounts.length; i++) {
        //         g = this._graphs[mounts[i]]
        //         if (g.values && g.values.length) {
        //           var d = g._closestPoint(m);
        //           var currentMin2 = Math.pow(m[0] - g.scaleX(d.x), 2) + Math.pow(m[1] - g.scaleY(d.y), 2); // in px²
        //           if (closestDistance === undefined || currentMin2 < closestDistance) {
        //             closestDistance = currentMin2;
        //             closestPoint = d;
        //             closestGraph = g;
        //           }
        //         }
        //       }
        //       if (closestPoint) {
        //         var fill = closestGraph.getComputedStyleValue('--device-color') || '#000';
        //         if (closestGraph.item.threshold) {
        //           switch (closestPoint.state) {
        //             case 1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-exceeds-color') || '#F20C0C';
        //               break;
        //             case -1:
        //               fill = closestGraph.getComputedStyleValue('--device-state-deceeds-color') || '#F20C0C';
        //               break;
        //           }
        //         }
        //         this._focusedValue = closestPoint;
        //         this._focusedValue.g = closestGraph;
        //         this._focusedValue._y_axis = this.multiAxes.y ? (closestGraph._y_left + closestGraph._y_right) : 0;
        //         this._focusedValue._x_axis = this.multiAxes.x ? (closestGraph._x_bottom + closestGraph._x_top) : this._height;
        //         this._focusDot.datum(closestPoint)
        //           .attr('fill', fill)
        //           .attr('r', closestGraph.dotRadius);
        //         this._showInfo();
        //         this._moveInfo(closestPoint);
        //       } else {
        //         this._debouncedHideInfo();
        //       }
        //     });
        //   }, {
        //     passive: true
        //   })
        //   .on('touchmove', this._resetZoom.bind(this), {
        //     passive: true
        //   });

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);

        this._isAttached = true;

        this._modusChanged(this.modus);
        this._multiAxesChanged(this.multiAxes);
        this._sizeChanged();
      }

      reset() {
        this.opened = false;
        this.set('item', {});
        this.set('items', []);
        this.set('exceeding', []);
      }

      _sizeChanged() {
        // only resize if initialized
        if (!(this.opened && this._isAttached)) return;
        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }
        this._activeSizeJob = requestAnimationFrame(() => {
          this._sizeLayout();
        }, 0);
      }

      _sizeLayout() {
        if (!(this.opened && this._isAttached)) return;
        var bRect = this.$.svg.getBoundingClientRect();

        if (this._activeSizeJob) {
          cancelAnimationFrame(this._activeSizeJob);
        }

        if (bRect.height === 0 || bRect.width === 0) {
          requestAnimationFrame(() => {
            this._sizeChanged();
          });
          return;
        }

        console.log('_sizeLayout');
        var top = 0,
          right = 0,
          bottom = 0,
          left = 0,
          axisSize = this.axisSize,
          tickSize = this.tickSize,
          axisMargin = this.axisMargin,
          condensedSize = tickSize + axisMargin;

        var q = [];

        function incremPosition(size) {
          var pos = this._pos;
          if (pos === 'left') {
            this._left = left;
            this._right = 0;
            left -= size;
          } else if (pos === 'right') {
            this._left = 0;
            this._right = right;
            right += size;
          } else {
            this._left = 0;
            this._right = 0;
          }
          if (pos === 'top') {
            this._bottom = 0;
            this._top = top;
            top -= size;
          } else if (pos === 'bottom') {
            this._bottom = bottom;
            this._top = 0;
            bottom += size;
          } else {
            this._bottom = 0;
            this._top = 0;
          }
          return true;
        }

        function finalizePosition(width, height) {
          var pos = this._pos;
          this._left += this._right;
          this._top += this._bottom;
          this._bottom = 0; this._right = 0;
          if (pos === 'right') {
            this._left += width;
          } else if (pos === 'bottom') {
            this._top += height;
          }
          return true;
        }

        this._graphs.forEach( g => {
          // if (this.multiAxes.x === true && g.axisX) {
            var size = g.axisX.classed('expanded') ? axisSize.x : condensedSize;
            q.push(incremPosition.call(g.axisX, size));
          // }
          // if (this.multiAxes.y === true && g.axisY) {
            var size = g.axisY.classed('expanded') ? axisSize.y : condensedSize;
            q.push(incremPosition.call(g.axisY, size));
          // }
        })
        // if (this.multiAxes.x === true && this.axisX) {
          var size = this.axisX.classed('expanded') ? axisSize.x : condensedSize;
          q.push(incremPosition.call(this.axisX, size));
        // }
        // if (this.multiAxes.y === true && this.axisY) {
          var size = this.axisY.classed('expanded') ? axisSize.y : condensedSize;
          q.push(incremPosition.call(this.axisY, size));
        // }

        // this.xTicks = Math.ceil(this._width / 75);
        // this.yTicks = Math.ceil(this._height / 50);

        Promise.all(q).then(() => {
          var bRect = this.$.svg.getBoundingClientRect();
          this._width = bRect.width - Math.abs(left || 0) - Math.abs(right || 0) - (this.margin.left || 0) - (this.margin.right || 0);
          this._height = bRect.height - Math.abs(bottom || 0) - Math.abs(top || 0) - (this.margin.bottom || 0) - (this.margin.top || 0);

          this.set('rangeX', [0, this._width]);
          this.set('rangeY', [this._height,0]);

          var p = [];

          this._graphs.forEach( g => {
            // if (this.multiAxes.x === true && g.axisX) {
              p.push(finalizePosition.call(g.axisX, this._width, this._height));
            // }
            // if (this.multiAxes.y === true && g.axisY) {
              p.push(finalizePosition.call(g.axisY, this._width, this._height));
            // }
          })
          // if (this.multiAxes.x === true && this.axisX) {
            p.push(finalizePosition.call(this.axisX, this._width, this._height));
          // }
          // if (this.multiAxes.y === true && this.axisY) {
            p.push(finalizePosition.call(this.axisY, this._width, this._height));
          // }

          Promise.all(p).then(() => {
            top -= (this.margin.top || 0);
            right += (this.margin.right || 0);
            bottom += (this.margin.bottom || 0);
            left -= (this.margin.left || 0);
            this._chart._top = top;
            this._chart._right = right;
            this._chart._bottom = bottom;
            this._chart._left = left;
            if (!this.domainX || !this.domainY) {
              this.redraw(true);
            } else {
              this.redraw();
            }
          })
        })

        // this._xGrid = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._height)
        //   .tickFormat('');
        // this._yGrid = this._createAxisFn(this._y, 'left', this.yScale, this.xTicks*this.gridMult)
        //   .tickSize(-this._width)
        //   .tickFormat('');

        // this._chart.select('#xGrid')
        //   .attr('transform', 'translate(0,' + this._height + ')')
        //   .call(this._xGrid);
        // this._chart.select('#yGrid')
        //   .call(this._yGrid)
        //   .attr('transform', 'translate(0,' + 0 + ')');;

        // if (this._isBrushed !== true || this._isZoomed !== true) {
        //   this._brushMixin.extent([
        //     [0, 0],
        //     [this._width, this._height]
        //   ])
        //   this._brush.call(this._brushMixin);
        // }
      }

      _multiAxesChanged(multiAxes) {
        // if (!this._isAttached) return;
        // console.log('_multiAxesChanged', multiAxes);
        // this._addAxis();
        // for (var key in multiAxes) {
        //   this._graphs.forEach( g => {
        //     g._addAxis(key, g.item.mount, !multiAxes[key]);
        //     if (multiAxes[key] === true) {
        //       console.log('forced scale', key);
        //       g._createScale(key);
        //       Promise.resolve(g._getDomain(key));
        //     } else {
        //       g.scale[key] = this.scale[key].bind(g);
        //     }
        //     g._updateAxisBrushGenerator(key);
        //     g._updateAxisBrushGenerator(key);
        //   })
        //
        //   if (multiAxes[key] === true) {
        //     // hide main axis
        //     this._axis[key].attr('hidden', true);
        //   } else {
        //     this._axis[key].attr('hidden', null);
        //   }
        //   this._updateAxisBrushGenerator(key);
        //   this._updateAxisBrushGenerator(key);
        // }
      }

      // _addAxis(g, key, mount, expanded) {
      //   if (g._axis[key]) return;
      //   this._nodes.axes[key] = this._nodes.axes[key] || d3.select(this.$.axis).append('svg:g').classed(key, true);
      //   var self = this, vertical = false, pos = g.axisPosition[key];
      //   // enter axes node
      //   g._axis[key] = this._nodes.axes[key]
      //     .append('svg:g')
      //     .classed('axis', true)
      //     .classed(key, true)
      //     .classed('expanded', expanded)
      //     .attr('mount', mount)
      //     .on('click', function() {
      //       var a = d3.select(this),
      //         exp = a.classed('expanded');
      //       a.classed('expanded', !exp);
      //       this._expanded = exp;
      //       self._sizeChanged();
      //     })
      //     .call(d3.drag()
      //       .on("start", this._axisDragStarted)
      //       .on("drag", this._axisDragged)
      //       .on("end", this._axisDragEnded));
      //
      //   // add title
      //   g._axis[key].append('svg:title').text(mount);
      //   // set scale
      //   // this.scale[key] = this._createScaleFn(this.scale[key]).domain(this.domain[key]);
      //   g._axisGenerator[key] = this._createAxisFn(this.scale[key], pos, this.keys[key].scale);
      //   switch (pos) {
      //     case 'left':
      //     case 'right':
      //       this.scale[key].range([this._height, 0]);
      //       g._brushGenerator[key] = d3.brushY();
      //       vertical = true;
      //       break;
      //     case 'bottom':
      //     case 'top':
      //       this.scale[key].range([0, this._width]);
      //       g._brushGenerator[key] = d3.brushX();
      //       break;
      //   }
      //   // enter brush node
      //   g._brush[key] = g._axis[key].append('svg:g').classed('brush', true);
      //   g._axis[key].classed('vertical', vertical);
      //   g._axis[key].node()._vertical = vertical;
      //   g._axis[key].node()._pos = pos;
      //   g._axis[key].node()._caller = g;
      //   // console.log('_addAxis', key, mount, pos)
      // }

      // _updateAxis(g, key) {
      //   g = g || this;
      //   if (!g._axis[key] || g._axis[key].attr('hidden')) return;
      //   var expanded = g._axis[key].classed('expanded'),
      //     tickSize = this.tickSize,
      //     pos = g._axis[key].node()._pos;
      //   // update axis
      //   if (pos === 'left' || pos === 'right') {
      //     this._updateScale.call(g);
      //     if (pos === 'left') {
      //       g._brushGenerator[key].extent([
      //         [-tickSize, 0], [0, this._height]
      //       ]);
      //     } else if (pos === 'right') {
      //       g._brushGenerator[key].extent([
      //         [0, 0], [tickSize, this._height]
      //       ]);
      //     }
      //   } else if (pos === 'bottom' || pos === 'top') {
      //     this._updateScale.call(g);
      //     if (pos === 'top') {
      //       g._brushGenerator[key].extent([
      //         [0, -tickSize], [this._width, 0]
      //       ]);
      //     } else if (pos === 'bottom') {
      //       g._brushGenerator[key].extent([
      //         [0, 0], [this._width, tickSize]
      //       ]);
      //     }
      //   }
      //   g._axisGenerator[key] = this._createAxisFn(g.scale[key], pos, g.keys[key].scale).tickFormat(expanded ? null : '').tickSize(tickSize);
      //   g._brush[key].raise().call(g._brushGenerator[key]);
      //   g._axis[key].call(g._axisGenerator[key]).transition(100)
      //     .attr('transform', 'translate(' + (g._axis[key].node()._left || 0) + ',' + (g._axis[key].node()._top || 0) + ')');
      //   g._axis[key].node()._width = this._width;
      //   g._axis[key].node()._height = this._height;
      // }
      //
      // _removeAxis(g, key) {
      //   g = g || this;
      //   if (!g._axis[key]) return;
      //   // console.log('_removeAxis', key)
      //   var node;
      //   g._brushGenerator[key] = null;
      //   g._axisGenerator[key] = null;
      //   g.scale[key] = this.scale[key];
      //   // remove axis & brush node
      //   if (g._brush[key]) {
      //     node = g._brush[key].node();
      //     if (node && node.parentElement)
      //       node.parentElement.removeChild(node);
      //   }
      //   if (g._axis[key]) {
      //     node = g._axis[key].node();
      //     if (node && node.parentElement)
      //       node.parentElement.removeChild(node);
      //   }
      //   g._axis[key] = null;
      //   g._brush[key] = null;
      // }

      // _callAxes() {
      //   if (!this._isAttached) return;
      //   console.log('_callAxes');
      //   this._graphs.forEach( g => {
      //     g._updateAxis();
      //     g._updateAxisBrush();
      //   })
      //   this._updateAxis();
      //   this._updateAxisBrush();
      // }
      //
      // _updateScales() {
      //   super._updateScales();
      //   this._graphs.forEach( g => {
      //     for (var key in this.multiAxes) {
      //       console.log(this.domain[key], key);
      //       if (!this.multiAxes[key] && this.domain && this.domain[key]) {
      //         g.set('domain.'+key, this.domain[key]);
      //       }
      //     }
      //   })
      // }

      _addGraph(g) {
        this._graphs.add(g);
      }
      _removeGraph(g) {
        this._graphs.delete(g);
      }

      _redomain() {
        if (!this._isAttached) return;

        Promise.resolve(this._getDomain.call(this))
          .then(this.redraw.bind(this, false))
          .catch(err => {
            if (err) {
              console.warn(err);
            }
          });
      }

      redraw(force) {
        if (!this._isAttached) return;

        if (force) {
          this._redomain();
          return;
        }

        console.log('_redraw');
        this._graphs.forEach( g => {
          g.axisGeneratorX = g._computeAxisGenerator(g.axisPositionX, g.scaleX, g.scalingX, g.scaleBaseX);
          g.axisGeneratorY = g._computeAxisGenerator(g.axisPositionY, g.scaleY, g.scalingY, g.scaleBaseY);
          g._updateAxisBrushGenerator.call(g.axisBrushGeneratorX, this.rangeX);
          g._updateAxisBrushGenerator.call(g.axisBrushGeneratorY, this.rangeY);
          g.axisX.select('.brush').call(g.axisBrushGeneratorX);
          g.axisY.select('.brush').call(g.axisBrushGeneratorY);
          g.axisX.call(g.axisGeneratorX.tickFormat(g.axisX.classed('expanded') ? null : ''))
              .transition(100)
              .attr('transform', 'translate(' + (g.axisX._left || 0) + ',' + (g.axisX._top || 0) + ')');
          g.axisY.call(g.axisGeneratorY.tickFormat(g.axisY.classed('expanded') ? null : ''))
              .transition(100)
              .attr('transform', 'translate(' + (g.axisY._left || 0) + ',' + (g.axisY._top || 0) + ')');
          g.redraw();
        })
        this.axisGeneratorX = this._computeAxisGenerator(this.axisPositionX, this.scaleX, this.scalingX, this.scaleBaseX);
        this.axisGeneratorY = this._computeAxisGenerator(this.axisPositionY, this.scaleY, this.scalingY, this.scaleBaseY);
        this._updateAxisBrushGenerator.call(this.axisBrushGeneratorX, this.rangeX);
        this._updateAxisBrushGenerator.call(this.axisBrushGeneratorY, this.rangeY);
        this.axisX.select('.brush').call(this.axisBrushGeneratorX);
        this.axisY.select('.brush').call(this.axisBrushGeneratorY);
        this.axisX.call(this.axisGeneratorX.tickFormat(this.axisX.classed('expanded') ? null : ''))
            .transition(100)
            .attr('transform', 'translate(' + (this.axisX._left || 0) + ',' + (this.axisX._top || 0) + ')');
        this.axisY.call(this.axisGeneratorY.tickFormat(this.axisY.classed('expanded') ? null : ''))
            .transition(100)
            .attr('transform', 'translate(' + (this.axisY._left || 0) + ',' + (this.axisY._top || 0) + ')');

        this._control.transition(100).style('transform', 'translate(-' + this._chart._right + 'px,-' + this._chart._bottom + 'px)');

        // Limiting Projection to Margin
        this._chart.select('clipPath#clip rect').transition(100)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.select('rect#plot').transition(100)
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.transition(100).attr('transform', 'translate(' + (-this._chart._left || 0) + ',' + (-this._chart._top || 0) + ')');

        this._focusY.attr('y1', this._height);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope device-chart', true)
          .classed('device-chart', true);

        this._updateInfo();
      }

      brushed() {
        // var s = d3.event.selection;
        // this._debouncedHideInfo();
        // if (s) {
        //   this._isBrushed = true;
        //   this._isZoomed = true;
        //   this.scaleX.domain([s[0][0], s[1][0]].map(this.scaleX.invert, this.scaleX)).nice(this.xTicks);
        //   this.scaleY.domain([s[1][1], s[0][1]].map(this.scaleY.invert, this.scaleY)).nice(this.yTicks);
        //   this._brush.call(this._brushMixin.move, null);
        //   return;
        // } else if (this._isBrushed === true) {
        //   this._isBrushed = false;
        // } else {
        //   this._isZoomed = false;
        //   this._redomain();
        //   return;
        // }
        // this.redraw();
      }

      _getDomain() {
        console.log('_getDomain');
        return new Promise((resolve, reject) => {
          var p = [], q = [];
          this._graphs.forEach( g => {
            p.push( g._getDomain('x', this.multiAxes['x']) )
            q.push( g._getDomain('y', this.multiAxes['y']) )
          })
          Promise.all(p)
            .then(res => {
              var min, max, domainX;
              for (var i = 0; i < res.length; i++) {
                min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
              }
              if (min === undefined || max === undefined) {
                resolve();
              }
              domainX = [min, max];
              this.set('domainX', domainX);
              if (this.multiAxes.x === false) {
                this._graphs.forEach( g => {
                  g.set('domainX', domainX);
                })
              }
              Promise.all(q)
                .then(res => {
                  var min, max, domainY;
                  for (var i = 0; i < res.length; i++) {
                    min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
                    max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
                  }
                  if (min === undefined || max === undefined) {
                    resolve();
                  }
                  domainY = [min, max];
                  this.set('domainY', domainY);
                  if (this.multiAxes.y === false) {
                    this._graphs.forEach( g => {
                      g.set('domainY', domainY);
                    })
                  }
                  resolve();
                })
                .catch(error => {
                  reject(error);
                })
              })
              .catch(error => {
                reject(error);
              });
          // for (var key in this.multiAxes) {
          //   if (this.multiAxes[key] === true) {
          //
          //   } else {
          //     p.push(
          //       this.requestRange(key)
          //             .then(res => {
          //               if (res.key === 'x') {
          //                 this.set('domainX', res.domain);
          //               }
          //               else if (res.key === 'y') {
          //                 this.set('domainY', res.domain);
          //               }
          //             }) )
          //   }
          // }

          // this.requestRange('x')
          //   .then(rangeX => {
          //     var domainX = rangeX;
          //     this.requestRange('y')
          //       .then(rangeY => {
          //
          //         var domainY = rangeY;
          //
          //         // if min, max are equal, add a little space
          //         if (domainY[0] !== undefined && domainY[1] !== undefined && domainY[0] === domainY[1]) {
          //           domainY[0] -= 0.5;
          //           domainY[1] += 0.5;
          //         }
          //
          //         if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
          //           if (domainY[0] <= 0) {
          //             domainY[0] = Number.EPSILON;
          //           }
          //           if (domainY[1] <= 0) {
          //             domainY[1] = Number.EPSILON;
          //           }
          //         }
          //
          //         this.scaleX.domain(domainX);
          //         this.set('domainX', domainX);
          //         this.scaleY.domain(domainY).nice(this.yTicks);
          //
          //         // if domain is on the edge of data, add a little space
          //         domainY = this.scaleY.domain();
          //         if (domainY[0] === rangeY[0]) {
          //           domainY[0] -= (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         if (domainY[1] === rangeY[1]) {
          //           domainY[1] += (rangeY[1] - rangeY[0]) / this.yTicks;
          //         }
          //         this.scaleY.domain(domainY);
          //         this.set('domainY', domainY);
          //         resolve();
          //
          //       })
          //       .catch(err => {
          //         reject(err);
          //       });
          //   })
          //   .catch(err => {
          //     reject(err);
          //   });
        });
      }

      insertValues(data) {
        this._graphs.forEach( g => {
          if (g && g._isAttached && g.item && g.item.mount && data[g.item.mount])
            g.insertValues(data[g.item.mount]);
        })
      }

      clearValues() {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.clearValues();
        })
      }
      //
      // requestRange(key) {
      //   return new Promise((resolve, reject) => {
      //     var p = [];
      //     this._graphs.forEach( g => {
      //       if (g && g._isAttached && g.item && g.item.mount)
      //         p.push(g._getDomain(key));
      //     })
      //     Promise.all(p)
      //       .then(res => {
      //         var min, max, key;
      //         for (var i = 0; i < res.length; i++) {
      //           min = (min === undefined || min > res[i].domain[0]) ? res[i].domain[0] : min;
      //           max = (max === undefined || max < res[i].domain[1]) ? res[i].domain[1] : max;
      //           key = key || res[i].key;
      //         }
      //         if (min === undefined || max === undefined) {
      //           reject();
      //         }
      //         resolve({domain: [min, max], key: key});
      //       })
      //       .catch(err => {});
      //   });
      // }

      _moveInfo(d) {
        if (Number.isFinite(this.scaleY(d.y))) {
          var x = this.timeFormatRange.call(this, d.x, this.scaleX.domain(), this._width);
          var y = this.numberFormat.call(this, d.y);
          this._info.text(x + ' ' + y);
          var fixP = this._fixedValue;
          if (fixP) {
            var diffX = Math.abs(fixP.x - d.x),
              diffY = Math.abs(fixP.y - d.y);
            diffX = this.timeFormat.call(this, diffX);
            diffY = this.numberFormat.call(this, diffY);
            this._infoDeltaX.text(diffX);
            this._infoDeltaY.text(diffY);
          }
          this._updateInfo();
        }
      }

      _showInfo() {
        this.cancelDebouncer('hideinfo');
        this._info.attr('hidden', null);
        this._focus.attr('hidden', null);
        if (this._fixedValue) {
          this._showDelta();
        }
      }

      _showDelta() {
        this._infoDeltaX.attr('hidden', null);
        this._infoDeltaY.attr('hidden', null);
        this._delta.attr('hidden', null);
      }

      _debouncedHideInfo() {
        if (this._activeHideInfoJob) {
          clearTimeout(this._activeHideInfoJob);
        }
        this._activeHideInfoJob = setTimeout(() => {
          // this._hideInfo();
        }, 1000);
      }

      _hideInfo() {
        this._info.attr('hidden', '');
        this._focus.attr('hidden', '');
        this._hideDelta();
        // this._xAxisFn = this._createAxisFn(this._x, 'bottom', this.xScale, this.xTicks);
        // this._yAxisFn = this._createAxisFn(this._y, 'left', this.yScale, this.yTicks);
        // this._axis.select('.x.axis').call(this._xAxisFn);
        // this._axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _hideDelta() {
        this._infoDeltaX.attr('hidden', '');
        this._infoDeltaY.attr('hidden', '');
        this._delta.attr('hidden', '');
      }

      _updateInfo() {
        if (!this._focusedValue || this._info.attr('hidden') === '') return;
        var focP = this._focusedValue;
        var x = this.scaleX(+focP.x),
          y = this.scaleY(+focP.y);
        if (!x || !y) {
          return;
        }

        this._alignText(this._info.node(), x, y, null, 1.5 * this._focusDot.attr('r'));
        switch (this.modus) {
          case 'delta':
            var fixP = this._fixedValue;
            if (fixP && fixP.x && focP.x !== fixP.x && fixP.y && focP.y !== fixP.y) {
              var xFix = this.scaleX(+fixP.x),
                yFix = this.scaleY(+fixP.y);
              var x1D, x2D, y1D, y2D;
              this._deltaX.attr('x1', x).attr('x2', xFix).attr('y1', yFix).attr('y2', yFix);
              this._deltaY.attr('y1', y).attr('y2', yFix);
              if (yFix < y || x < xFix) {
                this._deltaY.attr('x1', x).attr('x2', x);
                this._alignText(this._infoDeltaY.node(), x, (yFix + y) / 2, null, null, null, 'middle');
              } else {
                this._deltaY.attr('x1', xFix).attr('x2', xFix);
                this._alignText(this._infoDeltaY.node(), xFix, (yFix + y) / 2, null, null, null, 'middle');
              }
              this._deltaX
              this._alignText(this._infoDeltaX.node(), (xFix + x) / 2, yFix, null, null, null, 'middle');
              this._deltaDot.attr('cy', yFix).attr('cx', xFix);
            } else {
              this._hideDelta();
            }
          case 'integral':
          default: // always performed
            this._focusX.attr('x1', focP._y_axis).attr('x2', x).attr('y2', y).attr('y1', y);
            this._focusY.attr('y1', focP._x_axis).attr('y2', y).attr('x2', x).attr('x1', x);
            this._focusDot.attr('cy', y).attr('cx', x);
        }

        // this._xAxisFn.tickValues([this._focusedValue.x]);
        // this._xAxisFn.tickFormat(null);
        // this._yAxisFn.tickValues([this._focusedValue.y]);
        // this._yAxisFn.tickFormat(null);
        // this._axis.select('.x.axis').call(this._xAxisFn);
        // this._axis.select('.y.axis').call(this._yAxisFn);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('device-chart', true);
      }

      _alignText(node, x, y, marginLeft, marginBottom, textAnchor, alignmentBaseline) {
        marginLeft = marginLeft || 0;
        marginBottom = marginBottom || 0;
        var bbox = node.getBBox(),
          height = this._height,
          width = this._width,
          textAnchor = textAnchor || 'middle',
          alignmentBaseline = alignmentBaseline || 'ideographic',
          limitLeft = marginLeft,
          limitBottom = marginBottom;

        switch (textAnchor) { // list is not complete!
          case 'middle':
            limitLeft += bbox.width / 2;
          case 'end ':
            limitLeft += bbox.width;
        }
        switch (alignmentBaseline) { // list is not complete!
          case 'ideographic':
            limitBottom += bbox.height;
          case 'middle':
            limitBottom += bbox.height / 2;
          case 'hanging':
            limitBottom -= bbox.height;
        }

        if (y - limitBottom < 0) { // above top
          alignmentBaseline = 'hanging';
        } else if (y + limitBottom > height) {
          y = height - limitBottom;
        }

        if (x + limitLeft > width) { // beyond right
          textAnchor = 'end';
        } else if (x - limitLeft < 0) { // beyond left
          textAnchor = 'start';
        }
        node.setAttribute('x', x + marginLeft);
        node.setAttribute('y', y - marginBottom);
        node.setAttribute('text-anchor', textAnchor);
        node.setAttribute('alignment-baseline', alignmentBaseline);
      }

      _modusChanged(modus) {
        switch (modus) {
          case 'zoom':

            break;
          case 'delta':

            break;
          case 'integral':

            break;
          default:

        }
      }

      _dotClicked(d) {
        switch (this.modus) {
          case 'zoom':
            var offsetX = (this.scaleX(this.scaleX.domain()[1]) - this.scaleX(this.scaleX.domain()[0])) / 4,
              offsetY = (this.scaleY(this.scaleY.domain()[0]) - this.scaleY(this.scaleY.domain()[1])) / 4,
              x = this.scaleX(+d.x),
              y = this.scaleY(+d.y) || 0;
            d3.event.selection = [
              [x - offsetX, y - offsetY],
              [x + offsetX, y + offsetY]
            ];
            this.brushed();
            break;
          case 'delta':
            var fP = this._fixedValue;
            if (fP && fP.x && fP.y && fP.x === d.x && fP.y === d.y) {
              this._fixedValue = null;
              this._hideDelta();
              this._updateInfo();
              return;
            }
            this._fixedValue = d;
            this._deltaDot.datum(this._fixedValue)
              .attr('cx', d => {
                return this.scaleX(d.x)
              })
              .attr('cy', d => {
                return this.scaleY(d.y)
              })
              .attr('r', this._focusDot.attr('r'))
              .attr('fill', this._focusDot.attr('fill'));
            break;
          case 'integral':
            break;
        }
      }

      closeMenu() {
        this.showMenu = false;
      }

      changeInterpolation(interpolation, oldValue) {
        this._graphs.forEach( g => {
          if (g && g._isAttached)
            g.set('interpolation', interpolation);
        })
      }

      //
      // changeScale(newValue, oldValue) {
      //   // if (oldValue === undefined) return;
      //   // var domainY = this.scaleY.domain();
      //   // if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
      //   //   if (domainY[0] <= 0) {
      //   //     domainY[0] = Number.EPSILON;
      //   //   }
      //   //   if (domainY[1] <= 0) {
      //   //     domainY[1] = Number.EPSILON;
      //   //   }
      //   // }
      //   // this._debouncedHideInfo();
      //   // this.scaleY = this._createScaleFn(this.yScale);
      //   // this.scaleY.domain(domainY).nice(this.yTicks);
      //   // this.set('domainY', domainY);
      //   // this._sizeChanged();
      // }

      _resetZoom(e) {
        if (d3.event)
          d3.event.preventDefault();
        else if (e && e.preventDefault) {
          e.preventDefault();
        }
        this._isZoomed = false;
        this._fixedValue = null;
        this._focusedValue = null;
        this._hideInfo();
        this._redomain();
      }

      // _refresh() {
      //   this._buildLayout();
      //   this._graphs.forEach( g => {
      //     if (g && g._isAttached) {
      //       g.clearValues(true);
      //       g.requestValues(null, null, this.viewLength)
      //         .then(function(data) {
      //           for (var mount in data) {
      //             if (mount === this.item.mount) {
      //               this.insertValues(data[mount]);
      //               break;
      //             }
      //           }
      //         }.bind(g))
      //         .catch(err => {
      //           if (err) console.log(err);
      //         });
      //     }
      //   })
      //   this._isZoomed = false;
      //   this._redomain();
      // }
    }
    customElements.define(DeviceChart.is, DeviceChart);
  </script>

</dom-module>
