<!-- Dependent to be content of device-chart -->
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="mixins/scale-mixin.html" />
<link rel="import" href="mixins/device-mixin.html" />
<link rel="import" href="mixins/color-mixin.html" />

<dom-module id="device-graph">
  <template>
    <style></style>
  </template>
  <script>
    class DeviceAxis extends WebvisualMixins.ScaleMixin(WebvisualMixins.ColorMixin(Polymer.Element)) {

      static get is() {
        return 'device-axis';
      }

      static get properties() {
        return {

          position: {
            type: Object,
            value: function() {
              return {
                x: 'bottom',
                y: 'left'
              }
            },
            observer: '_positionChanged'
          },

          multiAxes: {
            type: Object
          }
        }
      }

      constructor() {
        super();

        this._isAttached = false;
        this._chart = null;

        this._generators.area = d3.area()
          .defined(this._defined.bind(this))
          .x(d => {
            return this.scale.x(d.x);
          })
          .y0(d => {
            if (this.yScale === 'ln' || this.yScale === 'log₁₀') {
              return this._chart._height;
            } else {
              return this.scale.y(0)
            }
          })
          .y1(d => {
            return this.scale.y(d.y);
          });

        this._generators.line = d3.line()
          .defined(this._defined.bind(this))
          .x(d => {
            return this.scale.x(d.x);
          })
          .y(d => {
            return this.scale.y(d.y);
          });

        this.bisectDate = d3.bisector((d, x) => {
          return d.x - x;
        });
      }

      static get observers() {
        return [
          '_itemChanged(item)',
          '_lineChanged(hasLine, "line")',
          '_areaChanged(hasArea, "area")',
          '_thresholdChanged(item.threshold, "boundery")'
        ]
      }

      get _containerRoot() {
        var root = Polymer.dom(this).getOwnerRoot();
        if (!root)
          return Polymer.dom(this).parentNode;
        else if (root.host || root.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
          return root.host;
        else
          return;
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.item) {
          this.addNodes();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeNodes();
      }

      addNodes() {
        // console.log('addNotes', this.item.mount);
        if (this._isAttached) {
          this.clearValues(true);
        }
        var _containerRoot = this._containerRoot;
        if (!_containerRoot || _containerRoot.nodeName !== 'DEVICE-CHART') {
          console.warn('No parentElement (chart) for graph found. Registration of Graph Element failed', _containerRoot);
          return;
        } else if (!_containerRoot._isAttached) {
          console.warn('Chart has not been attached yet for adding a graph. Registration of Graph Element failed');
          return;
        }
        this._chart = _containerRoot;

        this._areaChanged(this.hasArea);
        this._lineChanged(this.hasLine);

        this._chart._addGraph(this);

        this._isAttached = true;

        for (var key in this._chart.multiAxes) {
          if (this._chart.multiAxes[key] === true) {
            this._chart._addAxis(this, key, this.item.mount);
          } else {
            this.scale[key] = this._chart.scale[key];
          }
        }
        this._setColorProperties();
        this._chart._sizeChanged();
      }

      removeNodes() {
        // console.log('removeNodes', this.item.mount);
        this._isAttached = false;
        this._areaChanged();
        this._lineChanged();
        this._thresholdChanged();
        for (var key in this._chart.multiAxes) {
          this._chart._removeAxis(this, key);
          this._chart._sizeChanged();
        }
        this._chart._removeGraph(this);
      }

      _scaleChanged(scale) {
        if (!this._isAttached) return;
        for (var key in scale) {
          this.scale[key] = this._chart.multiAxes[key] ? this._chart._createScaleFn(scale[key]) : this._chart.scale[key];
        }
      }

      _areaChanged(hasArea, type) {
        // console.log('_areaChanged', this.item.mount, hasArea, type);
        if (!(this._chart && this._chart._nodes.area)) return;

        if (hasArea === false) {
          // remove fill area
          if (this._nodes.area && this._nodes.area.node) {
            node = this._nodes.area.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this._nodes.area = null;
          }
        } else {
          if (!(this._nodes.area && this._nodes.area.node)) { // add fill area
            this._nodes.area = this._chart._nodes.area.append('svg:path');
            this._nodes.line.append('svg:title').text(this.item.mount);
          }
          // update fill area node properties
          this._nodes.area
            .attr('mount', this.item.mount)
            .attr('class', 'area')
            .attr('stroke-width', 0)
            .datum([])
            .attr('d', this._generators.area);
        }
      }

      _lineChanged(hasLine, type) {
        // console.log('_lineChanged', this.item.mount, hasLine, type);
        if (!(this._chart && this._chart._nodes.line)) return;

        if (hasLine === false) {
          // remove line
          if (this._nodes.line && this._nodes.line.node) {
            node = this._nodes.line.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this._nodes.line = null;
          }
        } else {
          if (!(this._nodes.line && this._nodes.line.node)) { // add line node
            this._nodes.line = this._chart._nodes.line.append('svg:path');
            this._nodes.line.append('svg:title').text(this.item.mount);
          }
          // update line node properties
          this._nodes.line
            .attr('mount', this.item.mount)
            .attr('class', 'line')
            .attr('fill', 'none')
            .attr('stroke-width', this.lineWidth)
            .datum([])
            .attr('d', this._generators.line);

        }
      }

      _positionChanged(position) {
      }

      _thresholdChanged(threshold) {
        if (!(this._chart && this._chart._nodes.boundery)) return;

        if (threshold) {
          if (!this.boundery) { // add threshold node
            this.boundery = this._chart._nodes.boundery.append('linearGradient');
          }
          // update threshold node properties
          this.boundery
            .attr('id', 'boundery-line-' + this.item.mount)
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', 0).attr('y1', this._chart._height)
            .attr('x2', 0).attr('y2', 0);
        } else {
          // remove threshold colors
          if (this.boundery && this.boundery.node) {
            node = this.boundery.node();
            if (node && node.parentElement)
              node.parentElement.removeChild(node);
            this.boundery = null;
          }
        }
      }


      _itemChanged(item) {
        if (!this._isAttached) {
          return;
        }
        if (!(item && item.mount)) {
          this.removeNodes();
          return;
        }
        this.addNodes();
      }

      insertValues(values, len) {
        if (values === undefined) {
          return;
        }
        var len = len || (this.viewLength > 0 ? this.viewLength : values.length);
        if (!len) {
          values.map(function(v) {
            return {
              x: +v.x,
              y: +v.y,
              state: +v.state
            };
          });
          if (this.storeInside) {
            this.values = this.values.concat(values);
          }
          this.renderInsertedValues(values);
        } else {
          var tmp = values.slice(values.length - len, values.length);
          tmp.map(function(v) {
            return {
              x: new Date(v.x),
              y: +v.y,
              state: +v.state
            };
          });
          if (this.storeInside) {
            this.values = this.values.concat(tmp);
          }
          this.renderInsertedValues(tmp);
          tmp.length = 0;
        }
      }

      spliceValues(splices) {
        // requestAnimationFrame( () => {
        // var changeRecord = [];

        for (var i = 0; i < splices.length; i++) {
          for (var j = this.values.length - 1; j >= 0; j--) {
            if (this.values[j].x === splices[i].x)
              break;
          }
          if (j !== -1) {
            this.values.splice(j, 1);
            // changeRecord.push( { index: j, removed: [this.values[j]], addedCount: 0, object: this.values, type: 'splice'} );
          }
        }

        // })
        // this.notifySplices('values', changeRecord);
        this.redraw();
      }

      renderInsertedValues(values) {
        if (!this._isAttached && this.item) {
          this.addNodes();
        }
        if (this._chart) {
          if (!this._isBrushed) {
            console.log('is not Brushed')
            // for (var key in this._chart.multiAxes) {
              // if (this._chart.multiAxes[key] === true) {
              //   this._getDomain(key).then(this.redraw.bind(this));
              // } else {
                this._chart.redraw();
            //   }
            // }
          } else {
            this.redraw();
          }
        }
      }

      redraw() {
        if (!this._isAttached) return;
      }

      setColor(color) {
        super.setColor.call(this, color);
        if (!this._chart) return;
        for (var key in this.keys) {
          if (this.multiAxes[key] === true && this._nodes.axis[key]) {
            this._nodes.axis[key].style('color', this.item.color || '#000');
          }
        }
      }
    }
    customElements.define(DeviceAxis.is, DeviceAxis);
  </script>

</dom-module>
