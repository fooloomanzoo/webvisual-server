<!-- Dependent to be content of webvisual-element-chart -->
<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="behaviors/color-behavior.html" />
<!-- <link rel="import" href="behaviors/checked-and-select-behavior.html"/> -->
<link rel="import" href="behaviors/element-behavior.html" />

<link rel="import" href="style/webvisual-element-styles.html" />

<script type="text/javascript" src="../bower_components/d3/d3.min.js"></script>

<dom-module id="webvisual-element-graph">
    <template>
    <style include="webvisual-element-styles"></style>
  </template>
    <script>
        DiagramGraph = Polymer({
            is: 'webvisual-element-graph',

            behaviors: [
                WebvisualBehaviors.ColorBehavior,
                // WebvisualBehaviors.CheckedAndSelectBehavior,
                WebvisualBehaviors.ElementBehavior
            ],

            properties: {

                interpolation: {
                    type: String,
                    value: 'Lineare Verbindung',
                    observer: '_interpolationChanged'
                },

                noDots: Boolean,

                noLine: Boolean,

                noFill: Boolean,

                lineWidth: {
                    type: Number,
                    value: 0.5,
                    observer: '_lineWidthChanged'
                },

                dotRadius: {
                    type: Number,
                    value: 2.5,
                    observer: '_dotRadiusChanged'
                },

                viewLength: {
                    type: Number,
                    value: Number.POSITIVE_INFINITY
                },

                storeInside: {
                    type: Boolean,
                    value: true,
                    readOnly: true
                }
            },

            chartElement: Object,
            area: Object,

            _isAttached: false,

            get containerRoot() {
                var root = Polymer.dom(this).getOwnerRoot();
                if (!root)
                    return Polymer.dom(this).parentNode;
                else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
                    return root.host;
                else {
                    return undefined;
                }
            },

            observers: [
                '_itemChanged(item)',
                '_presentationChanged(noDots, noLine, noFill)'
            ],

            created: function() {
                this.area = d3.area()
                    .defined(this._defined.bind(this))
                    .x( function(d) {
                        return this.chartElement._x(d.x);
                    }.bind(this))
                    .y0( function() {
                      if (this.chartElement.yScale === 'ln' || this.chartElement.yScale === 'log₁₀') {
                        return this.chartElement._height;
                      } else {
                        return this.chartElement._y(0)
                      }
                    }.bind(this))
                    .y1( function(d) {
                        return this.chartElement._y(d.y);
                    }.bind(this));
            },

            attached: function() {
                if (this.item) {
                    this.addNodes();
                }
            },

            detached: function() {
                this.removeNodes();
                this.chartElement = null;
            },

            addNodes: function() {
                if (this._isAttached) {
                    this.clearValues(true);
                }
                var containerRoot = this.containerRoot;

                if (!containerRoot || containerRoot.nodeName !== 'WEBVISUAL-ELEMENT-CHART') {
                    console.warn('No parentElement (chart) for graph found. Registration of Graph Element failed');
                    return;
                } else {
                    this.chartElement = containerRoot;
                }

                this.chartElement._graphs.add(this);

                this.noDots = this.chartElement.noDots || false;
                this.noLine = this.chartElement.noLine || false;
                this.noFill = this.chartElement.noFill || false;

                // fill area
                if (this.areaNode) {
                    this.areaNode
                        .attr('data-name', this.item.mount)
                        .attr('fill', this.noFill ? null : (this.item.color || '#000'))
                        .attr('stroke', this.noLine ? null : '#000')
                        .attr('stroke-width', this.lineWidth);
                } else {
                    this.areaNode = this.chartElement._areas
                        .append('svg:path')
                        .attr('data-name', this.item.mount)
                        .attr('class', 'area')
                        .attr('fill', this.noFill ? null : (this.item.color || '#000'))
                        .attr('stroke', this.noLine ? null : '#000')
                        .attr('stroke-width', this.lineWidth);
                }
                this.areaNode
                    .datum([])
                    .attr('d', this.area);

                // threshold markings
                if (this.item) {
                    var y, node;
                    var bounderies = this.chartElement._bounderies;
                    if (this.item.threshold) {
                      this.bounderyAreaGradientNode = bounderies.append('linearGradient')
                          .attr('id', 'boundery-area-' + this.item.mount)
                          .attr('gradientUnits', 'userSpaceOnUse')
                          .attr('x1', 0).attr('y1', this.chartElement._height)
                          .attr('x2', 0).attr('y2', 0);
                      this.areaNode.attr('stroke', 'url(#boundery-area-' + this.item.mount + ')');
                      this.bounderyDotsGradientNode = bounderies.append('linearGradient')
                          .attr('id', 'boundery-dots-' + this.item.mount)
                          .attr('gradientUnits', 'userSpaceOnUse')
                          .attr('x1', 0).attr('y1', this.chartElement._height)
                          .attr('x2', 0).attr('y2', 0);
                    } else if (this.bounderyAreaGradientNode) {
                      node = this.bounderyAreaGradientNode.node();
                      if (node && node.parentElement)
                          node.parentElement.removeChild(node);
                      this.bounderyAreaGradientNode = null;
                      node = this.bounderyDotsGradientNode.node();
                      if (node && node.parentElement)
                          node.parentElement.removeChild(node);
                      this.bounderyDotsGradientNode = null;
                    }
                }
                // group of dots
                if (this.dots) {
                    this.dots.attr('mount', this.item.mount)
                        .attr('hidden', this.noDots ? true : null);
                } else {
                    this.dots = this.chartElement._dots
                        .append('svg:g')
                        .attr('mount', this.item.mount)
                        .attr('class', 'dots')
                        .attr('hidden', this.noDots ? true : null);
                }

                this._isAttached = true;
                this.chartElement.redraw();
            },

            removeNodes: function() {
                var node;
                if (this.areaNode) {
                    node = this.areaNode.node();
                    if (node && node.parentElement)
                        node.parentElement.removeChild(node);
                    this.areaNode = null;
                }
                if (this.dots) {
                    node = this.dots.node();
                    if (node && node.parentElement)
                        node.parentElement.removeChild(node);
                    this.dots = null;
                }
                if (this.bounderyAreaGradientNode) {
                  node = this.bounderyAreaGradientNode.node();
                  if (node && node.parentElement)
                      node.parentElement.removeChild(node);
                  this.bounderyAreaGradientNode = null;
                }
                if (this.bounderyDotsGradientNode) {
                  node = this.bounderyAreaGradientNode.node();
                  if (node && node.parentElement)
                      node.parentElement.removeChild(node);
                  this.bounderyDotsGradientNode = null;
                }

                if (this.chartElement && this.chartElement._graphs)
                    this.chartElement._graphs.delete(this);
                this._isAttached = false;
            },

            _itemChanged: function(item) {
                if (!item || !item.mount) {
                    // this.removeNodes();
                    return;
                }
                this.addNodes();
            },

            insertValues: function(values, len) {
                if (values === undefined) {
                    return;
                }

                var len = len || (this.viewLength > 0 ? this.viewLength : values.length);

                if (!this._initialized)
                    this._initialized = true;
                if (!len) {
                    values.map(function(v) {
                        return {
                            x: +v.x,
                            y: +v.y,
                            state: +v.state
                        };
                    });
                    if (this.storeInside) {
                        this.values = this.values.concat(values);
                    }
                    this.renderInsertedValues(values);
                } else {
                    var tmp = values.slice(values.length - len, values.length);
                    tmp.map(function(v) {
                        return {
                            x: new Date(v.x),
                            y: +v.y,
                            state: +v.state
                        };
                    });
                    if (this.storeInside) {
                        this.values = this.values.concat(tmp);
                    }
                    this.renderInsertedValues(tmp);
                    tmp.length = 0;
                }
            },

            spliceValues: function(splices) {
                // var list = this.$.list.items;

                // requestAnimationFrame( function() {
                var changeRecord = [];

                for (var i = 0; i < splices.length; i++) {
                    for (var j = this.values.length - 1; j >= 0; j--) {
                        if (this.values[j].x === splices[i].x)
                            break;
                    }
                    if (j !== -1) {
                        this.values.splice(j, 1);
                        // changeRecord.push( { index: j, removed: [this.values[j]], addedCount: 0, object: this.values, type: 'splice'} );
                    }
                }

                // }.bind(this))
                // this.notifySplices('values', changeRecord);
                this.redraw();
            },

            renderInsertedValues: function(values) {
                if (!this.chartElement)
                    this.chartElement = this.containerRoot;

                if (this.chartElement) {
                    if (this.chartElement._isZoomed === false)
                        this.chartElement.redraw();
                    else
                        this.redraw();
                }
            },

            redraw: function() {
                if (!(this.chartElement && this.chartElement.opened && this.item && this.values && this.values.length)) return;
                this.async(function() {
                    // performance.mark('graph redraw start');
                    var self = this;
                    var data = this.values || [];
                    if (!this.noFill) {
                      if (this.areaNode) {
                        this.areaNode
                            .datum(data)
                            .attr('d', this.area);
                      } else if (this.item && this.item.mount){
                        this.addNodes();
                        return;
                      } else {
                        return;
                      }
                    }
                    var y;
                    if (this.item.threshold) {
                      if (this.bounderyAreaGradientNode) {
                        var b_area = [];
                        var b_dots = [];
                        var u_color = this.customStyle['element-state-exceeds-color'] || '#F20C0C';
                        var l_color = this.customStyle['element-state-deceeds-color'] || '#F20C0C';

                        if (this.item.threshold.from !== undefined) {
                          y = ((1 - (this.chartElement._y(this.item.threshold.from) + this.lineWidth) / this.chartElement._height) * 100) + '%';
                          b_area.push({o: y, c: l_color})
                          b_area.push({o: y, c: '#000'})
                          y = ((1 - (this.chartElement._y(this.item.threshold.from) + 2 * (this.dotRadius + this.lineWidth * 2))/ this.chartElement._height) * 100) + '%';
                          b_dots.push({o: y, c: l_color})
                          b_dots.push({o: y, c: '#000'})
                        }
                        if (this.item.threshold.to !== undefined) {
                          y = ((1 - (this.chartElement._y(this.item.threshold.to) - this.lineWidth) / this.chartElement._height) * 100) + '%';
                          b_area.push({o: y, c: '#000'})
                          b_area.push({o: y, c: u_color})
                          y = ((1 - (this.chartElement._y(this.item.threshold.to) - 2 * (this.dotRadius + this.lineWidth * 2))/ this.chartElement._height) * 100) + '%';
                          b_dots.push({o: y, c: '#000'})
                          b_dots.push({o: y, c: u_color})
                        }
                        // for area
                        var gradients = this.bounderyAreaGradientNode
                            .attr('x1', 0).attr('y1', this.chartElement._height)
                            .attr('x2', 0).attr('y2', 0)
                            .selectAll('stop')
                              .data(b_area);

                        gradients.attr('offset', function(d) { return d.o; })
                              .attr('stop-color', function(d) { return d.c; });

                        gradients.enter()
                              .append('stop')
                              .attr('offset', function(d) { return d.o; })
                              .attr('stop-color', function(d) { return d.c; });

                        gradients.exit()
                              .remove();

                        // for dots
                        gradients = this.bounderyDotsGradientNode
                            .attr('x1', 0).attr('y1', this.chartElement._height)
                            .attr('x2', 0).attr('y2', 0)
                            .selectAll('stop')
                              .data(b_dots);

                        gradients.attr('offset', function(d) { return d.o; })
                              .attr('stop-color', function(d) { return d.c; });

                        gradients.enter()
                              .append('stop')
                              .attr('offset', function(d) { return d.o; })
                              .attr('stop-color', function(d) { return d.c; });

                        gradients.exit()
                              .remove();
                      }
                    }

                    if (!this.noDots) {
                        data = data.filter(this._defined.bind(this));
                        var everyOverlappingDot = (data.length / Math.max(this.chartElement._height, this.chartElement._width) * (this.dotRadius * 3));

                        if (everyOverlappingDot > 1)
                            data = data.filter(function(d, i) {
                                return (d.state !== 0 || i % everyOverlappingDot <= 1);
                            })
                        var dots = this.dots.selectAll('circle')
                            .data(data);
                        // update current dots
                        dots.attr('cx', function(d) {
                                return this.chartElement._x(d.x)
                            }.bind(this))
                            .attr('cy', function(d) {
                                return this.chartElement._y(d.y)
                            }.bind(this))
                            .attr('fill', this.item.color || '#fff');
                        // enter new dots
                        dots.enter()
                            .append('circle')
                            .classed('dot style-scope webvisual-element-graph', true)
                            .attr('r', this.dotRadius)
                            .attr('fill', this.item.color || '#fff')
                            .attr('cx', function(d) {
                                return this.chartElement._x(d.x)
                            }.bind(this))
                            .attr('cy', function(d) {
                                return this.chartElement._y(d.y)
                            }.bind(this))
                            .attr('stroke', this.bounderyAreaGradientNode ? 'url(#boundery-dots-' + this.item.mount + ')' : '#000')
                            .attr('stroke-width', this.lineWidth * 2)
                            .attr('title', function(d) {
                                return this.computeDate(d.x) + ' | ' + this.computeValue(d.y);
                            }.bind(this))
                            .on('mouseenter', function(d) {
                                this.setAttribute('r', self.dotRadius * 1.5);
                                self.chartElement._showInfo(d);
                            })
                            .on('mouseleave', function(d, i) {
                                this.setAttribute('r', self.dotRadius);
                                self.chartElement._hideInfo();
                            })
                            .on('click', function(d) {
                                var offset = this.dotRadius * 5;
                                var x = this.chartElement._x(d.x);
                                var y = this.chartElement._y(d.y);
                                d3.event.selection = [
                                    [x - offset, y - offset],
                                    [x + offset, y + offset]
                                ];
                                this.chartElement.brushed();
                            }.bind(this));
                        //  remove old dots
                        dots.exit()
                            .remove();
                    }
                }.bind(this));

                // performance.mark('graph redraw end');
                // performance.measure('graph redraw', 'graph redraw start', 'graph redraw end');
                // TODO(?): update line, animated http://bl.ocks.org/benjchristensen/1148374
            },

            _defined: function(d, i, data) {
                var domainX = this.chartElement._x.domain(),
                    yScale = this.chartElement.yScale;

                if (!Number.isFinite(d.y))
                    return false;
                else if ((yScale === 'ln' || yScale === 'log₁₀') && d.y <= 0)
                    return false; // log- and sqrt-scales require larger than 0-Values
                else if ((d.x >= domainX[0] && d.x <= domainX[1])
                     || (data[i+1] && data[i+1].x >= domainX[0] && data[i+1].x <= domainX[1])
                     || (data[i-1] && data[i-1].x >= domainX[0] && data[i-1].x <= domainX[1]))
                    return true; // only numbers in x-Domain are shown (and their successor and predecessor) (graph is a function by definition, so y-Domain is not relevant)
                else
                    return false;
            },

            setColor: function(color) {
                // random color if color is not set
                WebvisualBehaviors.ColorBehavior.setColor.call(this, color);
                if (this.chart) {
                    if (this.areaNode && this.areaNode.attr) this.areaNode.attr('fill', color);
                    if (this.dots && this.dots.selectAll)
                        this.dots.selectAll('circle.dot')
                        .attr('stroke', color);
                }
            },

            clearValues: function(force) {
              WebvisualBehaviors.ElementBehavior.clearValues.call(this, force);
              if (this.dots) {
                this.dots.selectAll('circle')
                        .remove();
              }
            },

            _presentationChanged: function(noDots, noLine, noFill) {
                if (this.dots && this.dots.attr) {
                    this.dots.attr('hidden', this.noDots ? true : null);
                    this.debounce('redraw', this.redraw, 16);
                }
                if (this.areaNode && this.areaNode.attr) {
                    this.areaNode.attr('fill', this.noFill ? (this.item.color || '#000') : null)
                                 .attr('stroke', this.noLine ? '#000' : null);
                    this.debounce('redraw', this.redraw, 16);
                }
            },

            _dotRadiusChanged: function(dotRadius) {
                if (this.dots && this.dots.selectAll) {
                    this.dots.selectAll('circle.dot').attr('r', dotRadius);
                }
            },

            _lineWidthChanged: function(lineWidth) {
                if (this.areaNode) {
                  this.areaNode.attr('stroke-width', lineWidth);
                }
            },

            _interpolationChanged: function(interpolation) {
                var curve;
                switch (interpolation) {
                    case 'Basis Spline':
                        curve = d3.curveBasis;
                        break;
                    case 'Monotoner Spline':
                        curve = d3.curveMonotoneX;
                        break;
                    case 'Kubischer Spline':
                        curve = d3.curveNatural;
                        break;
                    case 'Cardinaler Spline':
                        curve = d3.curveCardinal;
                        break;
                    case 'Catmull-Rom-Spline':
                        curve = d3.curveCatmullRom;
                        break;
                    case 'Stufe (mitte)':
                        curve = d3.curveStep;
                        break;
                    case 'Stufe (davor)':
                        curve = d3.curveStepAfter;
                        break;
                    case 'Stufe (danach)':
                        curve = d3.curveStepBefore;
                        break;
                    default:
                        curve = d3.curveLinear;
                        break;
                }
                this.area.curve(curve);

                if (this.chartElement && this.areaNode)
                    this.redraw();
            }
        });
    </script>

</dom-module>
