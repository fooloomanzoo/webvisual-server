<!-- Dependent to be content of webvisual-element-chart -->
<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="behaviors/color-behavior.html"/>
<link rel="import" href="behaviors/checked-and-select-behavior.html"/>
<link rel="import" href="behaviors/element-behavior.html"/>

<link rel="import" href="style/webvisual-element-styles.html"/>

<script type="text/javascript" src="../bower_components/d3/d3.min.js"></script>

<dom-module id="webvisual-element-graph">
  <template>
    <style include="webvisual-element-styles"></style>
  </template>
  <script>
    DiagramGraph = Polymer({
      is: 'webvisual-element-graph',

      behaviors: [
        WebvisualBehaviors.ColorBehavior,
        WebvisualBehaviors.CheckedAndSelectBehavior,
        WebvisualBehaviors.ElementBehavior
      ],

      properties: {

        interpolation: {
          type: String,
          value: 'Lineare Verbindung',
          observer: '_interpolationChanged'
        },

        noDots: {
          type: Boolean,
          observer: '_noDotsChanged'
        },

        noLine: {
          type: Boolean,
          observer: '_noLineChanged'
        },

        noFill: {
          type: Boolean,
          observer: '_noFillChanged'
        },

        dotRadius: {
          type: Number,
          value: 2.5,
          observer: '_dotRadiusChanged'
        },

        checked: {
          type: Boolean,
          value: true
        },

        viewLength: {
          type: Number,
          value: -1
        },

        storeInside: {
          type: Boolean,
          value: true,
          readOnly: true
        }
      },

      chartElement: Object,
      dots: Object,
      lineNode: Object,
      line: Object,
      areaNode: Object,
      area: Object,

      _hidden: false,
      _isAttached: false,

      get containerRoot() {
        var root = Polymer.dom(this).getOwnerRoot();
        if (!root)
          return Polymer.dom(this).parentNode;
        else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
          return root.host;
        else {
          return undefined;
        }
      },

      observers: [
        '_itemChanged(item)'
      ],

      created: function() {
        this.line = d3.line()
          .x( (d) => {
            return this.chartElement._x(d.x);
          })
          .y( (d) => {
            return this.chartElement._y(d.y);
          });
        this.area = d3.area()
          .x(this.line.x.call(this.area))
          .y0( (d) => {
            if (this.chartElement.yScale === "ln" || this.chartElement.yScale === 'log₁₀') {
              return this.chartElement._y(Number.EPSILON);
            } else {
              return this.chartElement._y(0)
            }
          })
          .y1(this.line.y.call(this.area));
      },

      attached: function() {
        this.addNodes();
      },

      detached: function() {
        this.removeNodes();
      },

      addNodes: function() {
        if (this._isAttached) {
          this.removeNodes();
          this.clearValues(true);
        }
        var containerRoot = this.containerRoot;
        // performance.mark('graph attached start');

        if (!containerRoot || containerRoot.nodeName !== 'WEBVISUAL-ELEMENT-CHART') {
          console.error(this.item.mount, 'Registration of Graph Element failed');
          return;
        } else {
          this.chartElement = containerRoot;
        }

        this.chartElement._graphs.add(this);

        this.noDots = this.chartElement.noDots || this.noDots;
        this.noLine = this.chartElement.noLines || this.noLine;
        this.noFill = this.chartElement.noAreas || this.noFill;

        // node of line
        this.lineNode = this.chartElement._lines
          .append('svg:path')
          .attr('mount', this.item.mount)
          .attr("class", "line")
          .attr('hidden', this.noLine ? true : null)
          .attr('fill', 'none')
          .attr('stroke', this.item.color || '#fff');
        this.lineNode
          .datum([])
          .attr("d", this.line);

        // fill area
        this.areaNode = this.chartElement._areas
          .append('svg:path')
          .attr('mount', this.item.mount)
          .attr("class", "area")
          .attr('hidden', this.noFill ? true : null)
          .attr('fill', this.item.color || '#000')
          .attr('stroke', 'none');
        this.areaNode
          .datum([])
          .attr("d", this.area);

        // group of dots
        this.dots = this.chartElement._dots
          .append("svg:g")
          .attr('mount', this.item.mount)
          .attr("class", "dots")
          .attr("hidden", this.noDots ? true : null);

        this._isAttached = true;

        this.chartElement.redraw();
      },

      removeNodes: function() {
        if (this.lineNode.node())
          this.lineNode.node().parentElement.removeChild(this.lineNode.node());
        if (this.areaNode.node())
          this.areaNode.node().parentElement.removeChild(this.areaNode.node());
        if (this.dots.node())
          this.dots.node().parentElement.removeChild(this.dots.node());

        this.chartElement._graphs.delete(this);
      },

      _itemChanged: function(item) {
        if (!item || !this._isAttached) {
          return;
        }
        this.addNodes();
      },

      insertValues: function(values, len) {
        if (values === undefined) {
          return;
        }

        // console.log(this.nodeName, this.item.mount, values, len);

        var len = len || (this.viewLength > 0 ? this.viewLength : values.length);

        if (!this._initialized)
          this._initialized = true;
        if (!len) {
          // if (this.item && this.item.exceedable === true) {
          //   values.forEach(function (value) {
          //     this.checkExceedingState(value);
          //   }, this)
          // }
          values.map( (v) => {
            return { x: new Date(v.x), y: +v.y, state: +v.state };
          });
          if (this.storeInside) {
            this.values = this.values.concat(values);
          }
          // console.log(this.values);
          this.renderInsertedValues(values);
        } else {
          var tmp = values.slice(values.length - len, values.length);
          // if (this.item && this.item.exceedable === true) {
          //   tmp.forEach(function (value) {
          //     this.checkExceedingState(value);
          //   }, this)
          // }
          tmp.map( (v) => {
            return { x: new Date(v.x), y: +v.y, state: +v.state };
          });
          if (this.storeInside) {
            this.values = this.values.concat(tmp);
          }
          this.renderInsertedValues(tmp);
          tmp.length = 0;
        }
      },

      spliceValues: function(splices) {
        // var list = this.$.list.items;

        requestAnimationFrame( () => {
          var changeRecord = [];

          function find(item) {
            return this.x === item.x;
          }

          for (var i = 0; i < splices.length; i++) {
            var pos = this.values.findIndex( find, splices[i]);
            if (pos !== -1) {
              this.values.splice(pos, 1);
              // changeRecord.push( { index: pos, removed: [this.values[pos]], addedCount: 0, object: this.values, type: 'splice'} );
            }
          }
        })
        // this.notifySplices('values', changeRecord);
      },

      renderInsertedValues: function(values) {
        WebvisualBehaviors.ElementBehavior.renderInsertedValues.call(this, values);
        if (!this.chartElement)
          this.chartElement = this.containerRoot;

        if (this.chartElement) {
          if (this.chartElement._isZoomed === false)
            this.chartElement.redraw();
          else
            this.redraw();
        }
      },

      redraw: function() {
        this.async( () => {
          if (!this.values || !this.values.length || this._hidden === true) return;
          // performance.mark('graph redraw start');
          var self = this;
          var data = this.values.filter(this._defined.bind(this)) || [];

          if (this.noLine === false) {
            this.lineNode
              .datum(data)
              .attr('d', this.line);
          }

          if (this.noFill === false && this.chartElement._height) {
            // this.area
            //   .y0(this.chartElement._y(0));
            this.areaNode
              .datum(data)
              .attr('d', this.area);
          }

          if (this.noDots === false) {
            var everyOverlappingDot = (data.length / Math.max(this.chartElement._height, this.chartElement._width) * (this.dotRadius * 3));

            if (everyOverlappingDot > 1)
              data = data.filter( (d, i) => {
                return (i % everyOverlappingDot <= 1);
              })
              var dots = this.dots.selectAll('circle')
                .data(data);
              // update current dots
              dots.attr('cx', (d) => {
                  return this.chartElement._x(d.x)
                })
                .attr('cy', (d) => {
                  return this.chartElement._y(d.y)
                });
              // enter new dots
              dots.enter()
                .append('circle')
                .classed('dot style-scope webvisual-element-graph', true)
                .attr('r', this.dotRadius)
                .attr('fill', (d) => {
                  switch (d.state) {
                    case 1:
                      return this.customStyle['element-state-exceeds-color'];
                      break;
                    case -1:
                      return this.customStyle['element-state-deceeds-color'];
                      break;
                    default:
                      return this.item.exceedable ? this.customStyle['element-state-inrange-color'] || this.item.color : this.item.color;
                  }
                })
                .attr('cx', (d) => {
                  return this.chartElement._x(d.x)
                })
                .attr('cy', (d) => {
                  return this.chartElement._y(d.y)
                })
                .attr('title', (d) => {
                  return this.computeDate(d.x) + ' | ' + this.computeValue(d.y);
                })
                .on('mouseenter', function(d) {
                  this.setAttribute('r', self.dotRadius * 1.5);
                  self.chartElement._showInfo(d);
                })
                .on('mouseleave', function(d, i) {
                  this.setAttribute('r', self.dotRadius);
                  self.chartElement._hideInfo();
                })
                .on('click', (d) => {
                  var offset = this.dotRadius * 5;
                  var x = this.chartElement._x(d.x);
                  var y = this.chartElement._y(d.y);
                  d3.event.selection = [
                    [x - offset, y - offset],
                    [x + offset, y + offset]
                  ];
                  this.chartElement.brushed();
                });
              //  remove old dots
              dots.exit()
                  .remove();
          }
        });

        // performance.mark('graph redraw end');
        // performance.measure('graph redraw', 'graph redraw start', 'graph redraw end');
        // TODO(?): update line, animated http://bl.ocks.org/benjchristensen/1148374
      },

      _defined: function(d, i, data) {
        var domainX = this.chartElement._x.domain(),
            yScale = this.chartElement.yScale;

        if (d.y === null || isNaN(d.y))
          return undefined; // NaN and null are displayable
        else if (d.state !== 0)
          return true; // element is exceeding
        else if ((yScale === "ln" || yScale === 'log₁₀') && d.y <= 0)
          return undefined; // log- and sqrt-scales require larger than 0-Values
        else if ((d.x >= domainX[0] && d.x <= domainX[1]) || (i > 0 && i + 1 < data.length && (data[i + 1].x > domainX[0] && data[i - 1].x < domainX[1])))
          return true; // only numbers in x-Domain are shown (and their successor and predecessor) (graph is a function by definition, so y-Domain is not relevant)
        else
          return undefined;
      },

      setColor: function(color) {
        // random color if color is not set
        WebvisualBehaviors.ColorBehavior.setColor.call(this, color);
        if (this.chart) {
          if (this.lineNode && this.lineNode.attr) this.lineNode.attr('stroke', color);
          if (this.areaNode && this.areaNode.attr) this.lineNode.attr('fill', color);
          if (this.dots && this.dots.selectAll)
            this.dots.selectAll('circle.dot')
                     .attr('stroke', color);
        }
      },

      checkedChanged: function(checked, old) {
        WebvisualBehaviors.CheckedAndSelectBehavior.checkedChanged.call(this, checked, old);
        this.noDots = (!checked || (this.chartElement && this.chartElement.noDots))  ? true : false;
        this.noLine = (!checked || (this.chartElement && this.chartElement.noLines)) ? true : false;
        this.noFill = (!checked || (this.chartElement && this.chartElement.noAreas)) ? true : false;
        this._hidden = !checked;
      },

      _noDotsChanged: function() {
        if (this.dots && this.dots.attr) {
          this.dots.attr('hidden', this.noDots ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _noLineChanged: function() {
        if (this.lineNode && this.lineNode.attr) {
          this.lineNode.attr('hidden', this.noLine ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _noFillChanged: function() {
        if (this.areaNode && this.areaNode.attr) {
          this.areaNode.attr('hidden', this.noFill ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this.dots && this.dots.selectAll) {
          this.dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _interpolationChanged: function(interpolation) {
        var curve;
        switch (interpolation) {
          case 'Basis Spline':
            curve = d3.curveBasis;
            break;
          case 'Monotoner Spline':
            curve = d3.curveMonotoneX;
            break;
          case 'Kubischer Spline':
            curve = d3.curveNatural;
            break;
          case 'Cardinaler Spline':
            curve = d3.curveCardinal;
            break;
          case 'Catmull-Rom-Spline':
            curve = d3.curveCatmullRom;
            break;
          case 'Stufe (mitte)':
            curve = d3.curveStep;
            break;
          case 'Stufe (davor)':
            curve = d3.curveStepAfter;
            break;
          case 'Stufe (danach)':
            curve = d3.curveStepBefore;
            break;
          default:
            curve = d3.curveLinear;
            break;
        }
        this.line.curve(curve);
        this.area.curve(curve);

        if (this.chartElement && this.areaNode)
          this.redraw();
      }
    });
  </script>

</dom-module>
