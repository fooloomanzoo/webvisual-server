<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="behaviors/fullscreen-behavior.html"/>

<link rel="import" href="components/webvisual-icon-button.html"/>

<link rel="import" href="style/webvisual-element-styles.html"/>

<script type="text/javascript" src="../bower_components/d3/d3.min.js"></script>

<!--
'webvisual-element-svg' provides rendering a svg in a container.

#the svg has to have following specifications:
- all tranistions of the included paths must be relative
- there doesn"t have to be a ""matrix"" transformation on the top element (very important), else zoom transitions won"t work corviewly
- "view-box"-attribute has to be set
- the to top element of the svg has to be a plain g-element (look up grouping in svg) with no transformations on it

#how to achive this in Inkscape:
> 1. Double click the group in Inkscape, to enter it.
> 2. Select all the contents of the group by pressing Ctrl+A, and copy them with Ctrl+C.
> 3. Double click outside the group to leave the group.
> 4. Edit > Paste In Place (Ctrl+Alt+V) â€“ at this point, group transformations are applied to the obects you paste.
> 5. Group the objects again (Ctrl+G)
> 6. Move the new group to the same depth as the original, and delete the original group. (This is probably easier with the XML editor, Ctrl+Shift+X.)
<http://stackoverflow.com/a/22629215/5077914>

#about absolut positioning
<http://stackoverflow.com/a/26053262>

#reference and inspiration
<http://bl.ocks.org/mbostock/9656675>

@element webvisual-element-svg
-->

<dom-module id="webvisual-element-svg">
<template strip-whitespace>
  <style include="webvisual-element-styles">
    :host {
      border-radius: inherit;
      -webkit-overflow-scrolling: touch;
      -webkit-tap-highlight-color:rgba(0,0,0,0);
      display: block;
      position: relative;
      width: 100%;
      height: 100%;
      font-family: 'FiraSans-Regular';
      letter-spacing: normal;
      user-select: none !important;
      background-color: transparent;
      color: currentColor;
      isolation: isolate;
    }
    :host([opened]) {
      pointer-events: all;
    }
    :host([fullscreen]) {
      background-color: var(--fullscreen-background-color);
      max-height: 100% !important;
      max-width: 100% !important;
      height: 100% !important;
      width: 100% !important;
    }
    :host(:-webkit-full-screen) {
      background-color: var(--fullscreen-background-color);
    }
    svg {
      border-radius: inherit;
      user-select: none !important;
    }
    #svgContainer {
      border-radius: inherit;
      display: block;
      width: 100%;
      height: 100%;
    }
    #svgContainer svg {
      position: relative;
      width: 100%;
      height: 100%;
      display: block;
    }
    #control {
      position: absolute;
      bottom: 4px;
      right: 4px;
    }
    text {
      pointer-events: none !important;
      cursor: default !important;
      letter-spacing: normal !important;
      stroke: none !important;
      -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
      @apply(--svg-text);
      mix-blend-mode: exclusion;
    }
    .selectable {
      pointer-events: all;
      cursor: pointer;
      transform-origin: center center;
      -moz-transform-origin: 50% 50%;
      @apply(--svg-selectable);
    }
    .clicked {
      fill: #3852D7 !important;
      fill-opacity: 0.25;
      @apply(--svg-clicked);
    }
    .selected {
      fill-opacity: 0.75;
      stroke-opacity: 0.5 !important;
      @apply(--svg-selected);
    }
    .exceeding {
      stroke: #D95656;
      fill-opacity: 1;
      stroke-width: 2px;
      stroke-linecap: round;
      stroke-linejoin: round;
      transform-origin: center center;
      will-change: transform;
      animation-name: exceeding-animation;
      animation-duration: 2s;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
      @apply(--svg-exceeding);
    }
    @keyframes exceeding-animation {
      0% {
        transform: scale(1.0);
      }
      50% {
        fill: #D95656;
        transform: scale(0.8);
        -moz-transform: scale(1.0);
      }
      100% {
        transform: scale(1.0);
      }
    }
    webvisual-icon-button {
      mix-blend-mode: exclusion;
    }
    [hidden] {
      display: none !important;
    }

  </style>
  <div id="svgContainer"></div>
  <div id="control" >
    <webvisual-icon-button title="focus" icon="filter-center-focus" on-tap="_resetZoom"></webvisual-icon-button>
    <webvisual-icon-button title="fullscreen" icon="[[fullscreenIcon]]" on-tap="toggleFullscreen"></webvisual-icon-button>
  </div>

</template>

<script>
  SvgElement = Polymer({
    is: 'webvisual-element-svg',

    behaviors: [
      WebvisualBehaviors.FullscreenBehavior
    ],

    properties: {
      /**
       * url prefix to source url of svg document
       */
      urlPrefix: String,

      /**
       * source url of svg document
       */
      src: String,

      _recentSrc: {
        type: String
      },

      /**
       * class-attribute to add a selected Node
       */
      selectedClass: {
        type: String,
        value: 'selected'
      },
      /**
       * class-attribute to add a exceeding Node
       */
      exceedingClass: {
        type: String,
        value: 'exceeding'
      },
      /**
       * (css-like) selector of a initially zoomed Nodes
       */
      initial: {
        type: String,
        value: '',
        observer: '_initialChanged'
      },
      /**
       * If true, initially it is not zoomed to selected Nodes
       */
      initiallyZoomToAll: Boolean,
      /**
       * If true, webvisual-element-svg is shown
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        observer: '_openedChanged'
      },
      /**
       * Minimal Zoom Level
       */
      minZoom: {
        type: Number,
        value: 0.9
      },
      /**
       * Maximal Zoom Level
       */
      maxZoom: {
        type: Number,
        value: 5
      },
      /**
       * a clicked or selected Node will be centered and zoomed, depending how many times a zoomed Node,
       * would fit in the actual view
       */
      zoomPartition: {
        type: Number,
        value: 3
      },

      /**
       * selectable css-selectors (key as id, value as selector), so that an eventlistener can be attached
       */
      selectableItems: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * multi selectable
       */

      multi: Boolean,

      item: {
        type: Object,
        value: function() {
          return {};
        }
      },
      items: {
        type: Array,
        value: function() {
          return [];
        }
      },
      exceeding: {
        type: Array,
        value: function() {
          return [];
        }
      }

    },

    /**
     * {private} inititial viewBox-height
     */
    _height: 0,
    /**
     * {private} inititial viewBox-width
     */
    _width: 0,
    /**
     * {private} mayor <g></g>-Node (that should be all sourounding group in the Svg-Graphic)
     */
    _mainG: Object,
    /**
     * {private} svg-Node
     */
    _svg: Object,
    /**
     * {private} d3-zoom-behavior
     */
    _d3Zoom: Object,

    observers: [
      '_srcChanged(src, urlPrefix)',
      '_selectableItemsChanged(selectableItems)',
      '_selectedItemsChanged(item)',
      '_selectedItemsChanged(items.length)',
      '_exceedingChanged(exceeding.length)'
    ],

    listeners: {
      'contextmenu': '_resetZoom'
    },

    _openedChanged: function() {
      if (!this.src) return;
      this._srcChanged();
      if (!this._inialized)
        this._initialize();
      this.debounce('resetZoom', this._resetZoom, 1000);
    },

    open: function(e) {
      this.setSvg(e.detail);
      this.opened = true;
    },

    close: function() {
      this.opened = false;
    },

    _srcChanged: function(src, urlPrefix) {
      if (src && this._recentSrc !== src) {
        this._recentSrc = src;
        this._svg = d3.select(this.$.svgContainer).select('svg#main');
        if (this._svg && !this._svg.empty()) {
          this.$.svgContainer.removeChild(this._svg.node());
        }
        // import svg (came by data-socket-repeater)
        urlPrefix = urlPrefix || '/images/';
        this._fetchResource(urlPrefix + src)
            .then( this._registerXML.bind(this) )
            .catch( function(req) {
              console.log('Failed to read source\n', req);
            });
      }
    },

    _fetchResource: function(url) {
      return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function() {
          try {
            if (this.readyState === 4 && this.status < 400) {
              if (this.responseXML) {
                resolve(this.responseXML.documentElement);
              } else {
                reject(this);
              }
            }
          } catch (e) {
            console.log(e);
            return;
          }
        }.bind(req);
        req.open("GET", url);
        req.withCredentials = true;
        req.send();
      })
    },

    _registerXML: function(xml) {
      // import svg to document
      var svgNode = document.importNode(xml.cloneNode(true), true);
      // register zoom function
      this._d3Zoom = d3.zoom()
                       .scaleExtent([this.minZoom, this.maxZoom])
                       .on('zoom', this._zoom.bind(this));

      // append imported svg to this element
      this.$.svgContainer.insertBefore(svgNode, this.$.svgContainer.firstChild);
      this._svg = d3.select(svgNode).attr('id', 'main')
                                    .classed('style-scope', true)
                                    .classed('webvisual-element-svg', true);

      // set style for resizing
      this._svg.attr('preserveAspectRatio', 'xMinYMin meet')
               .attr('height', null)
               .attr('width', null)
               .call(this._d3Zoom);

      // All nodes needs to be grouped in one main group for zooming
      this._mainG = this._svg.select('g')
                             .attr('id', 'mainG');

      this._mainG.selectAll('text')
                 .classed('style-scope', true).classed('webvisual-element-svg', true); // style-scoping in polymer

      // get original dimensions
      if (this._svg.attr('viewBox')) {
        var viewBox = this._svg.attr('viewBox').split(' ');
        this._width  = viewBox[2] - viewBox[0];
        this._height = viewBox[3] - viewBox[1];
      }

      this._initialize();
    },

    _initialize: function() {
      this.async( this._selectableItemsChanged.bind(this), 100);
      this.debounce('select', this._selectSelected, 100);
      this.debounce('select-exceeds', this._selectExceeds, 100);
    },

    _selectedItemsChanged: function() {
      if ((this.item && Object.keys(this.item).length) || (this.items && this.items.length)) {
        if (!this.src) {
          if (this.item && this.item.svg && this.item.svg.path) {
            this.src = this.item.svg.path;
          } else if (this.items.length > 0 && this.items[this.items.length-1].svg && this.items[this.items.length-1].svg.path) {
            this.src = this.items[this.items.length-1].svg.path;
          }
        }
        this.opened = this.src && (this.opened || this.forceOpened || this.openOnSelect);
        this.debounce('select', this._selectSelected, 50);
      } else if (this._mainG && this._mainG.selectAll) {
        this._mainG.selectAll('.' + this.selectedClass)
                   .classed(this.selectedClass, false);
      }
    },

    _exceedingChanged: function() {
      if (this.exceeding && this.exceeding.length) {
        if (!this.src && this.exceeding[this.exceeding.length-1].svg && this.exceeding[this.exceeding.length-1].svg.path) {
          this.src = this.exceeding[this.exceeding.length-1].svg.path;
        }
        this.opened = this.src && (this.opened || this.forceOpened || this.openOnExceed);
        this.debounce('select-exceeds', this._selectExceeds, 50);
      } else if (this._mainG && this._mainG.selectAll) {
        this._mainG.selectAll('.' + this.exceedingClass)
                   .classed(this.exceedingClass, false);
      }
    },

    _initialChanged: function(initial) {
      if (!this.src || !initial) return;
      this.debounce('resetZoom', this._resetZoom, 250);
    },

    _selectableItemsChanged: function() {
      if (!this._mainG.node || !this.src) return;

      if (this.selectableItems && this.selectableItems.items) {
        var self = this;
        for (var key in this.selectableItems.items) {
          this._mainG.selectAll(this.selectableItems.items[key])
                    .classed('selectable', true)  // for styling selectable
                    .classed('style-scope', true).classed('webvisual-element-svg', true) // for style-scoping in polymer
                    .attr('title', key)
                    .on('click',
                      function() {
                        d3.event.stopPropagation();
                        self._zoomToElement(this);
                        var clicked = this.classList.contains('clicked');
                        self._mainG.selectAll('.clicked')
                                   .classed('clicked', false);
                        if (!clicked) {
                          this.classList.add('clicked');
                        }
                      });
        }
        this._inialized = true;
      }
    },

    _zoom: function () {
      // if (isNaN(d3.event.transform.x) || isNaN(d3.event.transform.y) || isNaN(d3.event.transform.k)) return;
      this._mainG.attr('transform', d3.event.transform);
    },

    _zoomToElement: function(elem) {
      if (elem === undefined || !this._svg.node()) return;
      // calc centered zoom coordinates
      var transform = this._calcCenterZoom(elem);
      var t = d3.zoomIdentity.translate(transform.x, transform.y).scale(transform.k);

      // call transition to new translate and scale
      this._mainG.transition()
                 .duration(300)
                 .attr('transform', t);

      // save last transition
      this._svg.node().__zoom = t;
    },

    _selectSelected: function() {
      var sel = this.multi ? (this.items || []) : [];
      if (this.item && Object.keys(this.item).length && sel.indexOf(this.item) === -1)
        sel.push(this.item);
      if (sel && sel.length) {
        for (var i = 0; i < sel.length; i++) {
          if (sel[i] && sel[i].color && sel[i].svg && sel[i].svg.selector) {
            var style; // Use elements color as fill-color by creating a CSS rule
            if (this.shadowRoot) { // shadowDOM
              style = this.shadowRoot.querySelector('style');
            } else {
              var scopeName; // shadyDOM
              Array.prototype.forEach.call(this.classList, function(cl) {
                if (cl.startsWith('webvisual-element-svg')) {
                  scopeName = cl;
                }
              })
              style = document.querySelector('style[scope="'+scopeName+'"]');
            }
            // Add to StyleSheet
            if (style && style.sheet && style.sheet.insertRule) {
              var selector = sel[i].svg.selector.split(',');
              for (var j = 0; j < selector.length; j++) {
                style.sheet.insertRule(selector[j] + '.' + this.selectedClass + ' {\nfill: ' + sel[i].color + ' !important;\n}', style.sheet.cssRules.length);
              }

            }
          }
        }
        this.updateStyles();
        this.select(sel, this.selectedClass);
      }
    },

    _selectExceeds: function() {
      if (this.exceeding && this.exceeding.length)
        this.select(this.exceeding, this.exceedingClass);
    },

    select: function(selected, selectedClass) {
      if (!this._mainG.node || !this.src) return;
      // previous selected elements: remove class for selected elements
      this._mainG = this._svg.select('g');
      this._mainG.selectAll('.' + selectedClass)
                 .classed(selectedClass, false);
      var elems;
      var sel = [];
      if (Array.isArray(selected)) {
        for (var i = 0; i < selected.length; i++) {
          if (selected[i].svg && selected[i].svg.selector)
            sel.push(selected[i].svg.selector);
        }
        sel = sel.join(',');
      } else {
        if (selected && selected.svg && selected.svg.selector)
          sel = selected.svg.selector;
        else
          sel = '';
      }
      if (sel === '' ||
          (elems = this._mainG.selectAll(sel)).classed(selectedClass, true).empty()) {
        // if (this.opened) {
        //   this.debounce('resetZoom', this._resetZoom, 33);
        // }
        return;
      }

      var boundE, bounds = [];
      var self = this;
      elems.each(
             function() {
               boundE = this.getBoundingClientRect();
               bounds[0] = (bounds[0] > boundE.left ? boundE.left : bounds[0]) || boundE.left;
               bounds[1] = (bounds[1] > boundE.top ? boundE.top : bounds[1]) || boundE.top;
               bounds[2] = (bounds[2] < boundE.right ? boundE.right : bounds[2]) || boundE.right;
               bounds[3] = (bounds[3] < boundE.bottom ? boundE.bottom : bounds[3]) || boundE.bottom;
             });

      boundE = { left: bounds[0],
                 top: bounds[1],
                 height: bounds[3] - bounds[1],
                 width: bounds[2] - bounds[0] };

      if (this.opened)
        this._zoomToElement(boundE);
    },

    _calcCenterZoom: function(elem) {
      // get view height and width
      var view = this.getClientRects()[0];
      if (view === undefined || elem === undefined || view.height === 0 || view.width === 0)
        return {x: 0, y: 0, k: 1};

      // calculate scale based on partioned view and dimensions of the element
      var boundE, bboxE, ratio = view.width/view.height;
      if (elem.nodeType !== undefined)
        boundE = elem.getBoundingClientRect();
      else boundE = elem;

      var bboxG = this._mainG.node().getBBox();
      var boundG = this._mainG.node().getBoundingClientRect();

      // absolute position (for angled or transioned element)
      var vs = bboxG.width/boundG.width || 1; // view scale
      var x = (boundE.left - boundG.left)*vs + bboxG.x;
      var y = (boundE.top - boundG.top)*vs + bboxG.y;

      // calculate zoom based on partions or minZoom or maxZoom
      // scaling and centering
      // view height/width in comparison tho viewboxheight/-width is important because of resizing by the browser

      // if (ratio > 1) {
        var scale = Math.max(this._width/(this.zoomPartition*vs*boundE.width), this._height/(this.zoomPartition*vs*boundE.height));
      // } else {
      //   var scale = Math.max(this._width/(this.zoomPartition*vs*boundE.width), this._height/(this.zoomPartition*vs*boundE.height));
      // }

      if (scale < this.minZoom) scale = this.minZoom;
      else if (scale > this.maxZoom) scale = this.maxZoom;

      if (ratio > this._width/this._height) {
        x = -scale*x + (this._height*ratio - scale*boundE.width*vs)/2;
        y = -scale*y + (this._height - scale*boundE.height*vs)/2;
      }
      else {
        x = -scale*x + (this._width - scale*boundE.width*vs)/2;
        y = -scale*y + (this._width/ratio - scale*boundE.height*vs)/2;
      }

      if (isNaN(x) || isNaN(y) || isNaN(scale))
        return {x: 0, y: 0, k: 1};
      else
        return {x: x, y: y, k: scale};
    },

    _resetZoom: function(e) {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      if (!this.opened || !this._mainG || !this._mainG.node) return;

      // zoom to selectedItems
      if (!this.initiallyZoomToAll) {
        if (this.item && Object.keys(this.item).length || (this.items && this.items.length)) {
          this.debounce('select', this._selectSelected, 50);
          return;
        }
        if (this.exceeding.length) {
          this.debounce('select-exceeds', this._selectExceeds, 50);
          return;
        }
      }
      // zoom to initial
      if (this.initial) {
        var initial;
        if (!(initial = this._mainG.selectAll(this.initial)).empty()) {
          this.select([{svg: { selector: this.initial }}], 'initial');
          return;
        }
      }
      // zomm to _mainG
      this._zoomToElement(this._mainG.node());
    },

    _fullScreenChanged: function() {
      WebvisualBehaviors.FullscreenBehavior._fullScreenChanged.call(this);
      if (this.isFullscreen) {
        if (!this._old) {
          this._old = { zoomPartition: this.zoomPartition,
                        maxZoom: this.maxZoom,
                        minZoom: this.minZoom }
        }
        this.zoomPartition *= 6;
        this.maxZoom *= 1.25;
        this.minZoom = 0.98;
      } else if (this._old) {
        this.zoomPartition = this._old.zoomPartition;
        this.maxZoom = this._old.maxZoom;
        this.minZoom = this._old.minZoom;
      }
      this.debounce('resetZoom', this._resetZoom, 500);
    }
  });
</script>

<dom-module>
