<!-- Using d3.js-library -->

<dom-module id='chart-element'>
  <template>
    <style>
      :host {
        display: inline-flex;
				padding: 4px;
        width: 100%;
        height: 100%;
        flex: 1;
        position: relative;
        align-self: stretch;
        box-sizing: border-box;
        font-family: inherit;
        color: currentColor;
        letter-spacing: normal !important;
        border-radius: inherit;
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
        -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
        /*overflow: hidden;*/
        visibility: visible;
        -webkit-touch-callout: none !important;
          -webkit-user-select: none !important;
           -khtml-user-select: none !important;
             -moz-user-select: none !important;
              -ms-user-select: none !important;
                  user-select: none !important;
      }
      #svgContainer {
        display: inline-flex;
        flex: 1;
        position: relative;
      }
      #svgchart {
        width: 100%;
        height: auto;
        position: relative;
      }
      button-element, radio-button-element {
        padding: 0.5em;
        float: left;
        clear: both;
        width: 100%;
        border-radius: 0px;
      }
      button-element {
        font-size: 0.7em;
      }
      radio-button-element {
        margin-top: 0.2em;
        margin-bottom: 0.2em;
        --radio-button-checked-color: var(--bright-primary-color);
        --radio-button-unchecked-color: #bbb;
      }
      dropdown-element {
        --dropdown-background: rgba(255, 255, 255, 0.75);
      }
      dropdown-element#legend {
        --dropdown-background: rgba(255, 255, 255, 0.5);
      }
      graph-element {
        padding: 0.25em;
      }
      icon-button-element {
        position: absolute;
        opacity: 0.4;
        --iron-icon-width: 20px;
        --iron-icon-height: 20px;
        transition: opacity 150ms ease;
      }
      icon-button-element:hover {
        opacity: 1;
        border-radius: 3px;
      }
      #xbutton {
        left: auto; right: 16px; top: auto; bottom: 0;
      }
      #ybutton {
        left: 0; right: auto; top: 8px; bottom: auto;
      }
      #zoombutton {
        left: auto; right: 16px; top: 8px; bottom: auto;
      }
      #optionsbutton {
        left: 0; right: auto; top: auto; bottom: 0;
      }
      #legendbutton {
        left: auto; right: 52px; top: 8px; bottom: auto;
      }
      text {
        fill: currentColor;
        pointer-events: none;
        font-weight: normal; !important;
        letter-spacing: normal !important;
        /*@apply(--font-common-base);*/
        font-family: sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
        pointer-events: none;
      }
      g#chart g.axis {
        font-size: inherit;
      }
      g#chart text {
        font-size: 0.55em;
      }
      g#chart rect.plot {
        fill: white;
        fill-opacity: 0.7;
        stroke: currentColor;
        stroke-opacity: 0.25;
        shape-rendering: crispEdges;
        stroke-width: 1px;
      }
      g#brush rect.overlay {
        cursor: default;
      }
      g#brush rect.selection {
        stroke: #345475;
        fill: #111;
        stroke-opacity: 0.5;
        fill-opacity: 0.05;
      }
      g.grid g.tick line {
        stroke: currentColor;
        stroke-opacity: 0.1;
      }
      g.grid path {
        stroke-width: 0;
      }
      g.axis path, g.axis line {
        fill: none;
        stroke: currentColor;
        stroke-opacity: 0.25;
        stroke-width: 1.5px;
      }
      g#chart g.axis path, g#chart g.axis line {
        stroke-opacity: 0.5;
      }
      g#graphs path.area, g#graphs path.line {
        pointer-events: none;
        mix-blend-mode: color;
      }
      g#graphs circle {
        cursor: pointer;
        pointer-events: all;
        transform-origin: center;
      }
      g#zoom rect.overlay {
        fill: none;
        fill-opacity: 0.1;
        pointer-events: none;
        stroke-width: 0;
      }
      g#zoom rect.overlay.active {
        pointer-events: all;
        fill: #8B5F45;
        cursor: zoom-in;
        stroke: #1f1f1f;
        stroke-opacity: 0.3;
        stroke-width: 1px;
      }
      g#focus line.focus.line {
        fill: none;
        pointer-events: none;
        stroke: white;
        stroke-opacity: 0.2;
        stroke-width: 1px;
        stroke-dasharray: 2;
        mix-blend-mode: color-burn;
      }
      [hidden] {
        display: none !important;
      }
      g.axis, g.grid, g#focus, rect.plot {
        pointer-events: none;
      }
    </style>

    <div id="svgContainer">
      <svg id='svgchart' version='1.1' xmlns='http://www.w3.org/2000/svg'>
        <g id='chart'>
          <clipPath id='clip'>
            <rect x='0' y='0'></rect>
          </clipPath>
          <rect class='plot'></rect>
          <g class='x axis'></g>
          <g class='y axis'></g>
          <g class='x grid'></g>
          <g class='y grid'></g>
          <g id='brush'></g>
          <g id='focus' hidden>
            <line class='focus line x' x1='0'></line>
            <line class='focus line y'></line>
          </g>
          <g id='graphs'>
            <g id='areas'></g>
            <g id='lines'></g>
            <g id='dots'></g>
          </g>
          <text id='info' x='0' y='0' hidden></text>
          <g id='zoom'>
            <rect class='overlay' x="0.5" y="0.5"></rect>
          </g>
        </g>
      </svg>

      <icon-button-element id="zoombutton" icon="search" on-tap="_startZoomSession"></icon-button-element>

		  <icon-button-element id="legendbutton" icon="timeline"></icon-button-element>
		  <dropdown-element id="legend" for="legendbutton" target-toggle-event="tap" hiding-event="" position="bottom" align="center">
		    <content id='collector' select='graph-element'></content>
		    <template is="dom-repeat" items="[[selectedElements]]">
		      <graph-element data-id="[[item.dataId]]" data-label="[[item.dataLabel]]" data-keys="[[item.dataKeys]]" grouped-key="[[item.groupedKey]]" color="[[item.color]]" interpolation="[[interpolation]]">
		      </graph-element>
		    </template>
		  </dropdown-element>

		  <icon-button-element id="optionsbutton" icon="juelich:app-inverted"></icon-button-element>
		  <dropdown-element for="optionsbutton" target-toggle-event="tap" position="right" align="outer-start" offset="10">
		    <radio-button-element checked="[[!noDots]]" on-change="changeDots">mit Punkten</radio-button-element>
		    <radio-button-element checked="[[!noLines]]" on-change="changeLines">mit Linien</radio-button-element>
		    <radio-button-element checked="[[!noAreas]]" on-change="changeAreas">mit Flächen</radio-button-element>
		  </dropdown-element>

		  <icon-button-element id="ybutton" icon="y"></icon-button-element>
		  <dropdown-element for="ybutton" target-toggle-event="tap" position="right" align="start" offset="10">
		    <iron-selector attr-for-selected="scale" selected="{{yScale}}" fallback-selection="linear" toggles>
		      <button-element scale='linear'>linear</button-element>
		      <button-element scale='√'>√</button-element>
		      <button-element scale='ln'>ln</button-element>
		      <button-element scale='log₁₀'>log₁₀</button-element>
		    </iron-selector>
		  </dropdown-element>

		  <icon-button-element id="xbutton" icon="x"></icon-button-element>
		  <dropdown-element for="xbutton" target-toggle-event="tap" position="top" align="end" offset="1">
		    <iron-selector attr-for-selected="interpolate" selected="{{interpolation}}" fallback-selection="Lineare Verbindung" toggles>
		      <button-element interpolate='Lineare Verbindung'>Lineare Verbindung</button-element>
		      <button-element interpolate='Basis Spline'>Basis Spline</button-element>
		      <button-element interpolate='Monotoner Spline'>Monotoner Spline</button-element>
		      <button-element interpolate='Kubischer Spline'>Kubischer Spline</button-element>
		      <button-element interpolate='Cardinaler Spline'>Cardinaler Spline</button-element>
		      <button-element interpolate='Catmull-Rom-Spline'>Catmull-Rom-Spline</button-element>
		      <button-element interpolate='Stufe (mitte)'>Stufe (mitte)</button-element>
		      <button-element interpolate='Stufe (davor)'>Stufe (davor)</button-element>
		      <button-element interpolate='Stufe (danach)'>Stufe (danach)</button-element>
		    </iron-selector>
		  </dropdown-element>

  	</div>

  </template>

  <script>
    d3.timeFormatDefaultLocale({
      'dateTime': '%x %X',
      'date': '%d.%m.%Y',
      'time': '%H:%M:%S',
      'periods': ['', ''],
      'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
      'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
      'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
    });
    d3.formatDefaultLocale({
      "decimal": ",",
      "thousands": ".",
      "grouping": [3],
      "currency": ["", "\u00a0€"]
    });
    ChartElement = Polymer({
      is: 'chart-element',

      behaviors: [
        Polymer.IronResizableBehavior,
        ContainerBehavior
      ],

      properties: {
        notify: {
          type: Boolean,
          value: false
        },
        notifyParent: {
          type: Boolean,
          value: false
        },
        noSelectNotify: {
          type: Boolean,
          value: false
        },
        noExceedNotify: {
          type: Boolean,
          value: false
        },

        multiSelect: {
          type: Boolean,
          value: true
        },
        toggles: {
          type: Boolean,
          value: true
        },

        reproduce: {
          type: Boolean,
          value: true
        },
        reproductionContainer: {
          type: String,
          value: 'legend',
          readOnly: true
        },

        gridMult: {
          type: Number,
          value: 2
        },
        xScale: {
          type: String,
          value: 'time',
          observer: 'changeScale'
        },
        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },
        interpolation: {
          type: String,
          value: 'Lineare Verbindung',
          observer: 'changeInterpolation'
        },
        noDots: {
          type: Boolean,
          value: false
        },
        noLines: {
          type: Boolean,
          value: false
        },
        noAreas: {
          type: Boolean,
          value: false
        }
      },

      _width: 0,
      _height: 0,

      _margin: {
        top: 8,
        right: 16,
        bottom: 36,
        left: 44
      },

      _chart: Object,
      _svg: Object,

      _x: Function,
      _y: Function,

      _xAxis: Object,
      _yAxis: Object,
      _xGrid: Object,
      _yGrid: Object,

      _brush: Object,
      _brushBehavior: Object,
      _isBrushed: false,
      _isZoomed: false,

      _info: Object,
      _focus: Object,
      _focusX: Object,
      _focusY: Object,
      _zoomOverlay: Object,

      formatMillisecond: Function,
      formatSecond: Function,
      formatMinute: Function,
      formatHour: Function,
      formatDay: Function,
      formatWeek: Function,
      formatMonth: Function,
      formatYear: Function,

      get _self() {
        return this;
      },

      get _parent() {
        if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return this.parentNode.host;
        }
        return this.parentNode;
      },

      listeners: {
        'iron-resize': '_sizeChanged'
      },

      observers: [
        'redraw(selectedElements.length)'
      ],

      created: function() {
        this.formatMillisecond = d3.timeFormat(":%S,%L");
        this.formatLongSecond = d3.timeFormat(":%M:%S,%L");
        this.formatSecond = d3.timeFormat(":%M:%S");
        this.formatLongMinute = d3.timeFormat("%H:%M:%S");
        this.formatMinute = d3.timeFormat("%H:%M");
        this.formatHour = d3.timeFormat("%X");
        this.formatDay = d3.timeFormat("%d.%m");
        this.formatWeek = d3.timeFormat("%d.%m");
        this.formatMonth = d3.timeFormat("%d. %b");
        this.formatYear = d3.timeFormat("%Y");
      },

      ready: function() {
        this._buildLayout();
      },

      _onNeonAnimationFinish: function() {
        this._sizeChanged();
      },

      _sizeChanged: function(e) {
        this.debounce("resize", this._sizeLayout, 25);
      },

      _buildLayout: function() {
        // performance.mark('build start');
        this.assignParentResizable(this.rootElement);

        this._svg = d3.select(this.$.svgchart).attr('preserveAspectRatio', 'xMinYMin meet')
          .attr('height', null)
          .attr('width', null);
        this._x = this._createScale(this.xScale);
        this._y = this._createScale(this.yScale);

        this._chart = d3.select(this.$.chart);

        this._graphs = d3.select(this.$.graphs)
          .attr('clip-path', 'url(#clip)');

        this._brushBehavior = d3.brush()
          .on('end', this._brushed.bind(this._self));
        this._brush = d3.select(this.$.brush)
          .attr('clip-path', 'url(#clip)');

        this._info = d3.select(this.$.info);
        this._focus = d3.select(this.$.focus)
          .attr('clip-path', 'url(#clip)');
        this._focusX = this._focus.select('line.focus.line.x')
          .attr('clip-path', 'url(#clip)');
        this._focusY = this._focus.select('line.focus.line.y')
          .attr('clip-path', 'url(#clip)');
        this._zoomOverlay = d3.select(this.$.zoom).select('rect.overlay')
          .attr('clip-path', 'url(#clip)')
          .on('click', function(d, i) {
            var offset = Math.floor(Math.min(this._height, this._width) / 5);
            var x = d3.event.offsetX - this._margin.left;
            var y = d3.event.offsetY - this._margin.top;
            d3.event.selection = [
              [x - offset, y - offset],
              [x + offset, y + offset]
            ];
            this._brushed();
          }.bind(this))
          .on('touchmove', this._resetZoom.bind(this));

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('chart-element', true);

        this._svg.on('contextmenu', this._resetZoom.bind(this));
        // performance.mark('build end');
        // performance.measure('build', 'build start', 'build end');
        this._sizeChanged();
      },

      _sizeLayout: function() {
        // performance.mark('size start');
        var bRect = this.$.svgchart.getBoundingClientRect();
        if (bRect.height === 0 || bRect.width === 0) return;

        this._height = Math.max(bRect.height, 150);
        this._width = Math.max(bRect.width, 250);

        // this._svg.attr('height', this._height)
        //          .attr('width', this._width);

        this._width = this._width - this._margin.left - this._margin.right;
        this._height = this._height - this._margin.bottom - this._margin.top;

        this.xTicks = Math.ceil(this._width / 150);
        this.yTicks = Math.ceil(this._height / 50);

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this._chart.attr('transform', 'translate(' + this._margin.left + ',' + (this._margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.select('clipPath#clip rect')
          .attr('width', this._width)
          .attr('height', this._height);

        this._chart.select('rect.plot')
          .attr('width', this._width)
          .attr('height', this._height);

        this._zoomOverlay
          .attr('width', this._width - 1)
          .attr('height', this._height - 1);

        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);

        this._xGrid = this._createAxis(this._x, 'bottom', this.xScale, this.gridMult)
          .tickSize(-this._height, 0, 0)
          .tickFormat('');
        this._yGrid = this._createAxis(this._y, 'left', this.yScale, this.gridMult)
          .tickSize(-this._width, 0, 0)
          .tickFormat('');

        this._chart.select('g.x.axis')
          .call(this._xAxis)
          .attr('transform', 'translate(0,' + this._height + ')');
        this._chart.select('g.y.axis')
          .call(this._yAxis)
          .attr('transform', 'translate(0,' + 0 + ')');
        this._chart.select('g.x.grid')
          .attr('transform', 'translate(0,' + this._height + ')')
          .call(this._xGrid);
        this._chart.select('g.y.grid')
          .call(this._yGrid)
          .attr('transform', 'translate(0,' + 0 + ')');;

        this._brushBehavior.extent([
          [0, 0],
          [this._width, this._height]
        ])
        this._brush.call(this._brushBehavior);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('chart-element', true);
        this._focusY.attr('y1', this._height);
        // performance.mark('size end');
        // performance.measure('size', 'size start', 'size end');
        this._redraw();
      },

      _createScale: function(option) {
        switch (option) {
          case 'time':
            return d3.scaleTime();
            break;
          case 'ln':
            return d3.scaleLog().base(Math.E);
            break;
          case 'log₁₀':
            return d3.scaleLog();
            break;
          case '√':
            return d3.scaleSqrt();
            break;
          default:
            return d3.scaleLinear();
        }
      },

      _createAxis: function(scale, orient, kind, tickmult) {
        var axis, ticks, horTicks, verTicks;
        tickmult = tickmult || 1;

        switch (orient) {
          case 'top':
            axis = d3.axisTop();
            ticks = this.xTicks;
            break;
          case 'bottom':
            axis = d3.axisBottom();
            ticks = this.xTicks;
            break;
          case 'left':
            axis = d3.axisLeft();
            ticks = this.yTicks;
            break;
          case 'right':
            axis = d3.axisRight();
            ticks = this.yTicks;
            break;
        }
        axis.scale(scale).ticks(ticks * tickmult);
        if (kind === "time")
          axis.ticks(ticks * tickmult)
          .tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat(function(d) {
            return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
          })

        return axis;
      },

      timeFormat: function(date) {
        return (d3.timeSecond(date) < date ? this.formatMillisecond :
          d3.timeMinute(date) < date ? this.formatSecond :
          d3.timeHour(date) < date ? this.formatMinute :
          d3.timeDay(date) < date ? this.formatHour :
          d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.formatDay : this.formatWeek) :
          d3.timeYear(date) < date ? this.formatMonth :
          this.formatYear)(date);
      },
      timeFormatRange: function(date, r, pixels) {
        var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
        return (rangeRatio < 100 ? this.formatMillisecond :
          rangeRatio < 500 ? this.formatLongSecond :
          rangeRatio < 5000 ? this.formatSecond :
          rangeRatio < 20000 ? this.formatLongMinute :
          rangeRatio < 60000 ? this.formatMinute :
          rangeRatio < 3600000 ? this.formatHour :
          rangeRatio < 86400000 ? this.formatDay :
          rangeRatio < 604800000 ? this.formatWeek :
          rangeRatio < 2419200000 ? this.formatMonth :
          this.formatYear)(date);
      },

      redraw: function() {
        if (this._chart === undefined || this._chart.select === undefined) return;
        this._debouncedSetDomains();
        this._debouncedRedraw();
      },

      _debouncedSetDomains: function() {
        this.debounce('domains', this._setDomains, 33);
      },

      _debouncedRedraw: function() {
        this.debounce('redraw', this._redraw, 33);
      },

      _redraw: function() {
        if (this._chart === undefined || this._chart.select === undefined) return;
        if (this._elements.length > 0) {
          this._elements.forEach(function(g) {
            // performance.mark('start');
            if (g.redraw)
              g.redraw();
            // performance.mark('end');
            // performance.measure(g.dataId, 'start', 'end');
          });
          // p = performance.getEntriesByType("measure");
          //   for (var i=0; i < p.length; i++) {
          //     console.log ("performance.measure " + p[i].name +
          //         //  " startTime = " + p[i].startTime +
          //          " duration  = " + p[i].duration);
          //   }
          // performance.clearMarks();
          // performance.clearMeasures();
        }

        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._chart.select('g.x.grid').transition(50).call(this._xGrid);
        this._chart.select('g.y.grid').transition(50).call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('chart-element', true);
        this._updateInfo();
        // this._hideInfo();
      },

      _brushed: function() {
        var s = d3.event.selection;
        if (s) {
          this._isBrushed = true;
          this._isZoomed = true;
          this._x.domain([s[0][0], s[1][0]].map(this._x.invert, this._x)).nice(this.xTicks);
          this._y.domain([s[1][1], s[0][1]].map(this._y.invert, this._y)).nice(this.yTicks);
          this._brush.call(this._brushBehavior.move, null);
          return;
        } else if (this._isBrushed === true) {
          this._isBrushed = false;
        } else {
          this._isZoomed = false;
          this._setDomains();
        }
        this._redraw();
      },

      _setDomains: function() {
        if (this._elements.length === 0 || this._isZoomed === true) return;

        var domainX = [null, null],
          domainY = [null, null],
          v, yScale = this.yScale,
          range, rangedValues, containing = {};

        this._elements.forEach(function(g) {
          if (g.dataId && g.dataLabel) {
            if (containing[g.dataLabel] === undefined)
              containing[g.dataLabel] = [];
            if (containing[g.dataLabel].indexOf(g.dataId) === -1)
              containing[g.dataLabel].push(g.dataId)
          }
        });

        for (var label in containing) {
          if (containing[label].length > 0) {
            range = window.Cache[label].range(containing[label]);
            domainX[0] = (domainX[0] === null || range[0] < domainX[0]) ? range[0] : domainX[0];
            domainX[1] = (domainX[1] === null || range[1] > domainX[1]) ? range[1] : domainX[1];

            rangedValues = window.Cache[label].rangedValues(containing[label], 'y');
            domainY[0] = (domainY[0] === null || rangedValues[0] < domainY[0]) ? rangedValues[0] : domainY[0];
            domainY[1] = (domainY[1] === null || rangedValues[1] > domainY[1]) ? rangedValues[1] : domainY[1];
          }
        }

        if (this.yScale === "√" || this.yScale === "ln" || this.yScale === "log₁₀") {
          if (domainY[0] <= 0) {
            domainY[0] = 1e-15;
          }
          if (domainY[1] <= 0) {
            domainY[1] = 1e-15;
          }
        }

        // rounding y-domains to the according decimal exponent
        if (domainY[0] === domainY[1] && domainY[0] && domainY[1]) {
          v = (domainY[0]).toExponential().split('e');
          domainY[0] = (Math.floor(v[0])) * Math.pow(10, parseInt(v[1], 10));
          v = (domainY[1]).toExponential().split('e');
          domainY[1] = (Math.ceil(v[0])) * Math.pow(10, parseInt(v[1], 10));
        }
        this._x.domain(domainX);
        this._y.domain(domainY).nice(this.yTicks);

      },
      _showInfo: function(d) {
        this.cancelDebouncer('hideinfo');
        var x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
        this._info.text(x + ' , ' + d.y);
        this._info.x = d.x;
        this._info.y = d.y;
        this._info.attr('hidden', null);
        this._focus.transition(33).attr('hidden', null);
        this._updateInfo();
      },
      _hideInfo: function() {
        this.debounce('hideinfo', this._debounceHideInfo, 750);
      },
      _debounceHideInfo: function() {
        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);
        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._info.transition(33).attr('hidden', '');
        this._focus.transition(33).attr('hidden', '');
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('chart-element', true);
      },
      _updateInfo: function() {
        if (this._info.attr('hidden') === "true" || this._info.x === undefined || this._info.y === undefined) return;
        var bbox = this._info.node().getBBox();
        // console.log(bbox, this._width, this._height);
        var x = this._x(this._info.x),
          y = this._y(this._info.y);
        this._info.transition(33)
          .attr('x', (x + 4 + bbox.width > this._width ? (x - 4 - bbox.width < 0 ? 0 : x - 4 - bbox.width) : x + 4))
          .attr('y', (y > bbox.height + 4 ? y - 4 : bbox.height));
        this._focusX.transition(33)
          .attr('x2', x)
          .attr('y2', y)
          .attr('y1', y);
        this._focusY.transition(33)
          .attr('y2', y)
          .attr('x2', x)
          .attr('x1', x);

        this._xAxis.tickValues([this._info.x]);
        this._yAxis.tickValues([this._info.y]);
        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._svg.selectAll('g,line,text,path,rect')
          .classed('style-scope', true)
          .classed('chart-element', true);
      },
      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        } else {
          this.$.menu.setAttribute('hidden', '');
        }
      },
      changeInterpolation: function(interpolation, oldValue) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.interpolation = interpolation;
          });
      },
      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        if (this._isZoomed === false) {
          this._setDomains();
        }
        var domainX = this._x.domain();
        var domainY = this._y.domain();
        if (this.yScale === "√" || this.yScale === "ln" || this.yScale === "log₁₀") {
          if (domainY[0] <= 0) {
            domainY[0] = 1e-15;
          }
          if (domainY[1] <= 0) {
            domainY[1] = 1e-15;
          }
        }
        this._buildLayout();
        this._sizeLayout();
        this._x.domain(domainX);
        this._y.domain(domainY).nice(this.yTicks);
        this._redraw();
      },
      changeDots: function(e) {
        this.noDots = !e.target.checked;
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noDots', !e.target.checked)
          });
      },
      changeLines: function(e) {
        this.noLines = !e.target.checked;
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noLine', !e.target.checked)
          });
      },
      changeAreas: function(e) {
        this.noAreas = !e.target.checked;
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noFill', !e.target.checked)
          });
      },
      _startZoomSession: function() {
        if (this._zoomOverlay.classed('active')) {
          this._zoomOverlay.classed('active', null);
        } else {
          this._zoomOverlay.classed('active', true);
        }
      },
      _resetZoom: function() {
        if (d3.event)
          d3.event.preventDefault();
        this._isZoomed = false;
        this.redraw();
      }
    });
  </script>

</dom-module>
