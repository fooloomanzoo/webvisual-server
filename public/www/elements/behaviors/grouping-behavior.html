<script>
  GroupingBehaviorImpl = {

    properties: {
      animatable: {
        type: Boolean
      },

      animationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 1500,
            fill: 'forwards'
          };
        }
      },

      animationConfig: {
        type: Object,
        value: function() {
          return {};
        }
      },
      groupedKey: {
        type: String,
        value: '',
        observer: 'regroup'
      }
    },

    attached: function() {
    },

    regroup: function(groupedKey, old) {
      const label = this.getAttribute('label');

      if (!label || !groupedKey || !Groups[label] || !Groups[label][groupedKey] || PreferedGroupingKeys[groupedKey] === groupedKey)
        return;

      let oldgroups = this.queryAllEffectiveChildren('group-card');
      let elements = {};

      for (let i in oldgroups) {
        Array.prototype.forEach.call(oldgroups[i].querySelectorAll('[element]'), function(elem) {
          elem.oldBounds = elem.getBoundingClientRect();
          elements[elem.id] = elem;
        });
      }

      if (oldgroups.length === 0 || elements.length === 0) return;

      let id, index = 0, currentgroup;
      const subgroups = Groups[label][groupedKey];
      PreferedGroupingKeys[label] = groupedKey;

      this.animationConfig['group-transition'] = [];

      if (this.animatable) {
        for (let id in elements) {
          this.animationConfig['group-transition'].push( {
            name: 'attribute-animation',
            node: elements[id],
            timing: this.animationTiming
          })
        }
      }

      for (let subgroup in subgroups) {
        if (oldgroups[index]) {
          oldgroups[index].title = subgroup;
          oldgroups[index].svg = subgroups[subgroup].svg;
          currentgroup = oldgroups[index];
        } else {
          currentgroup = new GroupCard(subgroup, subgroups[subgroup].svg);
          this.appendChild(currentgroup);
        }
        for (let i in subgroups[subgroup].ids) {
          id = Groups[label][groupedKey][subgroup].ids[i];
          elements[id].groupedKey = groupedKey;
          elements[id].style.order = '';
          currentgroup.appendChild(elements[id]);
        }
        index++;
      }
      for (let i = index; i < oldgroups.length; i++) {
        Polymer.dom(this).removeChild(oldgroups[i]);
      }

      if (this.animatable) {
        this.playAnimation('group-transition');
      }
    }
  };

  GroupingBehavior = [
    Polymer.NeonAnimationRunnerBehavior,
    GroupingBehaviorImpl
  ];
</script>
