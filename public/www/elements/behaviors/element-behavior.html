<script>
  ElementBehavior = {

    properties: {
      dataId: {
        type: String,
        reflectToAttribute: true
      },
      dataLabel: {
        type: String,
        reflectToAttribute: true
      },
      dataKeys: {
        type: Object,
        value: function() {
          return {};
        }
      },
      groupedKey: {
        type: String,
        value: ''
      },

      newestDataFirst: {
        type: Boolean,
        value: false
      },

      firstStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      lastStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      isBoolean: {
        type: Boolean,
        value: false
      },

      svg: {
        type: Object,
        value: function() {
          return {};
        }
      },

      exceedable: {
        type: Boolean,
        value: false
      },
      isExceeding: {
        type: Boolean,
        value: false,
        observer: 'handleExceeding'
      },
      hasExceeded: {
        type: Boolean,
        value: false,
        observer: 'hasExceededChanged'
      },
      bubbles: {
        type: Boolean,
        value: false
      },

      noSocketConnection: {
        type: Boolean,
        value: false,
        observer: "updatableChanged"
      },

      singleValue: {
        type: Boolean,
        value: false
      },
      renderedValue: {
        type: Object
      }
    },

    get containerRoot() {
      var root = Polymer.dom(this).getOwnerRoot();
      if (!root)
        return Polymer.dom(this).parentNode;
      else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
        return root.host;
      else {
        return undefined;
      }
    },

    hostAttributes: {
      element: true
    },

    created: function() {
      var sel, uniqueid;
      while (true) {
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.setAttribute('uniqueid', uniqueid);
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    attached: function() {
      if (this.dataLabel && this.dataId)
        this.updatableChanged();
      else {
        this.set('values', this.values || []);
      }
    },

    detached: function() {
      var pos;
      if (this.noSocketConnection === false &&
        window.Content !== undefined &&
        window.Content[this.dataLabel] &&
        window.Content[this.dataLabel][this.dataId] &&
        (pos = window.Content[this.dataLabel][this.dataId].nodes.indexOf(this)) !== -1)
        window.Content[this.dataLabel][this.dataId].nodes.splice(pos, 1);
    },

    setElement: function(obj, options) {
      this.clearValues();
      var pos;
      if (this.noSocketConnection === false && this.dataLabel && this.dataId &&
        window.Content !== undefined &&
        window.Content[this.dataLabel] &&
        window.Content[this.dataLabel][this.dataId] &&
        (pos = window.Content[this.dataLabel][this.dataId].nodes.indexOf(this)) !== -1) {
        window.Content[this.dataLabel][this.dataId].nodes.splice(pos, 1); // remove from window.Content
        this.removeAttribute('updatable');
      }

      for (var key in obj.element) {
        this.set(key, obj.element[key]);
      }
      for (var key in obj.properties) {
        this.set(key, obj.properties[key].value);
      }
      for (var key in options) {
        this.set(key, options[key]);
      }
      this.updatableChanged();
    },

    unsetElement: function() {
      var pos;
      if (this.noSocketConnection === false && this.dataLabel && this.dataId &&
        window.Content !== undefined &&
        window.Content[this.dataLabel] &&
        window.Content[this.dataLabel][this.dataId] &&
        (pos = window.Content[this.dataLabel][this.dataId].nodes.indexOf(this)) !== -1) {
        window.Content[this.dataLabel][this.dataId].nodes.splice(pos, 1); // remove from window.Content
        this.removeAttribute('updatable');
      }
    },

    getElement: function() {
      return {
        element: {
          'dataId': this.dataId,
          'dataLabel': this.dataLabel,
          'dataKeys': this.dataKeys,
          'captionKeys': this.captionKeys,
          'isBoolean': this.isBoolean,
          'unit': this.unit,
          'svg': this.svg,
          'firstStateChange': this.firstStateChange,
          'lastStateChange': this.lastStateChange,
          'exceedable': this.exceedable,
          'groupedKey': this.groupedKey,
          'color': this.color
        }
      };
    },

    toDate: function(x) {
      return this.showFullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString();
    },

    getValue: function(y) {
      return this.isBoolean ? '' : y;
    },

    insertValues: function(values) {
      if (values === undefined) {
        values = this.values || [];
      }
      if (this.noSocketConnection === true) {
        this.splice('values', this.values.length, 0, values);
      }
      if (this.singleValue === true) {
        if (this.exceedable === true)
          this.checkExceedingState(values[values.length - 1]);
        this.renderInsertedValues(values[values.length - 1]);
      } else {
        if (this.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        this.renderInsertedValues(values);
      }
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.noSocketConnection === true) {
          this.splice('values', 0, splices.length);
        }
        this.renderSplicedValues(splices);
      }
    },

    renderInsertedValues: function(values) {
    },
    renderSplicedValues: function(splices) {
    },

    clearValues: function() {
      if (this.values)
        this.renderSplicedValues(this.values);
    },

    checkExceedingState: function(value) {
      if (this.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.setLastStateChange(value);
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.setFirstStateChange(value);
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setFirstStateChange: function(value) {
      this.firstStateChange.push(value);
    },

    setLastStateChange: function(value) {
      this.lastStateChange.push(value);
    },

    handleExceeding: function(isExceeding) {
      if (this.exceedable === true) {
        if (this.bubbles === true) {
          if (isExceeding === true)
            this.fire('element-is-exceeding', {
              target: this
            });
          else
            this.fire('element-is-not-exceeding', {
              target: this
            });
        }
      }
    },

    hasExceededChanged: function() {},

    resetState: function() {
      this.set('hasExceeded', false);
    },

    updatableChanged: function() {
      // sets a global Object 'window.Content', for updating the values of the elements
      if (this.noSocketConnection === false && this.dataLabel && this.dataId) {
        var id = this.dataId,
          label = this.dataLabel;
        this.setAttribute("updatable", '');
        if (window.Content === undefined)
          window.Content = {};
        if (window.Content[label] === undefined)
          window.Content[label] = {};
        if (window.Content[label][id] === undefined)
          window.Content[label][id] = {};
        if (window.Content[label][id].nodes === undefined)
          window.Content[label][id].nodes = [];
        if (window.Content[label][id].values === undefined)
          window.Content[label][id].values = [];
        if (window.Content[label][id].nodes.indexOf(this) === -1) {
          window.Content[label][id].nodes.push(this);
          // console.log(id, label, 'added', window.Content);
          try {
            // delete this.values;
            if (window.Cache[label] === undefined)
              window.Cache[label] = new ClientCache(window.name, label);
            if (window.Cache[label][id] === undefined) {
              var obj = {};
              obj[id] = [];
              window.Cache[label].append(obj);
            }

            Object.defineProperty(this, "values", {
              configurable: true,
              enumerable: false,
              get: function() {
                return window.Cache[label][id].values;
              }
            });
            this.insertValues(this.values || []);
          } catch (e) {
            console.log(this.nodeName, this.dataLabel, this.dataId, e);
          }
        }
      } else {
        this.removeAttribute("updatable");
        var pos;
        if (!(window.Content === undefined) &&
          window.Content[label] &&
          window.Content[label][id] &&
          (pos = window.Content[label][id].nodes.indexOf(this)) !== -1)
          window.Content[label][id].nodes.splice(pos, 1);
      }
    }
  };
</script>
