<script>
  DragAndDropBehavior = {

    properties: {
      notDraggable: {
        type: Boolean,
        value: false,
        observer: 'draggableChanged'
      },
      notDroppable: {
        type: Boolean,
        value: false,
        observer: 'droppableChanged'
      }
    },

    draggableChanged: function() {
      if (this.notDraggable === false) {
        this.setAttribute('draggable', '');
        var dragArea = this.dragArea || this;
        dragArea.addEventListener('dragstart', this.dragStart);
      }
      else if (this.notDraggable === true) {
        if (this.hasAttribute('draggable'))
          this.removeAttribute('draggable');
        var dragArea = this.dragArea || this;
        dragArea.removeEventListener('dragstart', this.dragStart);
      }
    },
    droppableChanged: function() {
      if (this.notDroppable === false) {
        this.setAttribute('droppable', '');
        var dropArea = this.dropArea || this;
        dropArea.addEventListener('dragover', this.dragOver);
        dropArea.addEventListener('drop', this.dropped);
      }
      else if (this.notDroppable === true) {
        if (this.hasAttribute('droppable'))
          this.removeAttribute('droppable');
        var dropArea = this.dropArea || this;
        dropArea.removeEventListener('dragover', this.dragOver);
        dropArea.removeEventListener('drop', this.dropped);
      }
    },
    dragStart: function(e) {
      console.log(this);
      e.dataTransfer.setData("text", "[uniqueid='" + e.target.getAttribute('uniqueid') + "']");
      e.dataTransfer.effectAllowed = "move";
    },
    dragOver: function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    },
    dropped: function(e) {
      e.preventDefault();
      var selector = e.dataTransfer.getData("text");
      if (selector) {
        var elem = document.querySelector(selector);
        console.log(selector, elem);
        if (elem) {
          var elemParent = elem.parentNode;
          var elemSibling = elem.nextSibling;
          if (elemParent === this.parentNode) {
            // drag and drop just in same context
            if (elemSibling === this) {
              elemParent.insertBefore(this, elem);
            } else {
              elemParent.insertBefore(elem, this);
              if (elemSibling) {
                elemParent.insertBefore(this, elemSibling);
              } else {
                elemParent.appendChild(this);
              }
            }
            if (window.getComputedStyle(elemParent,null).getPropertyValue('flex-wrap') === 'wrap') { // bug fix for wrap styles, polymer.dom and event propagation
              Array.prototype.forEach.call(elemParent.children, function(item, i) {
                item.style.order = i;
              })
            }
            e.stopPropagation();
          }
          // else {
          //   this.parentNode.insertBefore(elem, this);
          // }
        }
      }
    }
  };
</script>
