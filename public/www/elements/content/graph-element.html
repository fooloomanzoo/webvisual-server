<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->
<link rel="import" href="../behaviors/color-behavior.html"/>
<link rel="import" href="../behaviors/checked-and-select-behavior.html"/>
<link rel="import" href="../behaviors/element-behavior.html"/>
<dom-module id='graph-element'>
  <style>
    :host {
      box-sizing: border-box;
      position: relative;
    }
    radio-button-element#legendEntry {
      --radio-button-label-color: currentColor;
      padding: 0.25em;
    }
    caption-element#legendCaption {
      --caption-background: transparent;
      --caption-dark-background: transparent;
      --caption-padding: 0;
    }
  </style>
  <template>
    <radio-button-element id='legendEntry' checked='{{checked}}'>
      <caption-element id='legendCaption' horizontal only-grouped-key grouped-key='[[groupedKey]]' data-keys='[[dataKeys]]'></caption-element>
    </radio-button-element>
  </template>
  <script>
    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [
        ColorBehavior,
        CheckedAndSelectBehavior,
        ElementBehavior
      ],

      properties: {
        interpolation: {
          type: String,
          value: 'Lineare Verbindung',
          observer: '_interpolationChanged'
        },
        noDots: {
          type: Boolean,
          value: false,
          observer: '_noDotsChanged'
        },
        noLine: {
          type: Boolean,
          value: false,
          observer: '_noLineChanged'
        },
        noFill: {
          type: Boolean,
          value: false,
          observer: '_noFillChanged'
        },
        dotRadius: {
          type: Number,
          value: 2,
          observer: '_dotRadiusChanged'
        },
        lineWidth: {
          type: Number,
          value: 1.5,
          observer: '_lineNodeWidthChanged'
        },
        fillOpacity: {
          type: Number,
          value: 0.3,
          observer: '_fillOpacityChanged'
        },
        checkEveryValue: {
          type: Boolean,
          value: true,
          readOnly: true
        },
        checked: {
          type: Boolean,
          value: true
        }
      },
      _dots: Object,
      _lineNode: Object,
      _line: Object,
      _areaNode: Object,
      _area: Object,
      _hidden: false,
      _isAttached: false,

      created: function() {
        this._line = d3.line()
          .x((function(d) {
            return this.chartElement._x(d.x);
          }).bind(this))
          .y((function(d) {
            return this.chartElement._y(d.y);
          }).bind(this));
        this._area = d3.area()
          .x(this._line.x())
          .y1(this._line.y());
      },

      attached: function() {
        var containerRoot = this.containerRoot;
        // performance.mark('graph attached start');

        if (containerRoot.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.dataId, 'Graph is not attached to a container');
          this.chartElement = document.createElement('chart-element');
          containerRoot.appendChild(this.chartElement);
        } else {
          this.chartElement = containerRoot;
        }

        if (this.chartElement._elements.indexOf(this) === -1) {
          this.chartElement.__processNewNodes([this]);
        }

        this.noDots = this.chartElement.noDots || this.noDots;
        this.noLine = this.chartElement.noLines || this.noLine;
        this.noFill = this.chartElement.noAreas || this.noFill;

        this._chart = this.chartElement._chart;

        // node of line
        this._lineNode = this._chart.select('g#lines')
          .append('svg:path')
          .attr('data-id', this.dataId)
          .attr('data-label', this.dataLabel)
          .attr("class", "line")
          .attr('hidden', this.noLine ? true : null)
          .attr('fill', 'none')
          .attr('stroke', this.color)
          .attr('stroke-width', this.lineWidth);
        this._lineNode
          .datum([])
          .attr("d", this._line);

        // fill area
        this._area.y0(this.chartElement._height);
        this._areaNode = this._chart.select('g#areas')
          .append('svg:path')
          .attr('data-id', this.dataId)
          .attr('data-label', this.dataLabel)
          .attr("class", "area")
          .attr('hidden', this.noFill ? true : null)
          .attr('fill', this.color)
          .attr('fill-opacity', this.fillOpacity)
          .attr('stroke', 'none');
        this._areaNode
          .datum([])
          .attr("d", this._area);

        // group of dots
        this._dots = this._chart.select('g#dots')
          .append("svg:g")
          .attr('data-id', this.dataId)
          .attr('data-label', this.dataLabel)
          .attr("class", "dots")
          .attr("hidden", this.noDots ? true : null);

        this._isAttached = true;
        // performance.mark('graph attached end');
        // performance.measure('graph attached', 'graph attached start', 'graph attached end');
        // performance.mark('insert start');
        this.addValues();
        // performance.mark('insert end');
        // performance.measure('values insert', 'insert start', 'insert end');
        this.chartElement.redraw();
      },

      detached: function() {
        this._lineNode.node().parentElement.removeChild(this._lineNode.node());
        this._areaNode.node().parentElement.removeChild(this._areaNode.node());
        this._dots.node().parentElement.removeChild(this._dots.node());

        if (this.noSocketConnection === false &&
          window.Content !== undefined &&
          Content[this.dataLabel] &&
          Content[this.dataLabel][this.dataId] &&
          (pos = Content[this.dataLabel][this.dataId].nodes.indexOf(this)) !== -1)
          Content[this.dataLabel][this.dataId].nodes.splice(pos, 1);

        this.chartElement.__processRemovedNodes([this]);
      },

      render: function(values, splices) {
        if (!this.chartElement)
          this.chartElement = this.containerRoot;

        if (this.chartElement) {
          if (this.chartElement._isZoomed === false)
            this.chartElement.redraw();
          else
            this.redraw();
        }
      },

      redraw: function() {
        if (this._hidden === true) return;
        // performance.mark('graph redraw start');
        var self = this;
        var data = this.values.filter(this._defined.bind(this)) || [];

        if (this.noLine === false) {
          this._lineNode
            .datum(data)
            .attr('d', this._line);

        }

        if (this.noFill === false) {
          this._area
            .y0(this.chartElement._height);
          this._areaNode
            .datum(data)
            .attr('d', this._area);
        }

        if (this.noDots === false) {
          var everyOverlappingDot = (data.length / Math.max(this.chartElement._height, this.chartElement._width) * (this.dotRadius * 4));

          if (everyOverlappingDot > 1)
            data = data.filter(function(d, i) {
              return (i % everyOverlappingDot < 1);
            })
            var strokewidth = this.lineWidth*2/3;
            var dots = this._dots.selectAll('circle')
              .data(data);
            // update current dots
            dots.attr('cx', function(d, i) {
                return this.chartElement._x(d.x)
              }.bind(this))
              .attr('cy', function(d, i) {
                return this.chartElement._y(d.y)
              }.bind(this));
            // enter new dots
            dots.enter()
              .append('circle')
              .attr('r', this.dotRadius)
              .attr('stroke', this.color).attr('stroke-width', strokewidth)
              .attr('fill', '#fff')
              .attr('cx', function(d, i) {
                return this.chartElement._x(d.x)
              }.bind(this))
              .attr('cy', function(d, i) {
                return this.chartElement._y(d.y)
              }.bind(this))
              .classed('style-scope', true).classed('chart-element', true)
              .on('mouseenter', function(d) {
                this.setAttribute('r', self.dotRadius * 1.5);
                self.chartElement._showInfo(d);
              })
              .on('mouseleave', function(d, i) {
                this.setAttribute('r', self.dotRadius);
                self.chartElement._hideInfo();
              })
              .on('click', function(d, i) {
                var offset = this.dotRadius * 5;
                var x = this.chartElement._x(d.x);
                var y = this.chartElement._y(d.y);
                d3.event.selection = [
                  [x - offset, y - offset],
                  [x + offset, y + offset]
                ];
                this.chartElement._brushed();
              }.bind(this));
            //  remove old dots
            dots.exit()
                .remove();
        }

        // performance.mark('graph redraw end');
        // performance.measure('graph redraw', 'graph redraw start', 'graph redraw end');
        // TODO(?): update line, animated http://bl.ocks.org/benjchristensen/1148374
      },

      _defined: function(d, i, data) {
        var domainX = this.chartElement._x.domain(),
            yScale = this.chartElement.yScale;

        if (d.y === null || isNaN(d.y))
          return undefined; // NaN and null are displayable
        else if (yScale !== "linear" && d.y <= 0)
          return undefined; // log- and sqrt-scales require larger than 0-Values
        else if ((d.x >= domainX[0] && d.x <= domainX[1]) || (i > 0 && i + 1 < data.length && (data[i + 1].x > domainX[0] && data[i - 1].x < domainX[1])))
          return true; // only numbers in x-Domain are shown (and their successor and predecessor) (graph is a function by definition, so y-Domain is not relevant)
        else
          return undefined;
      },

      setColor: function(color) {
        // random color if color is not set
        ColorBehavior.setColor.call(this, color);
        if (this._chart) {
          if (this._lineNode) this._lineNode.attr('stroke', this.color);
          if (this._areaNode) this._lineNode.attr('fill', this.color);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke', this.color);
        }
        this.$.legendEntry.customStyle['--radio-button-checked-color'] = this.color;
        this.$.legendEntry.customStyle['--radio-button-unchecked-color'] = this.color;
        this.$.legendEntry.updateStyles();
      },

      checkedChanged: function(checked, old) {
        CheckedAndSelectBehavior.checkedChanged.call(this, checked, old);
        this.noDots = (!checked || (this.chartElement && this.chartElement.noDots))  ? true : false;
        this.noLine = (!checked || (this.chartElement && this.chartElement.noLines)) ? true : false;
        this.noFill = (!checked || (this.chartElement && this.chartElement.noAreas)) ? true : false;
        this._hidden = !checked;
      },

      _noDotsChanged: function() {
        if (this._chart && this._dots) {
          this._dots.attr('hidden', this.noDots ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _noLineChanged: function() {
        if (this._chart && this._lineNode) {
          this._lineNode.attr('hidden', this.noLine ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _noFillChanged: function() {
        if (this._chart && this._areaNode) {
          this._areaNode.attr('hidden', this.noFill ? true : null);
          this.debounce('redraw', this.redraw, 16);
        }
      },

      _fillOpacityChanged: function() {
        if (this._chart && this._areaNode) {
          this._areaNode.attr('fill-opacity', this.fillOpacity);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this._chart && this._dots) {
          this._dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _lineNodeWidthChanged: function(lineWidth) {
        if (this._chart) {
          if (this._lineNode) this._lineNode.attr('stroke-width', this.lineWidth);
          if (this._dots)
            this._dots.selectAll('circle.dot')
            .attr('stroke-width', this.lineWidth);
        }
      },

      _interpolationChanged: function(interpolation) {
        var curve;
        switch (interpolation) {
          case 'Basis Spline':
            curve = d3.curveBasis;
            break;
          case 'Monotoner Spline':
            curve = d3.curveMonotoneX;
            break;
          case 'Kubischer Spline':
            curve = d3.curveNatural;
            break;
          case 'Cardinaler Spline':
            curve = d3.curveCardinal;
            break;
          case 'Catmull-Rom-Spline':
            curve = d3.curveCatmullRom;
            break;
          case 'Stufe (mitte)':
            curve = d3.curveStep;
            break;
          case 'Stufe (davor)':
            curve = d3.curveStepAfter;
            break;
          case 'Stufe (danach)':
            curve = d3.curveStepBefore;
            break;
          default:
            curve = d3.curveLinear;
            break;
        }
        this._line.curve(curve);
        this._area.curve(curve);
        if (this._chart && this._areaNode)
          this.redraw();
      }
    });
  </script>

</dom-module>
