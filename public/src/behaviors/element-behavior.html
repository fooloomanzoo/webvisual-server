<script>
  ElementBehavior = {

    properties: {
      item: Object,

      groupedKey: String,

      firstStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      lastStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },

      exceedable: Boolean,

      isExceeding: Boolean,

      hasExceeded: Boolean,

      bubbles: Boolean,

      noSocketConnection: {
        type: Boolean,
        value: false,
        observer: "updatableChanged"
      },

      singleValue: Boolean,

      renderedValue: Object
    },

    observers: [
      'handleExceeding(isExceeding)',
      'hasExceededChanged(hasExceeded)',
      'setElement(item)'
    ],

    get containerRoot() {
      var root = Polymer.dom(this).getOwnerRoot();
      if (!root)
        return Polymer.dom(this).parentNode;
      else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
        return root.host;
      else {
        return undefined;
      }
    },

    hostAttributes: {
      element: true
    },

    created: function() {
      var sel, uniqueid;
      while (true) {
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.setAttribute('uniqueid', uniqueid);
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    attached: function() {
      if (this.item && this.item.id)
        this.updatableChanged();
      else {
        this.set('values', this.values || []);
      }
    },

    detached: function() {
      this.unsetElement();
      this.clearValues();
    },

    setElement: function(item, properties) {
      this.clearValues();
      this.set('item', item);
      for (var key in properties) {
        if (key !== 'item')
          this.set(key, properties[key].value);
      }
      this.updatableChanged();
    },

    unsetElement: function() {
      if (this.item && this.item.id) {
        var id = this.item.id;
        if (this.noSocketConnection === false && id)
          Webvisual.retractElement(this);
      }
    },

    getElement: function() {
      return this.properties;
    },

    toDate: function(x) {
      return this.showFullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString();
    },

    getValue: function(y) {
      return this.isBoolean ? '' : y;
    },

    insertValues: function(values) {
      if (values === undefined) {
        values = this.values || [];
      }
      if (this.noSocketConnection === true) {
        this.splice('values', this.values.length, 0, values);
      }
      if (this.singleValue === true) {
        if (this.exceedable === true)
          this.checkExceedingState(values[values.length - 1]);
        this.renderInsertedValues(values[values.length - 1]);
      } else {
        if (this.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        this.renderInsertedValues(values);
      }
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.noSocketConnection === true) {
          this.splice('values', 0, splices.length);
        }
        this.renderSplicedValues(splices);
      }
    },

    renderInsertedValues: function(values) {
    },
    renderSplicedValues: function(splices) {
    },

    clearValues: function() {
      if (this.values)
        this.renderSplicedValues(this.values);
    },

    checkExceedingState: function(value) {
      if (this.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.setLastStateChange(value);
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.setFirstStateChange(value);
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setFirstStateChange: function(value) {
      this.firstStateChange.push(value);
    },

    setLastStateChange: function(value) {
      this.lastStateChange.push(value);
    },

    handleExceeding: function(isExceeding) {
      if (this.exceedable === true) {
        if (this.bubbles === true) {
          if (isExceeding === true)
            this.fire('element-is-exceeding', {
              target: this
            });
          else
            this.fire('element-is-not-exceeding', {
              target: this
            });
        }
      }
    },

    hasExceededChanged: function() {},

    resetState: function() {
      this.set('hasExceeded', false);
    },

    updatableChanged: function() {
      // sets a global Object 'Webvisual', for updating the values of the elements
      if (this.item &&
         !this.noSocketConnection &&
          this.item.id) {
        var id = this.item.id;
        try {
          Object.defineProperty(this, "values", {
            configurable: true,
            enumerable: false,
            get: function() {
              return Webvisual.cache[id].values;
            }
          });
          this.insertValues(this.values || []);
          Webvisual.assignElement(this);
        } catch (e) {
          console.log(this.nodeName, system, id, e);
        }
      } else {
        Webvisual.retractElement(this);
      }
    }
  };
</script>
