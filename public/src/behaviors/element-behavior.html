<script>
  ElementBehavior = {

    properties: {
      item: Object,

      groupedKey: String,

      firstStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      lastStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },

      exceedable: Boolean,

      isExceeding: Boolean,

      hasExceeded: Boolean,

      bubbles: Boolean,

      noSocketConnection: {
        type: Boolean,
        value: false,
        observer: "updatableChanged"
      },

      singleValue: Boolean,

      renderedValue: Object
    },

    observers: [
      'handleExceeding(isExceeding)',
      'hasExceededChanged(hasExceeded)',
      'setElement(item)'
    ],

    get containerRoot() {
      var root = Polymer.dom(this).getOwnerRoot();
      if (!root)
        return Polymer.dom(this).parentNode;
      else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
        return root.host;
      else {
        return undefined;
      }
    },

    hostAttributes: {
      element: true
    },

    created: function() {
      var sel, uniqueid;
      while (true) {
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector("[uniqueid='" + uniqueid + "']");
        if (!sel) break;
      }
      this.setAttribute('uniqueid', uniqueid);
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    attached: function() {
      if (this.item && this.item.system && this.item.id)
        this.updatableChanged();
      else {
        this.set('values', this.values || []);
      }
    },

    detached: function() {
      var pos, system, id;
      if (this.item &&
          this.item.system &&
          this.item.id) {
            system = this.item.system;
            id = this.item.id;
          }
      if (this.noSocketConnection === false &&
        system &&
        id &&
        window.Content !== undefined &&
        window.Content[system] &&
        window.Content[system][id] &&
        (pos = window.Content[system][id].nodes.indexOf(this)) !== -1)
        window.Content[system][id].nodes.splice(pos, 1);
    },

    setElement: function(item, properties) {
      this.clearValues();
      this.set('item', item);
      for (var key in properties) {
        if (key !== 'item')
          this.set(key, properties[key].value);
      }
      var pos, system = item.system, id = item.id;
      if (this.noSocketConnection === false && system && id &&
        window.Content !== undefined &&
        window.Content[system] &&
        window.Content[system][id] &&
        (pos = window.Content[system][id].nodes.indexOf(this)) !== -1) {
        window.Content[system][id].nodes.splice(pos, 1); // remove from window.Content
        this.removeAttribute('updatable');
      }
      this.updatableChanged();
    },

    unsetElement: function() {
      var pos, system, id;
      if (this.item &&
          this.item.system &&
          this.item.id) {
            system = this.item.system;
            id = this.item.id;
          }
      if (this.noSocketConnection === false &&
          system &&
          id &&
          window.Content !== undefined &&
          window.Content[system] &&
          window.Content[system][id] &&
          (pos = window.Content[system][id].nodes.indexOf(this)) !== -1) {
            window.Content[system][id].nodes.splice(pos, 1); // remove from window.Content
            this.removeAttribute('updatable');
          }
    },

    getElement: function() {
      return this.properties;
    },

    toDate: function(x) {
      return this.showFullDate ? new Date(x).toLocaleString() : new Date(x).toLocaleTimeString();
    },

    getValue: function(y) {
      return this.isBoolean ? '' : y;
    },

    insertValues: function(values) {
      if (values === undefined) {
        values = this.values || [];
      }
      if (this.noSocketConnection === true) {
        this.splice('values', this.values.length, 0, values);
      }
      if (this.singleValue === true) {
        if (this.exceedable === true)
          this.checkExceedingState(values[values.length - 1]);
        this.renderInsertedValues(values[values.length - 1]);
      } else {
        if (this.exceedable === true) {
          values.forEach(function (value) {
            this.checkExceedingState(value);
          }, this)
        }
        this.renderInsertedValues(values);
      }
    },

    spliceValues: function(splices) {
      if (splices) {
        if (this.noSocketConnection === true) {
          this.splice('values', 0, splices.length);
        }
        this.renderSplicedValues(splices);
      }
    },

    renderInsertedValues: function(values) {
    },
    renderSplicedValues: function(splices) {
    },

    clearValues: function() {
      if (this.values)
        this.renderSplicedValues(this.values);
    },

    checkExceedingState: function(value) {
      if (this.exceedable === false || value === undefined) return;

      if (value.state === 0) {
        if (this.isExceeding === true) {
          this.setLastStateChange(value);
          this.isExceeding = false;
        }
      } else {
        if (this.isExceeding !== true) {
          this.setFirstStateChange(value);
          this.isExceeding = true;
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setFirstStateChange: function(value) {
      this.firstStateChange.push(value);
    },

    setLastStateChange: function(value) {
      this.lastStateChange.push(value);
    },

    handleExceeding: function(isExceeding) {
      if (this.exceedable === true) {
        if (this.bubbles === true) {
          if (isExceeding === true)
            this.fire('element-is-exceeding', {
              target: this
            });
          else
            this.fire('element-is-not-exceeding', {
              target: this
            });
        }
      }
    },

    hasExceededChanged: function() {},

    resetState: function() {
      this.set('hasExceeded', false);
    },

    updatableChanged: function() {
      // sets a global Object 'window.Content', for updating the values of the elements
      if (this.item &&
         !this.noSocketConnection &&
          this.item.system &&
          this.item.id) {
        var system = this.item.system, id = this.item.id;
        this.setAttribute("updatable", '');
        if (window.Content === undefined)
          window.Content = {};
        if (window.Content[system] === undefined)
          window.Content[system] = {};
        if (window.Content[system][id] === undefined)
          window.Content[system][id] = {};
        if (window.Content[system][id].nodes === undefined)
          window.Content[system][id].nodes = [];
        if (window.Content[system][id].values === undefined)
          window.Content[system][id].values = [];
        if (window.Content[system][id].nodes.indexOf(this) === -1) {
          window.Content[system][id].nodes.push(this);
          // console.log(id, system, 'added', window.Content);
          try {
            // delete this.values;
            if (window.Cache[system] === undefined)
              window.Cache[system] = new ClientCache(window.name, system);
            if (window.Cache[system][id] === undefined) {
              var obj = {};
              obj[id] = [];
              window.Cache[system].append(obj);
            }

            Object.defineProperty(this, "values", {
              configurable: true,
              enumerable: false,
              get: function() {
                return window.Cache[system][id].values;
              }
            });
            this.insertValues(this.values || []);
          } catch (e) {
            console.log(this.nodeName, system, id, e);
          }
        }
      } else {
        this.removeAttribute("updatable");
        var pos;
        if (!(window.Content === undefined) &&
          window.Content[system] &&
          window.Content[system][id] &&
          (pos = window.Content[system][id].nodes.indexOf(this)) !== -1)
          window.Content[system][id].nodes.splice(pos, 1);
      }
    }
  };
</script>
