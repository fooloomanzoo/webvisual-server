<script>
  ContainerBehavior = {

    properties: {

      opened: Boolean,

      openOnSelect: Boolean,

      openOnExceed: Boolean,

      forceOpened: Boolean,

      isExceeding: {
        type: Boolean,
        notify: true
      },

      selectNotify: Boolean,

      exceedNotify: Boolean,

      notifySelf: Boolean,

      notifyParent: Boolean,

      selectEvent: {
        type: String,
        value: 'item-select'
      },

      exceedEvent: {
        type: String,
        value: 'exceeding'
      },

      multiSelect: Boolean,

      noAutoRemovalExceedings: Boolean,

      item: Object,

      items: {
        type: Array,
        value: function() {
          return [];
        }
      },

      exceeding: {
        type: Array,
        value: function() {
          return [];
        }
      },

      reproduce: Boolean,

      reproductionContainer: String,

      reproductionAttribute: {
        type: String,
        value: 'insertionpoint'
      }

    },

    observers: [
      '_watchSelectSelf(selectNotify, notifySelf)',
      '_watchExceedSelf(exceedNotify, notifySelf)',
      '_watchSelectParent(selectNotify, notifyParent)',
      '_watchExceedParent(exceedNotify, notifyParent)',
      '_reproductionSelectRepeat(item)',
      '_reproductionMultiSelectRepeat(items.splices)',
      '_reproductionExceedsRepeat(exceeding.splices)',
    ],

    hostAttributes: {
      container: true
    },

    get rootElement() {
      var parentNode = Polymer.dom(this).parentNode;
      // If the parentNode is a document fragment, then we need to use the host.
      var ownerRoot = Polymer.dom(this).getOwnerRoot();
      var target;

      if (this.for) {
        target = Polymer.dom(ownerRoot).querySelector('#' + this.for);
      } else {
        target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ?
            ownerRoot.host : parentNode;
      }

      return target;
    },

    created: function() {
      var sel, uniqueid;
      while (true) {
        uniqueid = String(Math.random().toString(16).slice(2));
        sel = document.querySelector('[uniqueid="' + uniqueid + '"]');
        if (!sel) break;
      }
      this.setAttribute('uniqueid', uniqueid);
    },

    detached: function() {
      this._watchSelectSelf(false, this.notifySelf);
      this._watchExceedSelf(false, this.notifySelf);
      this._watchSelectParent(false, this.notifyParent);
      this._watchExceedParent(false, this.notifyParent);
    },

    _watchSelectSelf: function(selectNotify, notifySelf) {
      console.log(selectNotify, notifySelf);
      if (notifySelf === true && selectNotify === true) {
        this.addEventListener(this.selectEvent, this._select, {
          passive: true
        });
        this.addEventListener('clear-selected-items', this.clearItems, {
          passive: true
        });
      } else {
        this.rootElement.removeEventListener(this.selectEvent, this._select, {
          passive: true
        });
        this.rootElement.removeEventListener('clear-selected-items', this.clearItems, {
          passive: true
        });
      }
    },

    _watchExceedSelf: function(exceedNotify, notifySelf) {
      console.log(exceedNotify, notifySelf);
      if (notifySelf === true && exceedNotify === true) {
        this.addEventListener(this.exceedEvent, this._setExceeding, {
          passive: true
        });
        this.addEventListener('clear-exceeding-items', this.clearExceedings, {
          passive: true
        });
      } else {
        this.rootElement.removeEventListener(this.exceedEvent, this._setExceeding, {
          passive: true
        });
        this.rootElement.removeEventListener('clear-exceeding-items', this.clearExceedings, {
          passive: true
        });
      }
    },

    _watchSelectParent: function(selectNotify, notifyParent) {
            console.log(selectNotify, notifyParent, this.rootElement);
      if (notifyParent === true && selectNotify === true) {
        this.rootElement.addEventListener(this.selectEvent, this._select, {
          passive: true
        });
        this.rootElement.addEventListener('clear-selected-items', this.clearItems, {
          passive: true
        });
      } else {
        this.rootElement.removeEventListener(this.selectEvent, this._select, {
          passive: true
        });
        this.rootElement.removeEventListener('clear-selected-items', this.clearItems, {
          passive: true
        });
      }
    },

    _watchExceedParent: function(exceedNotify, notifyParent) {
            console.log(exceedNotify, notifyParent, this.rootElement);
      if (notifyParent === true && exceedNotify === true) {
        this.rootElement.addEventListener(this.exceedEvent, this._setExceeding, {
          passive: true
        });
        this.rootElement.addEventListener('clear-exceeding-items', this.clearExceedings, {
          passive: true
        });
      } else {
        this.rootElement.removeEventListener(this.exceedEvent, this._setExceeding, {
          passive: true
        });
        this.rootElement.removeEventListener('clear-exceeding-items', this.clearExceedings, {
          passive: true
        });
      }
    },

    _select: function(e) {
      if (e && e.detail && e.detail.item) {
        if (e.detail.value === true)
          this.select(e.detail.item);
        else
          this.deselect(e.detail.item);
      }
    },

    select: function(item) {
      this.set('item', item); // store nevertheless the multiSelect option the last selected Element
      if (this.multiSelect === true) {
        if (this.items.indexOf(item) === -1) {
          this.push('items', item);
        }
      }

      this.opened = this.forceOpened || this.openOnSelect;
    },

    deselect: function(item) {
      if (this.multiSelect) {
        var pos = this.items.indexOf(item);
        if (pos !== -1) {
          this.splice('items', pos, 1);
        }
        this.set('item', (this.items.length !== 0) ? this.items[0] : null);
      } else {
        this.set('item', null);
      }

      this.opened = this.forceOpened || (this.openOnSelect && this.item) ? true : false;
    },

    clearItems: function() {
      this.set('item', null);
      this.splice('items', 0, this.items.length);
    },

    _setExceeding: function(e) {
      if (e && e.detail && e.detail.item) {
        if (e.detail.value === true)
          this.setExceeding(e.detail.item);
        else
          this.unsetExceeding(e.detail.item);
      }
    },

    setExceeding: function(item) {
      var pos = this.exceeding.indexOf(item);
      if (pos === -1)
        this.push('exceeding', item);

      this.isExceeding = (this.exceeding.length > 0) ? true : false;
      this.opened = this.opened || this.forceOpened || (this.openOnExceed && this.isExceeding);
    },

    unsetExceeding: function(item) {
      if (this.noAutoRemovalExceedings === true) return;
      var pos = this.exceeding.indexOf(item);
      if (pos !== -1)
        this.splice('exceeding', pos, 1);

      this.isExceeding = (this.exceeding.length > 0) ? true : false;
      this.opened = this.opened || this.forceOpened || (this.openOnExceed && this.isExceeding);
    },

    clearExceedings: function() {
      this.splice('exceeding', 0, this.exceeding.length);
      this.isExceeding = false;
    },

    _handleExceeding: function(value) {},

    _reproductionSelectRepeat: function(item) {
      if (this.reproduce === false && !item) return;

      var container = (this.reproductionContainer) ? Polymer.dom(this).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);

      var elements = Polymer.dom(container).getEffectiveChildNodes().filter(function(el) {
        return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(this.reproductionAttribute);
      }.bind(this));

      elements.forEach(function(e) {
        e.item = {};
        e.item = item;
      }, this);
    },

    _reproductionMultiSelectRepeat: function(changeRecord) {
      if (this.reproduce === false) return;
      if (changeRecord && changeRecord.indexSplices) {

        var container = (this.reproductionContainer) ? Polymer.dom(this).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);

        var reproductionAttribute = this.reproductionAttribute;

        var elements = Polymer.dom(container).getEffectiveChildNodes().filter(function(el) {
          return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(reproductionAttribute) && !el.hasAttribute('element');
        });

        elements.forEach(function(e) {
          e.notifySplices('items', changeRecord);
        }, this);

        // for (var i = 0; i < changeRecord.indexSplices.length; i++) {
        //   for (var j = 0; j < changeRecord.indexSplices[i].removed.length; j++) {
        //     item = changeRecord.indexSplices[i].removed[j];
        //
        //     elements.filter(function(el) {
        //         return el.ident === item.ident && el.system === item.system;
        //       })
        //       .forEach(function(el) {
        //         el.unsetElement();
        //       }, this);
        //     this._elements = this._elements.filter(function(el) {
        //       return !(el.ident === item.ident && el.system === item.system);
        //     })
        //     containers.forEach(function(el) {
        //       // containers should notify themselfes? "item.unsetItem(del);"
        //       el.unsetItem(item);
        //     }, this);
        //   }
        //
        //   for (var j = 0; j < changeRecord.indexSplices[i].addedCount; j++) {
        //     index = changeRecord.indexSplices[i].index + j;
        //     item = changeRecord.indexSplices[i].object[index];
        //     var element = item.getElement();
        //
        //     // if (this.multiSelect === false)
        //     elements.forEach(function(el) {
        //       el.setElement(element);
        //     });
        //
        //     containers.forEach(function(el) {
        //       el.setItem(item);
        //     }, this);
        //   }
        // }
      }
    },

    _reproductionExceedsRepeat: function(changeRecord) { // just the containers
      if (this.reproduce === false) return;
      if (changeRecord && changeRecord.indexSplices) {

        var container = (this.reproductionContainer) ? Polymer.dom(this).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);

        var containers = Polymer.dom(container).getEffectiveChildNodes().filter(function(el) {
          return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute('container');
        });

        containers.forEach(function(c) {
          c.notifySplices('exceeding', changeRecord);
        }, this);

        // for (var i = 0; i < changeRecord.indexSplices.length; i++) {
        //   for (var j = 0; j < changeRecord.indexSplices[i].removed.length; j++) {
        //     item = changeRecord.indexSplices[i].removed[j];
        //     containers.forEach(function(el) {
        //       el.unsetExceeding(item);
        //     }, this);
        //   }
        //   for (var j = 0; j < changeRecord.indexSplices[i].addedCount; j++) {
        //     index = changeRecord.indexSplices[i].index + j;
        //     item = changeRecord.indexSplices[i].object[index];
        //
        //     containers.forEach(function(el) {
        //       el.setExceeding(item);
        //     }, this);
        //   }
        // }
      }
    }
  };
</script>
