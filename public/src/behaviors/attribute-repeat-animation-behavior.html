<script>
  AttributeRepeatAnimationBehaviorImpl = {

    properties: {
      animatable: {
        type: Boolean
      },

      animationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500,
            fill: 'forwards'
          };
        }
      },
      animationConfig: {
        type: Object,
        value: function() {
          return {};
        }
      },
      attributeAlias: {
        type: Object,
        value: function() {
          return {};
        }
      },
      attributeAnimations: {
        type: Object,
        value: function() {
          return {};
        }
      },
      repeatedAttributes: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'createAnimatableObserver'
      }
    },

    getAnimatableNodes: function() {
      this._reproductionContainerNode = (this.reproductionContainer) ? Polymer.dom(this.root).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);
      this.animatableNodes = Polymer.dom(this._reproductionContainerNode).getEffectiveChildNodes().filter(function(el) {
        return (el.nodeType === Node.ELEMENT_NODE);
      });
      return this.animatableNodes;
    },

    _initialized: {},
    attributeObserver: {},
    animatableNodes: [],

    createAnimatableObserver: function(attrs) {
      for (var j in attrs) {
        var attr = attrs[j];
        var alias = this.attributeAlias[attr] || attr;
        this.attributeObserver[attr] = new MutationObserver( function(attr, alias, mutations) {
          if (this.animatable) {
            this.prepareAttributeAnimation(alias, this[attr])
                .then( function(nodes) {
                  var p = [];

                  for (var i in nodes) {
                    if (nodes[i].attributeAlias)
                      alias = nodes[i].attributeAlias[attr] || attr;
                    p.push( this.reproduceAttribute.call(this, nodes[i], alias, this[attr]) );
                  }

                  Promise.all(p)
                         .then(this.startAttributeAnimation.call(this, attr))
                }.bind(this));
          } else {
            var nodes = this.getAnimatableNodes();
            for (var i in nodes) {
              if (nodes[i].attributeAlias)
                alias = nodes[i].attributeAlias[attr] || attr;
              this.reproduceAttribute( nodes[i], alias, this[attr] );
            }
          }

        }.bind(this, attr, alias));

        var observerConfig = {
          attributes: true,
          childList: false,
          characterData: false,
          attributeFilter: [attr]
        };

        this.attributeObserver[attr].observe(this, observerConfig);

        if (!this._initialized[attr] && this.animationConfig) {
          this.prepareAttributeAnimation(attr, this[attr]);
        }
      }

    },

    startAttributeAnimation: function(attr) {
      if (this.offsetHeight === 0 || !attr)
        return;
      // console.log('should play', this.nodeName, attr, this.animationConfig);
      this.playAnimation(attr + '-changed-runner');
    },

    prepareAttributeAnimation: function(attr) {
      return new Promise( function(resolve, reject) {
        if (!this.attributeObserver[attr])
          reject(this.nodeName + ': observer for animatable runner is not existing: '+ attr);

        var animatables = this.getAnimatableNodes();

        this.animationConfig[attr + '-changed-runner'] = [];
        for (var i in animatables) {
          var node = animatables[i];
          node.style.display = '';
          if (node.animatable && node.prepareAttributeAnimation && node.repeatedAttributes.indexOf(attr) !== -1) {
            // Configure the Animation to Run the underlaying Animation
            node.prepareAttributeAnimation(attr, this[attr]);
          } else {
            // set the fromRect for giving an Rect to transition from
            this.prepareAnimationOnNode(attr, node);
          }
        }
        if (!this._initialized[attr]) {
          this._initialized[attr] = true;
          // this.startAttributeAnimation(attr);
        }
        resolve(animatables);
      }.bind(this))
    },

    prepareAnimationOnNode: function(attr, node) {
      // var oldBounds = node.getBoundingClientRect();
      if (this.attributeAnimations[attr] && ((this[attr] && this.attributeAnimations[attr].entry) || (!this[attr] && this.attributeAnimations[attr].exit))) {
        var animation = (this[attr] ? this.attributeAnimations[attr].entry : this.attributeAnimations[attr].exit);
        if (Array.isArray(animation)) {
          for (var i in animation) {
            if (!animation[i].node) animation[i].node = node;
            if (!animation[i].timing) animation[i].timing = this.animationTiming;
            this.animationConfig[attr + '-changed-runner'].push( animation[i] );
          }
        } else {
          if (!animation.node) animation.node = node;
          if (!animation.timing) animation.timing = this.animationTiming;
          this.animationConfig[attr + '-changed-runner'].push( animation );
        }
      } else {
        this.animationConfig[attr + '-changed-runner'].push( {
          name: 'attribute-animation',
          // fromRect: oldBounds,
          node: node,
          timing: this.animationTiming
        });
      }
    },

    reproduceAttribute: function(node, attr, value) {
      return new Promise( function(resolve, reject) {
        if (attr && node) {
          if (value) {
            node.setAttribute(attr, value);
          }
          else {
            if (node.hasAttribute(attr))
              node.removeAttribute(attr);
          }
          resolve(node)
        } else {
          reject('no given node or attribute for reproducing attribute');
        }
      })
    }
  };

  AttributeRepeatAnimationBehavior = [
    Polymer.NeonAnimationRunnerBehavior,
    AttributeRepeatAnimationBehaviorImpl
  ]
</script>
