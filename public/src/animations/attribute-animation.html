<script>

  Polymer({

    is: 'attribute-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      if (!config.node) return;

      let toRect, fromRect;
      config.node.style.display = '';
      config.node.style.willChange = 'transform';

      if (config.toRect) {
        toRect = config.toRect;
      } else {
        toRect = config.node.getBoundingClientRect();
      }

      if (config.fromRect) {
        fromRect = config.fromRect;
      }
      else if (config.node.oldBounds) {
        fromRect = config.node.oldBounds;
      } else {
        fromRect = { left: toRect.left, top: toRect.top, width: toRect.width/2, height: toRect.height/2};
      }

      const deltaLeft = fromRect.left - toRect.left;
      const deltaTop = fromRect.top - toRect.top;
      const deltaWidth = (toRect.width > 0) ? fromRect.width / toRect.width : 0;
      const deltaHeight = (toRect.height > 0) ? fromRect.height / toRect.height : 0;

      // console.log('translate(' + deltaLeft + 'px,' + deltaTop + 'px) scale(' + deltaWidth + ',' + deltaHeight + ')');
      this._effect = new KeyframeEffect(config.node, [
        {'transform': 'translate(' + deltaLeft + 'px,' + deltaTop + 'px) scale(' + deltaWidth + ',' + deltaHeight + ')'},
        {'transform': 'none'}
      ], this.timingFromConfig(config));

      this.setPrefixedProperty(config.node, 'transformOrigin', '50% 0');

      config.node.oldBounds = toRect;

      return this._effect;
    },

    complete: function(config) {
      const height = window.getComputedStyle(config.node,null).getPropertyValue("height");
      if (!height)
        config.node.style.display = 'none';
      config.node.style.willChange = 'initial';
      config.node.style.zIndex = 'inherit';
      if (config && typeof config.callback === 'function') {
        console.log(config.callback);
        config.callback(config);
      }
    }

  });

</script>
